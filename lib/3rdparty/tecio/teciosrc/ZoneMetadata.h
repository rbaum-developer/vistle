 #pragma once
#include "ThirdPartyHeadersBegin.h"
#include <algorithm>
#include <string>
#include <vector>
#include "ThirdPartyHeadersEnd.h"
#include "basicTypes.h"
#include "feCellTypeMetrics.h"
#include "FEZoneInfo.h"
#include "IJK.h"
#include "IJKPartitionTree.h"
#include "IJKZoneInfo.h"
#include "MinMaxTree.h"
#include "NonSzZoneFileLocations.h"
#include "PartitionMetadata.h"
#include "writeValueArray.h"
#include "zoneUtil.h"
namespace tecplot { namespace ___3931 { template<typename T> ItemAddress64::SubzoneOffset_t getNumSzFromNumItems(T ___2810) { return static_cast<ItemAddress64::SubzoneOffset_t>((___2810 + 0xFF) >> 8); } namespace { bool isClassicFEZoneType(ZoneType_e ___4689) { return (___4689 == ___4699 || ___4689 == ___4697     || ___4689 == ___4698    || ___4689 == ___4692    || ___4689 == ___4693); } } class ZoneMetadata { private: UNCOPYABLE_CLASS(ZoneMetadata); private: ___4633        ___2675; ZoneType_e         ___2682; int32_t            m_dimension; bool               m_isSZL; ___1842                m_zoneIJK; std::string        ___2493; FaceNeighborMode_e ___2456; double             ___2619; ___1170         ___2620; ___4633        ___2612; ItemAddress64::___2978 m_numPartitions; ___1861 m_partitionTree; public: ___2238<___1879> m_ijkZoneInfos; private: ItemAddress64::SectionOffset_t m_numSections; ___2238<___463> m_secNumElems; ___2238<uint8_t>     m_secCellShape; ___2238<uint8_t>     m_secGridOrder; ___2238<uint8_t>     m_secCellBasisFunc; ___2238<CellNodeIndex_t> m_cornersPerCell; ___2238<CellNodeIndex_t> ___2498; public: ___2238<___2238<___463> > m_secPtnNumCells; ___2238<___2716> m_ptnNumNodes; ___2238<___2238<___463> > m_secPtnFirstCell; ___2238<___2716> m_ptnFirstNode; ___2238<___1842> m_ptnNodeMinIJKs; ___2238<___1842> m_ptnNodeMaxIJKs; ___2238<___2238<ItemAddress64::SubzoneOffset_t> > m_secPtnNumCszs; ___2238<ItemAddress64::SubzoneOffset_t> m_ptnNumNszs; ___2238<ItemAddress64::___2978> m_ptnFileNums; ___2238<___1391>                  m_ptnHeaderFileLocs; ___2238<___1391>                  m_varPtnMinMaxFileLocs; ___2238<MinMaxTree>                 m_varPtnMinMaxTrees; ___2238<PartitionMetadata> m_ptnMetadata; NonSzZoneFileLocations m_nonSzZoneFileLocations; public: ZoneMetadata() : ___2675(-1) , ___2682(___4700) , m_dimension(-1) , m_isSZL(false) , m_zoneIJK() , ___2493() , ___2456(___1288) , ___2619(0.0) , ___2620(___3786) , ___2612(-1) , m_numPartitions(0) , m_numSections(0) { } inline void swap(ZoneMetadata& ___2886) { using std::swap; swap(___2675, ___2886.___2675); swap(___2682, ___2886.___2682); swap(m_dimension, ___2886.m_dimension); swap(m_isSZL, ___2886.m_isSZL); swap(m_zoneIJK, ___2886.m_zoneIJK); swap(___2493, ___2886.___2493); swap(___2456, ___2886.___2456); swap(___2619, ___2886.___2619); swap(___2620, ___2886.___2620); swap(___2612, ___2886.___2612); swap(m_numPartitions, ___2886.m_numPartitions); swap(m_partitionTree, ___2886.m_partitionTree); swap(m_ijkZoneInfos, ___2886.m_ijkZoneInfos);
swap(m_numSections, ___2886.m_numSections); swap(m_secNumElems, ___2886.m_secNumElems); swap(m_secCellShape, ___2886.m_secCellShape); swap(m_secGridOrder, ___2886.m_secGridOrder); swap(m_secCellBasisFunc, ___2886.m_secCellBasisFunc); swap(m_cornersPerCell, ___2886.m_cornersPerCell); swap(___2498, ___2886.___2498); swap(m_secPtnNumCells, ___2886.m_secPtnNumCells); swap(m_ptnNumNodes, ___2886.m_ptnNumNodes); swap(m_secPtnFirstCell, ___2886.m_secPtnFirstCell); swap(m_ptnFirstNode, ___2886.m_ptnFirstNode); swap(m_ptnNodeMinIJKs, ___2886.m_ptnNodeMinIJKs); swap(m_ptnNodeMaxIJKs, ___2886.m_ptnNodeMaxIJKs); swap(m_secPtnNumCszs, ___2886.m_secPtnNumCszs); swap(m_ptnNumNszs, ___2886.m_ptnNumNszs); swap(m_ptnFileNums, ___2886.m_ptnFileNums); swap(m_ptnHeaderFileLocs, ___2886.m_ptnHeaderFileLocs); swap(m_varPtnMinMaxFileLocs, ___2886.m_varPtnMinMaxFileLocs); swap(m_varPtnMinMaxTrees, ___2886.m_varPtnMinMaxTrees); swap(m_ptnMetadata, ___2886.m_ptnMetadata); swap(m_nonSzZoneFileLocations, ___2886.m_nonSzZoneFileLocations); } inline ___4633 zone() const { ENSURE(___2675>=0 && ___2675<MAX_NUM_ZONES); return ___2675; } inline ZoneType_e getZoneType() const { ENSURE(VALID_ENUM(___2682,ZoneType_e)); return ___2682; } inline int32_t getZoneDimension() const { ENSURE(1 <= m_dimension && m_dimension <= 3); return m_dimension; } inline bool isSZL() const { return m_isSZL; } inline ___1842 const& getZoneIJK() const { ENSURE(m_zoneIJK.___2065()); return m_zoneIJK; } inline ___463 ___1764() const { REQUIRE(___2682 != ___4695 && ___2682 != ___4696); if ( ___2682 == ___4701 ) return m_zoneIJK.getNumContiguousCells(); else return m_zoneIJK.___1666(); } inline ___2716 ___1766() const { REQUIRE(___2682 != ___4695 && ___2682 != ___4696); if ( ___2682 == ___4701 ) return m_zoneIJK.___1766(); else return m_zoneIJK.___1668(); } inline CellNodeIndex_t getNumCornersPerCell(ItemAddress64::SectionOffset_t section) const { REQUIRE(___2682 != ___4695 && ___2682 != ___4696); REQUIRE(___2682 == ___4701 || (___2682 != ___4701 && section < checked_numeric_cast<ItemAddress64::SectionOffset_t>(m_cornersPerCell.size()))); if ( ___2682 == ___4701 ) return 8; else return m_cornersPerCell[section]; } inline CellNodeIndex_t getNumNodesPerCell(ItemAddress64::SectionOffset_t section) const { REQUIRE(___2682 != ___4695 && ___2682 != ___4696); REQUIRE(___2682 == ___4701 || (___2682 != ___4701 && section < checked_numeric_cast<ItemAddress64::SectionOffset_t>(___2498.size()))); if ( ___2682 == ___4701 ) return 8; else return ___2498[section]; } inline std::string getName() const { return ___2493; } inline FaceNeighborMode_e getFaceNeighborMode() const { ENSURE(VALID_ENUM(___2456, FaceNeighborMode_e) || ___2456 == ___1286); return ___2456;
} inline double getSolutionTime() const { return ___2619; } inline ___1170 getStrandID() const { REQUIRE(___2620==___3786 || ___4310(___2620)); return ___2620; } inline ___4633 getParentZone() const { REQUIRE(___2612==-1 || (___2612 >= 0 && ___2612 < MAX_NUM_ZONES)); return ___2612; } void setZone(___4633 zone) { REQUIRE(zone >= 0 && zone < MAX_NUM_ZONES); ___2675 = zone; } void setZoneType(ZoneType_e ___4689) { REQUIRE(___2682 == ___4700); REQUIRE(VALID_ENUM(___4689, ZoneType_e)); ___2682 = ___4689; if (___2682 != ZoneType_FEMixed) m_numSections = 1; if (isClassicFEZoneType(___2682)) { if (!m_secNumElems.alloc(m_numSections)      || !m_secCellShape.alloc(m_numSections)     || !m_secGridOrder.alloc(m_numSections)     || !m_secCellBasisFunc.alloc(m_numSections) || !m_cornersPerCell.alloc(m_numSections)   || !___2498.alloc(m_numSections)) throw std::bad_alloc(); switch (___4689) { case ___4699: m_secCellShape[0] = FECellShape_Triangle; m_cornersPerCell[0] = 3; break; case ___4697: m_secCellShape[0] = FECellShape_Quadrilateral; m_cornersPerCell[0] = 4; break; case ___4698: m_secCellShape[0] = FECellShape_Tetrahedron; m_cornersPerCell[0] = 4; break; case ___4692: m_secCellShape[0] = FECellShape_Hexahedron; m_cornersPerCell[0] = 8; break; case ___4693: m_secCellShape[0] = FECellShape_Bar; m_cornersPerCell[0] = 2; break; default: ___476(___1303); break; } ___2498[0] = m_cornersPerCell[0]; m_secGridOrder[0] = 1; m_secCellBasisFunc[0] = FECellBasisFunction_Lagrangian; } } void setZoneDimension(int32_t ___1087) { REQUIRE(1 <= ___1087 && ___1087 <= 3); m_dimension = ___1087; } inline void setIsSZL(bool isSZL) { m_isSZL = isSZL; } inline void setIJKMax(___1842 const& ijkDim) { REQUIRE(___2682==___4701); m_zoneIJK = ijkDim; } inline void setFEDescription( ___463     ___2779, CellNodeIndex_t ___2787, ___2716     ___2819) { REQUIRE(___2682 != ___4701 && ___2682 != ___4695 && ___2682 != ___4696); REQUIRE(___2779>0 && ___2779 <= MAX_NUM_CELLS); REQUIRE(___2819>0 && ___2819 <= MAX_NUM_NODES); REQUIRE((___2682 == ZoneType_FEMixed && ___2787 == 0) || (isClassicFEZoneType(___2682) && 0 < ___2787 && ___2787 <= MAX_NUM_CELL_CORNERS)); m_zoneIJK = ___1842(___2819, ___2779, ___2787); if (isClassicFEZoneType(___2682)) m_secNumElems[0] = m_zoneIJK.___2103(); } inline void setName(std::string const& ___2683) { ___2493 = ___2683; } inline void setFaceNeighborMode(FaceNeighborMode_e ___1282) { REQUIRE(VALID_ENUM(___1282, FaceNeighborMode_e) || ___1282 == ___1286); ___2456 = ___1282; } inline void setSolutionTime(double ___3638) { ___2619 = ___3638; } inline void setStrandID(___1170 ___3783) { ___2620 = ___3783; } inline void setParentZone(___4633 ___2972)
{ REQUIRE(___2972==-1 || (___2972 >= 0 && ___2972 < MAX_NUM_ZONES)); ___2612 = ___2972; } inline ItemAddress64::___2978 getNumPartitions() const { ENSURE(VALID_ITEM_ADDRESS_PARTITION(m_numPartitions-1)); return m_numPartitions; } inline ItemAddress64::SubzoneOffset_t getNumCszsInPartitionSection( ItemAddress64::___2978     ___2975, ItemAddress64::SectionOffset_t section) const { REQUIRE(m_isSZL); REQUIRE(___2975 < m_numPartitions); REQUIRE(section < m_numSections); ItemAddress64::SubzoneOffset_t const numCszs = m_secPtnNumCszs[section][___2975]; ENSURE(IMPLICATION(___2682==___4701, VALID_ITEM_ADDRESS_SUBZONE_OFFSET(numCszs-1))); ENSURE(IMPLICATION(___2682!=___4701, numCszs == getNumSzFromNumItems(m_secPtnNumCells[section][___2975]))); return numCszs; } inline ItemAddress64::SubzoneOffset_t getNumCszsInPartition(ItemAddress64::___2978 ___2975) const { REQUIRE(m_isSZL); REQUIRE(___2975 < m_numPartitions); ItemAddress64::SubzoneOffset_t numCszs = 0; for (ItemAddress64::SectionOffset_t section = 0; section < m_numSections; ++section) numCszs += getNumCszsInPartitionSection(___2975,section); ENSURE(numCszs > 0); return numCszs; } inline ItemAddress64::SubzoneOffset_t getNumNszsInPartition(ItemAddress64::___2978 ___2975) const { REQUIRE(m_isSZL); REQUIRE(___2975 < m_numPartitions); ItemAddress64::SubzoneOffset_t const numNszs = m_ptnNumNszs[___2975]; ENSURE(IMPLICATION(___2682==___4701, VALID_ITEM_ADDRESS_SUBZONE_OFFSET(numNszs-1))); ENSURE(IMPLICATION(___2682!=___4701, numNszs == getNumSzFromNumItems(m_ptnNumNodes[___2975]))); ENSURE(numNszs > 0); return numNszs; } inline void setNumPartitions(ItemAddress64::___2978 numPartitions) { REQUIRE(numPartitions >= 1 && (m_isSZL ? VALID_ITEM_ADDRESS_PARTITION(numPartitions-1) : numPartitions == 1)); m_numPartitions = numPartitions; ENSURE(VALID_ITEM_ADDRESS_PARTITION(m_numPartitions-1)); } ItemAddress64::SectionOffset_t numSections() const { return static_cast<ItemAddress64::SectionOffset_t>(m_numSections); } int64_t numElems(ItemAddress64::SectionOffset_t section) const { REQUIRE(section < checked_numeric_cast<ItemAddress64::SectionOffset_t>(m_secNumElems.size())); return m_secNumElems[section]; } FECellShape_e cellShape(ItemAddress64::SectionOffset_t section) const { REQUIRE(section < checked_numeric_cast<ItemAddress64::SectionOffset_t>(m_secCellShape.size())); return static_cast<FECellShape_e>(m_secCellShape[section]); } FEGridOrder_t gridOrder(ItemAddress64::SectionOffset_t section) const { REQUIRE(section < checked_numeric_cast<ItemAddress64::SectionOffset_t>(m_secGridOrder.size())); return static_cast<FEGridOrder_t>(m_secGridOrder[section]); } FECellBasisFunction_e cellBasisFunc(ItemAddress64::SectionOffset_t section) const { REQUIRE(section < checked_numeric_cast<ItemAddress64::SectionOffset_t>(m_secCellBasisFunc.size())); return static_cast<FECellBasisFunction_e>(m_secCellBasisFunc[section]); } inline void setSectionMetrics(
ItemAddress64::SectionOffset_t numSections, ___3267<int64_t const> const& secNumElems, ___3267<uint8_t const> const& secCellShape, ___3267<uint8_t const> const& secGridOrder, ___3267<uint8_t const> const& secCellBasisFunc) { REQUIRE(___2682 == ZoneType_FEMixed); REQUIRE(m_secNumElems.empty() && m_secCellShape.empty() && m_secGridOrder.empty() && m_secCellBasisFunc.empty()); REQUIRE(!secNumElems.empty() && !secCellShape.empty() && !secGridOrder.empty() && !secCellBasisFunc.empty()); REQUIRE((secNumElems.size() + secCellShape.size() + secGridOrder.size() + secCellBasisFunc.size()) % 4ul == 0 && (secNumElems.size() + secCellShape.size() + secGridOrder.size() + secCellBasisFunc.size()) == 4ul*static_cast<size_t>(numSections)); m_numSections = numSections; if (!m_secNumElems.alloc(m_numSections)      || !m_secCellShape.alloc(m_numSections)     || !m_secGridOrder.alloc(m_numSections)     || !m_secCellBasisFunc.alloc(m_numSections) || !m_cornersPerCell.alloc(m_numSections)   || !___2498.alloc(m_numSections)) throw std::bad_alloc(); ___1170 numEdges = 0; ___1170 numFacesOrEdges = 0; ___1170 numHighOrderNodes = 0; ___1170 numNaturalSubElems = 0; ___1170 const MAX_NUM_FACES_PER_ELEM = 6; std::vector<___1170> numCornersPerFaceOrEdge(MAX_NUM_FACES_PER_ELEM); std::vector<___1170> numNodesPerFaceOrEdge(MAX_NUM_FACES_PER_ELEM); std::vector<___1170> numHighOrderNodesPerFaceOrEdge(MAX_NUM_FACES_PER_ELEM); for (ItemAddress64::SectionOffset_t section = 0; section < numSections; ++section) { m_secNumElems[section]      = secNumElems[section]; m_secCellShape[section]     = secCellShape[section]; m_secGridOrder[section]     = secGridOrder[section]; m_secCellBasisFunc[section] = secCellBasisFunc[section]; tecplot::feCellTypeMetrics( static_cast<FECellShape_e>(m_secCellShape[section]), static_cast<FEGridOrder_t>(m_secGridOrder[section]), static_cast<FECellBasisFunction_e>(m_secCellBasisFunc[section]), numEdges, numFacesOrEdges, m_cornersPerCell[section], ___2498[section], numHighOrderNodes, numNaturalSubElems, numCornersPerFaceOrEdge.begin(), numNodesPerFaceOrEdge.begin(), numHighOrderNodesPerFaceOrEdge.begin()); } } inline void addPartitionTreeItem(ItemAddress64::___2978 ___2975, ___1842 const& ___2472, ___1842 const& ___2362) { m_partitionTree.___13(___2975, ___2472, ___2362); } inline ItemAddress64::___2978 getPartitionForIJK(___1842 const& ___1841) const { if (m_numPartitions == 1) { return 0; } else { ___1851 ___2476(___1841.i(), ___1841.___2103(), ___1841.___2132()); ___1851 ___2370(___1841.i(), ___1841.___2103(), ___1841.___2132()); std::vector<___1862> ___2097; m_partitionTree.query(boost::geometry::index::intersects(___1853(___2476, ___2370)), std::back_inserter(___2097)); return (___2097.empty() ? ItemAddress64::INVALID_PARTITION : ___2097[0].second); } } inline std::vector<ItemAddress64::___2978> getPartitionsForIJKRange(___1842 const& ijkMin, ___1842 const& ___1859) const { if (m_numPartitions == 1) { return std::vector<ItemAddress64::___2978>(1, 0);
} else { ___1851 ___2476(ijkMin.i(), ijkMin.___2103(), ijkMin.___2132()); ___1851 ___2370(___1859.i(), ___1859.___2103(), ___1859.___2132()); std::vector<___1862> ___2097; m_partitionTree.query(boost::geometry::index::intersects(___1853(___2476, ___2370)), std::back_inserter(___2097)); std::vector<ItemAddress64::___2978> ___3356; ___3356.reserve(___2097.size()); for (std::vector<___1862>::const_iterator it = ___2097.begin(); it != ___2097.end(); ++it) ___3356.push_back(it->second); std::sort(___3356.begin(), ___3356.end()); return ___3356; } } inline std::vector<ItemAddress64::___2978> getPartitionsForIndexPlane(IJKPlanes_e whichPlane, ___2716 planeIndex) const { if (m_numPartitions == 1) { return std::vector<ItemAddress64::___2978>(1, 0); } else { ___1842 planeMin(0, 0, 0); ___1842 planeMax(getZoneIJK() - 1); switch (whichPlane) { case ___1865: planeMin.setI(planeIndex); planeMax.setI(planeIndex); break; case ___1870: planeMin.setJ(planeIndex); planeMax.setJ(planeIndex); break; case ___1872: planeMin.___3495(planeIndex); planeMax.___3495(planeIndex); break; default: ___476(___1303); break; } ___1851 ___2476(planeMin.i(), planeMin.___2103(), planeMin.___2132()); ___1851 ___2370(planeMax.i(), planeMax.___2103(), planeMax.___2132()); std::vector<___1862> ___2097; m_partitionTree.query(boost::geometry::index::intersects(___1853(___2476, ___2370)), std::back_inserter(___2097)); std::vector<ItemAddress64::___2978> ___3356; ___3356.reserve(___2097.size()); for (std::vector<___1862>::const_iterator it = ___2097.begin(); it != ___2097.end(); ++it) ___3356.push_back(it->second); std::sort(___3356.begin(), ___3356.end()); return ___3356; } } inline std::vector<ItemAddress64::___2978> getPartitionsForIndexLine(IJKLines_e whichLine, ___2716 mIndex, ___2716 nIndex) const { if (m_numPartitions == 1) { return std::vector<ItemAddress64::___2978>(1, 0); } else { ___1842 lineMin(0, 0, 0); ___1842 lineMax(getZoneIJK() - 1); switch (whichLine) { case ___1855: lineMin.setJ(mIndex); lineMin.___3495(nIndex); lineMax.setJ(mIndex); lineMax.___3495(nIndex); break; case ___1857: lineMin.setI(mIndex); lineMin.___3495(nIndex); lineMax.setI(mIndex); lineMax.___3495(nIndex); break; case ___1858: lineMin.setI(mIndex); lineMin.setJ(nIndex); lineMax.setI(mIndex); lineMax.setJ(nIndex); break; default: ___476(___1303); break; } ___1851 ___2476(lineMin.i(), lineMin.___2103(), lineMin.___2132()); ___1851 ___2370(lineMax.i(), lineMax.___2103(), lineMax.___2132()); std::vector<___1862> ___2097; m_partitionTree.query(boost::geometry::index::intersects(___1853(___2476, ___2370)), std::back_inserter(___2097)); std::vector<ItemAddress64::___2978> ___3356; ___3356.reserve(___2097.size()); for (std::vector<___1862>::const_iterator it = ___2097.begin(); it != ___2097.end(); ++it) ___3356.push_back(it->second); std::sort(___3356.begin(), ___3356.end()); return ___3356; } } inline bool ijkPartitionMetadataIsLoaded(ItemAddress64::___2978 ___2975) const { return ___2975 < m_ijkZoneInfos.size() && m_ijkZoneInfos[___2975].___2065();
} inline ItemAddress64 cellAddressAtIJKPaddedCellIndex(___463 paddedCellIndex) const { REQUIRE(paddedCellIndex < getZoneIJK().getNumPaddedCells()); ItemAddress64 ___449; if (getNumPartitions() == 1) { ___449 = m_ijkZoneInfos[0].cellAddressAtPaddedCellIndex(paddedCellIndex); } else { ___1842 const ___4629 = getZoneIJK().ijkAtOffset(paddedCellIndex); ItemAddress64::___2978 const ___2975 = getPartitionForIJK(___4629); ___476(ijkPartitionMetadataIsLoaded(___2975)); ___1842 partitionIJK = ___4629 - m_ptnNodeMinIJKs[___2975]; if (partitionIJK.i() == m_ijkZoneInfos[___2975].___2893().i() - 1) partitionIJK.setI(partitionIJK.i() - 1); if (partitionIJK.___2103() == m_ijkZoneInfos[___2975].___2893().___2103() - 1) partitionIJK.setJ(partitionIJK.___2103() - 1); ___449 = m_ijkZoneInfos[___2975].cellAddressAtCellIJK(partitionIJK); ENSURE(___449.___2975() == ___2975); } return ___449; } inline ItemAddress64 nodeAddressAtIJKNodeIndex(___2716 ___2714) const { ItemAddress64 nodeAddress; if (getNumPartitions() == 1) { nodeAddress = m_ijkZoneInfos[0].nodeAddressAtNodeIndex(___2714); } else { ___1842 const ___4629 = getZoneIJK().ijkAtOffset(___2714); ItemAddress64::___2978 const ___2975 = getPartitionForIJK(___4629); ___476(ijkPartitionMetadataIsLoaded(___2975)); ___1842 const partitionIJK = ___4629 - m_ptnNodeMinIJKs[___2975]; nodeAddress = m_ijkZoneInfos[___2975].nodeAddressAtNodeIJK(partitionIJK); ENSURE(nodeAddress.___2975() == ___2975); } return nodeAddress; } ItemAddress64 cellAddressAtFECellIndex(___463 zoneCellIndex) const { REQUIRE(zoneCellIndex < ___1764()); ItemAddress64::___2978 ___2975 = 0; ItemAddress64::SectionOffset_t section = 0; ItemAddress64::___2978 const numPartitions = getNumPartitions(); for (; ___2975 < numPartitions; ++___2975) { bool foundLocation = false; for (section = 0; section < m_numSections; ++section) { ___463 const numSecPtnCells = m_secPtnNumCells[section][___2975]; foundLocation = zoneCellIndex < numSecPtnCells; if (foundLocation) break; zoneCellIndex -= numSecPtnCells; } if (foundLocation) break; } ___476(___2975 < numPartitions && section < m_numSections); ItemAddress64::SubzoneOffset_t  const szOffset = ItemAddress64::SubzoneOffset_t(zoneCellIndex >> ItemAddress64::ItemOffsetBitSize); ItemAddress64::ItemOffset_t const itemOffset = ItemAddress64::ItemOffset_t(zoneCellIndex & ItemAddress64::MAX_ITEM_OFFSET); return ItemAddress64(___2975, section, szOffset, itemOffset); } ItemAddress64 szlCellAddressAtFEUniformCellAddress(ItemAddress64 const& ___449) const { REQUIRE(___449.___2063()); REQUIRE(___449.sectionOffset() < m_numSections); REQUIRE(___449.___4256() < m_secNumElems[___449.sectionOffset()]); ItemAddress64::___2978 ___2975 = 0; ItemAddress64::___2978 const numPartitions = getNumPartitions(); ItemAddress64::___4259 secUniformOffset = ___449.___4256(); for (; ___2975 < numPartitions; ++___2975)
{ bool foundLocation = false; ___463 const numSecPtnCells = m_secPtnNumCells[___449.sectionOffset()][___2975]; foundLocation = secUniformOffset < numSecPtnCells; if (foundLocation) break; secUniformOffset -= numSecPtnCells; if (foundLocation) break; } ___476(___2975 < numPartitions); ItemAddress64::SubzoneOffset_t  const szOffset = ItemAddress64::SubzoneOffset_t(secUniformOffset >> ItemAddress64::ItemOffsetBitSize); ItemAddress64::ItemOffset_t const itemOffset = ItemAddress64::ItemOffset_t(secUniformOffset & ItemAddress64::MAX_ITEM_OFFSET); return ItemAddress64(___2975, ___449.sectionOffset(), szOffset, itemOffset); } ItemAddress64 uniformCellAddressAtFESzlCellAddress(ItemAddress64 const& ___449) const { REQUIRE(___449.isSzlItem()); REQUIRE(VALID_ITEM_ADDRESS(___449)); ___463 ___4256 = (___463(___449.subzoneOffset()) <<ItemAddress64::ItemOffsetBitSize) | ___449.itemOffset(); ItemAddress64::___2978 ___2975 = ___449.___2975(); ItemAddress64::SectionOffset_t const section = ___449.sectionOffset(); while (___2975 > 0) { --___2975; ___4256 += m_secPtnNumCells[section][___2975]; } return ItemAddress64{section, ___4256}; } ItemAddress64 nodeAddressAtFENodeIndex(___2716 zoneNodeIndex) const { REQUIRE(zoneNodeIndex < ___1766()); ItemAddress64::___2978 ___2975 = 0; ItemAddress64::___2978 numPartitions = getNumPartitions(); if ( numPartitions > 1 ) { while (true) { ___2716 const numPtnItems = m_ptnNumNodes[___2975]; if (zoneNodeIndex < numPtnItems) break; zoneNodeIndex -= numPtnItems; ++___2975; ___476(___2975 < numPartitions); } } ItemAddress64::SubzoneOffset_t  const szOffset = ItemAddress64::SubzoneOffset_t(zoneNodeIndex >> ItemAddress64::ItemOffsetBitSize); ItemAddress64::ItemOffset_t const itemOffset = ItemAddress64::ItemOffset_t(zoneNodeIndex & ItemAddress64::MAX_ITEM_OFFSET); return ItemAddress64(___2975, 0/*section*/, szOffset, itemOffset); } ___2716 nodeIndexAtFENodeAddress(ItemAddress64 const& nodeAddress) const { REQUIRE(m_isSZL); REQUIRE(VALID_ITEM_ADDRESS(nodeAddress)); ___2716 ___2714 = (___2716(nodeAddress.subzoneOffset())<<ItemAddress64::ItemOffsetBitSize) | nodeAddress.itemOffset(); ItemAddress64::___2978 ___2975 = nodeAddress.___2975(); while (___2975 > 0) { --___2975; ___2714 += m_ptnNumNodes[___2975]; } return ___2714; } ItemAddress64 paddedUniformCellAddressAtIJKSzlCellAddress(ItemAddress64 const& ___449) const { if (getNumPartitions() == 1) { return ItemAddress64{m_ijkZoneInfos[0].paddedCellIndexAtCellAddress(___449)}; } else { ItemAddress64::___2978 const ___2975 = ___449.___2975(); ___476(ijkPartitionMetadataIsLoaded(___2975)); ___1842 const cellIJK = m_ptnNodeMinIJKs[___2975] + m_ijkZoneInfos[___2975].cellIJKAtCellAddress(___449); return ItemAddress64{getZoneIJK().offsetAtIJK(cellIJK)}; } } ___2716 nodeIndexAtIJKNodeAddress(ItemAddress64 const& nodeAddress) const
{ REQUIRE(getZoneType() == ___4701); ___2716 ___2714; if (getNumPartitions() == 1) { ___2714 = m_ijkZoneInfos[0].nodeIndexAtNodeAddress(nodeAddress); } else { ItemAddress64::___2978 const ___2975 = nodeAddress.___2975(); ___476(ijkPartitionMetadataIsLoaded(___2975)); ___1842 const nodeIJK = m_ptnNodeMinIJKs[___2975] + m_ijkZoneInfos[___2975].nodeIJKAtNodeAddress(nodeAddress); ___2714 = getZoneIJK().offsetAtIJK(nodeIJK); } ENSURE(___2714 < ___1766()); return ___2714; } ___463 getNumIJKFaceNeighbors( ItemAddress64 const& ___449, FaceIndex_t          ___455) const { REQUIRE(m_isSZL); REQUIRE(___455 < NUM_IJK_CELL_FACES); ItemAddress64::___2978 const ___2975 = ___449.___2975(); ___476(ijkPartitionMetadataIsLoaded(___2975)); return m_ijkZoneInfos[___2975].getNumIJKFaceNeighbors(___449, ___455); } void getIJKFaceNeighbor( ItemAddress64 const& ___449, FaceIndex_t          ___455, ___463          neighborOffset, ItemAddress64&       fnCoord, ___4633&         fnZone) const { REQUIRE(___449.isSzlItem()); REQUIRE(m_isSZL); REQUIRE(___455 < NUM_IJK_CELL_FACES); REQUIRE(neighborOffset < getNumIJKFaceNeighbors(___449, ___455)); ItemAddress64::___2978 const ___2975 = ___449.___2975(); ___476(ijkPartitionMetadataIsLoaded(___2975)); m_ijkZoneInfos[___2975].getIJKFaceNeighbor(___449, ___455, neighborOffset, fnCoord, fnZone); if (fnCoord == ItemAddress64(___2747) && getNumPartitions() > 1) { ___1842 neighborCellIJK = m_ijkZoneInfos[___2975].cellIJKAtCellAddress(___449) + m_ptnNodeMinIJKs[___2975] + ___1879::ijkFaceNeighborOffset[___455]; if (0 <= neighborCellIJK && neighborCellIJK < getZoneIJK()) { ItemAddress64::___2978 neighborPartition = getPartitionForIJK(neighborCellIJK); neighborCellIJK -= m_ptnNodeMinIJKs[neighborPartition]; if (neighborCellIJK <= m_ijkZoneInfos[neighborPartition].___2196()) fnCoord = m_ijkZoneInfos[neighborPartition].cellAddressAtCellIJK(neighborCellIJK); } } } void getIJKFaceNeighbors( ItemAddress64 const&     ___449, FaceIndex_t              ___455, ___3267<ItemAddress64>& cellNeighbors, ___3267<___4633>&   zoneNeighbors, bool&                    isFaceCompletelyObscured) const { REQUIRE(VALID_ITEM_ADDRESS(___449)); REQUIRE(___455 < NUM_IJK_CELL_FACES); REQUIRE(cellNeighbors.empty()); REQUIRE(zoneNeighbors.empty()); ItemAddress64 szlCellAddr; bool const isCellAddressUniform = ___449.___2063(); if (isCellAddressUniform) { ___463 const paddedCellIndex = ___463(___449.___4256()); szlCellAddr = cellAddressAtIJKPaddedCellIndex(paddedCellIndex); } else { szlCellAddr = ___449; } ___463 const numNeighbors = getNumIJKFaceNeighbors(szlCellAddr, ___455); ___476(numNeighbors != 0); isFaceCompletelyObscured = true; cellNeighbors.reserve(numNeighbors); cellNeighbors.___3501(numNeighbors); zoneNeighbors.reserve(numNeighbors); zoneNeighbors.___3501(numNeighbors);
for (___463 n = 0; n < numNeighbors; ++n) { ItemAddress64 fnCoord; ___4633 fnZone; getIJKFaceNeighbor(szlCellAddr, ___455, n, fnCoord, fnZone); if (fnCoord.___2063() && fnCoord.___4256() == ___2747) { ___476(fnZone == ___2748); cellNeighbors[n] = ItemAddress64(___2747); zoneNeighbors[n] = ___2748; } else if (isCellAddressUniform) { cellNeighbors[n] = paddedUniformCellAddressAtIJKSzlCellAddress(fnCoord); zoneNeighbors[n] = fnZone; } else { cellNeighbors[n] = fnCoord; zoneNeighbors[n] = fnZone; } } ENSURE(!cellNeighbors.empty()); ENSURE(cellNeighbors.size() == zoneNeighbors.size()); } }; }}
