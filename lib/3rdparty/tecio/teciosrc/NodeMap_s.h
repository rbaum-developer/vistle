 #pragma once
#include "ThirdPartyHeadersBegin.h"
#include <fstream>
#include <vector>
#include <boost/make_shared.hpp>
#include <boost/shared_ptr.hpp>
#include "ThirdPartyHeadersEnd.h"
#include "MASTER.h"
#include "GLOBAL.h"
#include "CodeContract.h"
#include "basicTypes.h"
#include "fileio.h"
namespace tecplot { namespace tecioszl { struct ___2728 { typedef boost::shared_ptr<___2728> Ptr; static Ptr makePtr( int64_t maxNodeValue, int64_t cellCount, int32_t nodesPerCell); static Ptr makePtr( int64_t maxNodeValue, std::vector<int64_t> const& numCellsPerSection, std::vector<int32_t> const& numNodesPerCellPerSection); static OffsetDataType_e getRawItemTypeForMaxNodeValue(int64_t maxNodeValue); int64_t m_maxNodeValue; std::vector<int64_t> m_numCellsPerSection; std::vector<int32_t> m_numNodesPerCellPerSection; ___2728(int64_t maxNodeValue, int64_t cellCount, int32_t nodesPerCell); ___2728( int64_t maxNodeValue, std::vector<int64_t> const& numCellsPerSection, std::vector<int32_t> const& numNodesPerCellPerSection); virtual ~___2728(); OffsetDataType_e getRawItemType() const; int64_t expectedValueCount() const; virtual int64_t storedValueCount() const = 0; virtual void appendValue(int64_t value) = 0; virtual void ___3502(int32_t section, int64_t ___2863, int64_t value) = 0; virtual int64_t value(int32_t section, int64_t ___2863) const = 0; virtual void* getRawPtr(int32_t section) = 0; virtual void writeToFile(tecplot::___3931::FileWriterInterface& outputFile, bool ___4477) const = 0; virtual uint64_t sizeInFile(bool ___4477) const = 0; static Ptr makePtr(tecplot::___3931::___1397& inputFile, bool readASCII); protected: virtual void readValuesFromFile(tecplot::___3931::___1397& inputFile, bool readASCII) = 0; }; struct AppendContext { AppendContext(___2728 const& ___2721) : ___2495(___2721) , m_section(0) , m_nodeInSection(0) , m_nodeInCell(0) , m_numNodesInSection(0) , m_numNodesInCell(0) { skipEmptySections(); if (!___2495.m_numCellsPerSection.empty()) { m_numNodesInCell = ___2495.m_numNodesPerCellPerSection[m_section]; m_numNodesInSection = m_numNodesInCell * ___2495.m_numCellsPerSection[m_section]; } } void skipEmptySections() { REQUIRE(m_section <= ___2495.m_numCellsPerSection.size()); while (m_section < ___2495.m_numCellsPerSection.size() && ___2495.m_numCellsPerSection[m_section] == 0) ++m_section; ENSURE(m_section <= ___2495.m_numCellsPerSection.size()); } void operator++() { ++m_nodeInSection; ++m_nodeInCell; if (m_nodeInSection == m_numNodesInSection) { m_nodeInSection = 0; m_nodeInCell = 0; ++m_section; skipEmptySections(); if (m_section < ___2495.m_numCellsPerSection.size()) { m_numNodesInCell = ___2495.m_numNodesPerCellPerSection[m_section]; m_numNodesInSection = m_numNodesInCell * ___2495.m_numCellsPerSection[m_section]; } } else if (m_nodeInCell == m_numNodesInCell) { m_nodeInCell = 0; } } ___2728 const& ___2495; size_t           m_section; size_t           m_nodeInSection; size_t           m_nodeInCell; size_t           m_numNodesInSection; size_t           m_numNodesInCell; }; template <typename T> class TypedNodeMap : public ___2728 { public: TypedNodeMap(int64_t maxNodeValue, int64_t cellCount, int32_t nodesPerCell); TypedNodeMap( int64_t maxNodeValue, std::vector<int64_t> const& numCellsPerSection,
std::vector<int32_t> const& numNodesPerCellPerSection); virtual int64_t storedValueCount() const; virtual void appendValue(int64_t value); virtual void ___3502(int32_t section, int64_t ___2863, int64_t value); virtual int64_t value(int32_t section, int64_t ___2863) const; virtual void* getRawPtr(int32_t section); virtual void writeToFile(tecplot::___3931::FileWriterInterface& outputFile, bool ___4477) const; virtual uint64_t sizeInFile(bool ___4477) const; protected: virtual void readValuesFromFile(tecplot::___3931::___1397& inputFile, bool readASCII); private: std::vector<std::vector<T> > m_nodes; AppendContext m_appendContext; }; template<typename T> TypedNodeMap<T>::TypedNodeMap(int64_t maxNodeValue, int64_t cellCount, int32_t nodesPerCell) : ___2728(maxNodeValue, cellCount, nodesPerCell) , m_nodes(m_numCellsPerSection.size()) , m_appendContext(*this) { REQUIRE(maxNodeValue < static_cast<int64_t>(std::numeric_limits<T>::max())); } template<typename T> TypedNodeMap<T>::TypedNodeMap( int64_t maxNodeValue, std::vector<int64_t> const& numCellsPerSection, std::vector<int32_t> const& numNodesPerCellPerSection) : ___2728( maxNodeValue, numCellsPerSection, numNodesPerCellPerSection) , m_nodes(m_numCellsPerSection.size()) , m_appendContext(*this) { REQUIRE(maxNodeValue < static_cast<int64_t>(std::numeric_limits<T>::max())); REQUIRE(numCellsPerSection.size() <= 16ul); REQUIRE(numCellsPerSection.size() == numNodesPerCellPerSection.size()); } template<typename T> int64_t TypedNodeMap<T>::storedValueCount() const { REQUIRE(m_nodes.size() == m_numCellsPerSection.size()); int64_t numValues = 0; for (size_t section = 0; section < m_numCellsPerSection.size(); ++section) numValues += static_cast<int64_t>(m_nodes[section].size()); return numValues; } template<typename T> void TypedNodeMap<T>::appendValue(int64_t value) { REQUIRE(value < std::numeric_limits<T>::max()); REQUIRE(m_appendContext.m_section < m_numCellsPerSection.size()); std::vector<T>& nodes = m_nodes[m_appendContext.m_section]; if (nodes.empty()) nodes.reserve(m_numCellsPerSection[m_appendContext.m_section] * m_numNodesPerCellPerSection[m_appendContext.m_section]); nodes.push_back(static_cast<T>(value)); ++m_appendContext; } template<typename T> void TypedNodeMap<T>::___3502(int32_t section, int64_t ___2863, int64_t value) { REQUIRE(section < checked_numeric_cast<int32_t>(m_nodes.size())); REQUIRE(value < std::numeric_limits<T>::max()); std::vector<T>& nodes = m_nodes[section]; if (nodes.empty() || nodes.size() <= (size_t)___2863) nodes.resize(___2863 + 1); nodes[___2863] = static_cast<T>(value); } template<typename T> int64_t TypedNodeMap<T>::value(int32_t section, int64_t ___2863) const { REQUIRE(section < checked_numeric_cast<int32_t>(m_nodes.size())); REQUIRE(0 <= ___2863 && ___2863 < checked_numeric_cast<int64_t>(m_nodes[section].size())); return m_nodes[section][___2863]; } template<typename T> void* TypedNodeMap<T>::getRawPtr(int32_t section) { REQUIRE(section < checked_numeric_cast<int32_t>(m_nodes.size()));
std::vector<T>& nodes = m_nodes[section]; if (nodes.empty()) nodes.assign(m_numNodesPerCellPerSection[section] * m_numCellsPerSection[section], 0); return nodes.data(); } template<typename T> void TypedNodeMap<T>::writeToFile(tecplot::___3931::FileWriterInterface& outputFile, bool ___4477) const { REQUIRE(m_nodes.size() == m_numCellsPerSection.size()); REQUIRE(m_numNodesPerCellPerSection.size() == m_numCellsPerSection.size()); tecplot::tecioszl::writeScalar(outputFile, m_maxNodeValue, ___4477); tecplot::tecioszl::writeVector(outputFile, m_numCellsPerSection, ___4477); tecplot::tecioszl::writeVector(outputFile, m_numNodesPerCellPerSection, ___4477); for (size_t section = 0; section < m_numCellsPerSection.size(); ++section) tecplot::tecioszl::writeVector(outputFile, m_nodes[section], ___4477); } template<typename T> uint64_t TypedNodeMap<T>::sizeInFile(bool ___4477) const { REQUIRE(m_nodes.size() == m_numCellsPerSection.size()); REQUIRE(m_numNodesPerCellPerSection.size() == m_numCellsPerSection.size()); uint64_t totalSize = 0; totalSize += tecplot::tecioszl::scalarSizeInFile(m_maxNodeValue, ___4477); totalSize += tecplot::tecioszl::vectorSizeInFile(m_numCellsPerSection, ___4477); totalSize += tecplot::tecioszl::vectorSizeInFile(m_numNodesPerCellPerSection, ___4477); for (size_t section = 0; section < m_numCellsPerSection.size(); ++section) totalSize += tecplot::tecioszl::vectorSizeInFile(m_nodes[section], ___4477); return totalSize; } template<typename T> void TypedNodeMap<T>::readValuesFromFile(tecplot::___3931::___1397& inputFile, bool readASCII) { REQUIRE(m_nodes.size() == m_numCellsPerSection.size()); REQUIRE(m_numNodesPerCellPerSection.size() == m_numCellsPerSection.size()); for (size_t section = 0; section < m_numCellsPerSection.size(); ++section) tecplot::tecioszl::readVector(inputFile, m_nodes[section], readASCII); } }}
