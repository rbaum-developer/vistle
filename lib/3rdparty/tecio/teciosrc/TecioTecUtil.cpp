#include "TecioTecUtil.h"
#include "ThirdPartyHeadersBegin.h"
#include <algorithm>
#include <cfloat>
#include <cstring>
#include <limits>
#include <map>
#include <set>
#include <sstream>
#include <tuple>
#include <boost/shared_ptr.hpp>
#include "ThirdPartyHeadersEnd.h"
#include "MASTER.h"
#include "GLOBAL.h"
#include "feCellTypeMetrics.h"
#include "FieldData_s.h"
#include "NodeMap_s.h"
#include "NodeToElemMap_s.h"
#include "zoneUtil.h"
 #if defined TECIOMPI
struct ___2120 {}; struct ___2663 {};
 #else
#include "JobControl_s.h"
#include "Mutex_s.h"
 #endif
using namespace tecplot::___3931; namespace { tecplot::tecioszl::___1360* toSzlioFieldData(___1359 ___1349) { return reinterpret_cast<tecplot::tecioszl::___1360*>(___1349); } ___1359 toTecUtilFieldData(tecplot::tecioszl::___1360* ___1349) { return reinterpret_cast<___1359>(___1349); } } namespace { tecplot::tecioszl::___2728* toSzlioNodeMap(___2725 ___2721) { return reinterpret_cast<tecplot::tecioszl::___2728*>(___2721); } ___2725 toTecUtilNodeMap(tecplot::tecioszl::___2728* ___2721) { return reinterpret_cast<___2725>(___2721); } } namespace { tecplot::tecioszl::___2741* toSzlioNodeToElemMap(___2740 nodeToElem) { return reinterpret_cast<tecplot::tecioszl::___2741*>(nodeToElem); } ___2740 toTecUtilNodeToElemMap(tecplot::tecioszl::___2741* nodeToElem) { return reinterpret_cast<___2740>(nodeToElem); } } struct StringList_s { std::vector<std::string> m_strings; }; namespace tecplot { namespace tecioszl { namespace { char* copyString(std::string const& str) { char* ___3356 = new char[strlen(str.c_str()) + 1]; strcpy(___3356, str.c_str()); return ___3356; } } ___4014::___4014(___3968& tecioData) : m_tecioData(tecioData) {} ___4014::~___4014() {} void ___4014::___3815(char** ___3853) const { delete[] *___3853; *___3853 = 0; } void ___4014::___3825(___3837* ___3817) const { delete *___3817; *___3817 = 0; } ___2225 ___4014::___3830(___3837 ___3817) const { return (___2225)___3817->m_strings.size(); } char* ___4014::___3831(___3837 ___3817, ___2225 ___3851) const { REQUIRE(0 < ___3851 && ___3851 <= ___3830(___3817)); return copyString(___3817->m_strings[___3851 - 1]); } ___264 ___4014::___235() const { return m_tecioData.dataSetAuxData().get(); } ___264 ___4014::___274(___4633 zone) const { REQUIRE(m_tecioData.validZoneNum(zone)); Zone_s const* zonePtr = m_tecioData.zonePtr(zone); return zonePtr->___2343.get(); } ___264 ___4014::___273(___4349 ___4333) const { REQUIRE(0 < ___4333 && ___4333 <= static_cast<___1170>(m_tecioData.variableNames().size())); return m_tecioData.varAuxData()[___4333 - 1].get(); } int32_t ___4014::___247(___264 ___265) const { return static_cast<int32_t>(___265->m_auxDataItems.size()); } void ___4014::___243(___264 ___265, int32_t index, char** ___2683, ___90* value, AuxDataType_e* type, ___372* ___3359) const { REQUIRE(VALID_REF(___265)); REQUIRE(0 < index && (size_t)index <= ___265->m_auxDataItems.size()); REQUIRE(VALID_REF(___2683) && *___2683 == 0); REQUIRE(VALID_REF(value) && *value == 0); REQUIRE(VALID_REF(type)); REQUIRE(VALID_REF(___3359)); AuxData_s::AuxDataItem const& auxDataItem = ___265->m_auxDataItems[index - 1]; *___2683 = copyString(auxDataItem.___2493);
*value = reinterpret_cast<___90>(copyString(auxDataItem.___2665)); *type = ___270; *___3359 = auxDataItem.m_retain; } ___372 ___4014::___894() const { return static_cast<___372>(m_tecioData.___894()); } ___372 ___4014::datasetGetTitle(char** datasetTitle) const { *datasetTitle = copyString(m_tecioData.___4175()); return ___4224; } int32_t ___4014::___887() const { return 0; } ___3499 ___4014::datasetGetRelevantZones(double  , double /*solutionTimeMax*/, ___372 /*ignoreStaticZones*/) const { ___476(___1303); return ___3499(0); } ___4633 ___4014::___889() const { REQUIRE(___894()); return static_cast<___4633>(m_tecioData.___2844()); } ___4349 ___4014::___888() const { REQUIRE(___894()); return static_cast<___4349>(m_tecioData.variableNames().size()); } ___4262 ___4014::datasetGetUniqueID() const { REQUIRE(___894()); return static_cast<___4262>(0); } ___4349 ___4014::___4342(char ___214) const { REQUIRE('X' <= ___214 && ___214 <= 'Z'); return static_cast<___4349>(___214 - 'X' + 1); } ___372 ___4014::___4341(___4349 ___4365, char** ___4359) const { REQUIRE(0 < ___4365 && ___4365 <= static_cast<___4349>(m_tecioData.variableNames().size())); REQUIRE(VALID_REF(___4359) && !*___4359); *___4359 = copyString(m_tecioData.variableNames()[___4365 - 1]); return ___4224; } int32_t ___4014::___4340(___4349 ___4365) const { REQUIRE(0 < ___4365 && ___4365 <= static_cast<___4349>(m_tecioData.variableNames().size())); return static_cast<int32_t>(m_tecioData.varAuxData()[___4365]->m_auxDataItems.size()); } ___372 ___4014::___4635(___4633 ___4655) const { return (m_tecioData.zonePtr(___4655) != NULL) ? ___4224 : ___1303; } ___372 ___4014::___4611(___3499* ___1151) const { try { std::set<___3491>* ___3356 = new std::set<___3491>(m_tecioData.unflushedZoneSet()); *___1151 = reinterpret_cast<___3499>(___3356); return ___4224; } catch (...) { return ___1303; } } ZoneType_e ___4014::___4617(___4633 ___4655) const { REQUIRE(m_tecioData.validZoneNum(___4655)); Zone_s const* zonePtr = m_tecioData.zonePtr(___4655); return zonePtr->___2682; } ___372 ___4014::zoneGetNumSections(___4262 ASSERT_ONLY(dataSetID), ___4633 ___4655, ___1170* numSections) const { REQUIRE(dataSetID == 0); REQUIRE(m_tecioData.validZoneNum(___4655)); REQUIRE(___4617(___4655) != ___4701 && ___4617(___4655) != ___4695 && ___4617(___4655) != ___4696); ZoneType_e const ___4689 = ___4617(___4655); if (___4689 == ___4699 || ___4689 == ___4697     || ___4689 == ___4698    || ___4689 == ___4692    || ___4689 == ___4693) { *numSections = 1; } else { ___476(___4689 == ZoneType_FEMixed); Zone_s const* zonePtr = m_tecioData.zonePtr(___4655);
*numSections = checked_numeric_cast<___1170>(zonePtr->m_cellShapes.size()); } ENSURE(*numSections >= 1); return ___4224; } namespace { std::pair<___1170 ,___1170/*___2819*/> numNodesForFECellType( FECellShape_e         cellShape, ___1170            gridOrder, FECellBasisFunction_e basisFn) { ___1170 numEdges; ___1170 numFacesOrEdges; ___1170 ___2787; ___1170 ___2819; ___1170 numHighOrderNodes; ___1170 numNaturalSubElems; ___1170 const MAX_NUM_FACES_PER_ELEM = 6; std::vector<___1170> numCornersPerFaceOrEdge(MAX_NUM_FACES_PER_ELEM); std::vector<___1170> numNodesPerFaceOrEdge(MAX_NUM_FACES_PER_ELEM); std::vector<___1170> numHighOrderNodesPerFaceOrEdge(MAX_NUM_FACES_PER_ELEM); tecplot::feCellTypeMetrics( cellShape, gridOrder, basisFn, numEdges, numFacesOrEdges, ___2787, ___2819, numHighOrderNodes, numNaturalSubElems, numCornersPerFaceOrEdge.begin(), numNodesPerFaceOrEdge.begin(), numHighOrderNodesPerFaceOrEdge.begin()); ENSURE(2 <= ___2787 && ___2787 <= ___2819 && ___2819 <= static_cast<___1170>(MAX_NODES_PER_ELEM)); return std::make_pair(___2787, ___2819); } } namespace { ___372 getSectionMetrics(Zone_s const& zone, ___1170             section, FECellShape_e&         cellShape, ___1170&            gridOrder, FECellBasisFunction_e& basisFn, ___2225&             numElements, ___1170&            numCornersPerElem, ___1170&            numNodesPerElem) { if (zone.___2682 == ZoneType_FEMixed) { cellShape = zone.m_cellShapes[section]; gridOrder = zone.m_gridOrders[section]; basisFn = zone.m_basisFns[section]; numElements = zone.m_numElementsPerSection[section]; } else { switch (zone.___2682) { case ___4699: cellShape = FECellShape_Triangle;      break; case ___4697:     cellShape = FECellShape_Quadrilateral; break; case ___4698:    cellShape = FECellShape_Tetrahedron;   break; case ___4692:    cellShape = FECellShape_Hexahedron;    break; case ___4693:  cellShape = FECellShape_Bar;           break; default: ___476(___1303); break; } gridOrder = 1; basisFn = FECellBasisFunction_Lagrangian; numElements = zone.___2680.___2103(); } std::tie(numCornersPerElem, numNodesPerElem) = numNodesForFECellType(cellShape, gridOrder, basisFn); return ___4224; } } ___372 ___4014::zoneGetSectionMetrics( ___4262 ASSERT_ONLY(dataSetID), ___4633 ___4655, ___1170 section, FECellShape_e* cellShape, ___1170* gridOrder, FECellBasisFunction_e* basisFn, ___2225* numElements, ___1170* numCornersPerElem, ___1170* numNodesPerElem) const { REQUIRE(dataSetID == 0); REQUIRE(m_tecioData.validZoneNum(___4655)); REQUIRE(___4617(___4655) != ___4701 && ___4617(___4655) != ___4695 && ___4617(___4655) != ___4696); ASSERT_ONLY(___1170 numSections = 0); REQUIRE(zoneGetNumSections(dataSetID, ___4655, &numSections) && section <= numSections); REQUIRE(VALID_REF(cellShape)); REQUIRE(VALID_REF(gridOrder));
REQUIRE(VALID_REF(basisFn)); REQUIRE(VALID_REF(numElements)); REQUIRE(VALID_REF(numCornersPerElem)); REQUIRE(VALID_REF(numNodesPerElem)); return getSectionMetrics( *m_tecioData.zonePtr(___4655), section-1, *cellShape, *gridOrder, *basisFn, *numElements, *numCornersPerElem, *numNodesPerElem); } int32_t ___4014::zoneGetDimension( ___4262  ASSERT_ONLY(dataSetID), ___4633 ___4655) const { REQUIRE(dataSetID == 0); REQUIRE(m_tecioData.validZoneNum(___4655)); int32_t ___3356 = 0; Zone_s const* zonePtr = m_tecioData.zonePtr(___4655); ZoneType_e const ___4689 = ___4617(___4655); if (___4689 == ___4701) { ___3356 = ___2881(zonePtr->___2680); } else if (___4689 == ZoneType_FEMixed) { ___476(!zonePtr->m_cellShapes.empty()); ___3356 = feMixedZoneDimension(zonePtr->m_cellShapes[0]); } else { ___3356 = feNonMixedZoneDimension(___4689); } ENSURE(1 <= ___3356 && ___3356 <= 3); return ___3356; } void ___4014::___4612(___4633 ___4655, ___1842& ___2713) const { REQUIRE(m_tecioData.validZoneNum(___4655)); Zone_s const* zonePtr = m_tecioData.zonePtr(___4655); ___2713 = zonePtr->___2680; } ___372 ___4014::___4613(___4633 ___4655, char** ___4649) const { REQUIRE(m_tecioData.validZoneNum(___4655)); REQUIRE(VALID_REF(___4649) && !*___4649); Zone_s const* zonePtr = m_tecioData.zonePtr(___4655); *___4649 = copyString(zonePtr->___2681); return ___4224; } ___4633 ___4014::___4614(___4633 ___4655) const { REQUIRE(m_tecioData.validZoneNum(___4655)); Zone_s const* zonePtr = m_tecioData.zonePtr(___4655); return zonePtr->___2612; } double ___4014::___4615(___4633 ___4655) const { REQUIRE(m_tecioData.validZoneNum(___4655)); Zone_s const* zonePtr = m_tecioData.zonePtr(___4655); return zonePtr->___2619; } ___1170 ___4014::___4616(___4633 ___4655) const { REQUIRE(m_tecioData.validZoneNum(___4655)); Zone_s const* zonePtr = m_tecioData.zonePtr(___4655); return zonePtr->___2620; } int32_t ___4014::___4610(___4633 ___4655) const { REQUIRE(m_tecioData.validZoneNum(___4655)); Zone_s const* zonePtr = m_tecioData.zonePtr(___4655); return static_cast<int32_t>(zonePtr->___2343->m_auxDataItems.size()); } ___372 ___4014::___4637(___4633 ___4655) const { REQUIRE(m_tecioData.validZoneNum(___4655)); Zone_s const* zonePtr = m_tecioData.zonePtr(___4655); return static_cast<___372>(zonePtr->___2682 != ___4701); } ___372 ___4014::___4638(tecplot::___3931::___4633 ___4655) const { REQUIRE(m_tecioData.validZoneNum(___4655)); Zone_s const* zonePtr = m_tecioData.zonePtr(___4655); return static_cast<___372>(zonePtr->___2682 == ___4701); } ___372 ___4014::___4350(___4349 ASSERT_ONLY(___4365)) const { REQUIRE(0 < ___4365 && ___4365 <= static_cast<___4349>(m_tecioData.variableNames().size())); return ___4224; } ___372 ___4014::varGetEnabled(___3499* enabledVars) const
{ ___476(___1303); *enabledVars = ___3499(0); return ___4224; } int32_t ___4014::solutionTimeGetNumTimeSteps() const { ___476(___1303); return 0; } double ___4014::solutionTimeGetMinTime() const { ___476(___1303); return 0.0; } double ___4014::solutionTimeGetMaxTime() const { ___476(___1303); return 0.0; } ___372 ___4014::___3766() const { return ___4224; } GeomID_t ___4014::___1590(void) { if (!m_tecioData.geoms().empty()) return reinterpret_cast<GeomID_t>(&m_tecioData.geoms()[0]); return ___4033; } TextID_t ___4014::___4085(void) { if (!m_tecioData.texts().empty()) return reinterpret_cast<TextID_t>(&m_tecioData.texts()[0]); return ___4033; } int32_t ___4014::___795(void) { return (int32_t)m_tecioData.customLabels().size(); } ___372 ___4014::___794(___3837* ___2169, int32_t ___4450) { REQUIRE(0 < ___4450 && ___4450 <= (int32_t)m_tecioData.customLabels().size()); try { *___2169 = new StringList_s; (*___2169)->m_strings = m_tecioData.customLabels()[___4450 - 1]; return ___4224; } catch(...) { return ___1303; } } void ___4014::___856() { } void ___4014::___857() { } void ___4014::___3777(char const* ___2999, ___372 ___3582, ___372 ___3577) const { ___4276(___2999); ___4276(___3582); ___4276(___3577); } void ___4014::___3776(char const* ___2999) const { ___4276(___2999); } ___372 ___4014::___3767(int percentDone) const { ___4276(percentDone); return ___4224; } void ___4014::___3768(void) const { } ___372 ___4014::___1981(void) const { return ___1303; } ___4633 ___4014::___542(___3499 ___4681, ___4633 ___4655) const { REQUIRE(m_tecioData.validZoneNum(___4655)); Zone_s const* zonePtr = m_tecioData.zonePtr(___4655); std::set<___3491>* ___4668 = reinterpret_cast<std::set<___3491>*>(___4681); if (!zonePtr->m_shareConnectivityFromZone) return ___4033; else if (!___4668 || ___4668->find(zonePtr->m_shareConnectivityFromZone) != ___4668->end()) return zonePtr->m_shareConnectivityFromZone; return ___4033; } ___3499 ___4014::___543(___4633 zone) const { REQUIRE(m_tecioData.validZoneNum(zone)); Zone_s const* zonePtr = m_tecioData.zonePtr(zone); try { std::set<___3491>* ___3356 = new std::set<___3491>; if (zonePtr->___2495) { ___4633 const ___341 = m_tecioData.baseZoneForConnectivity(zone); std::set<___3491> const zoneSet = m_tecioData.zoneSet(); for (std::set<___3491>::const_iterator ___4655 = zoneSet.begin(); ___4655 != zoneSet.end(); ++___4655) { if (m_tecioData.baseZoneForConnectivity(static_cast<___4633>(*___4655)) == ___341) ___3356->insert(*___4655); } } return reinterpret_cast<___3499>(___3356); } catch (...) { return NULL; } } ValueLocation_e ___4014::___908(___4633 ___4655, ___4349 ___4365) const
{ REQUIRE(m_tecioData.validZoneNum(___4655)); REQUIRE(0 < ___4365 && ___4365 <= static_cast<___4349>(m_tecioData.variableNames().size())); Zone_s const* zonePtr = m_tecioData.zonePtr(___4655); return zonePtr->___2668[___4365 - 1]; } ValueLocation_e ___4014::___909(___1359 ___1349) const { REQUIRE(VALID_REF(___1349)); return toSzlioFieldData(___1349)->___2667; } ___372 ___4014::___911( ___4633 ___4655, ___4349 ___4333, double* minVal, double* maxVal) const { REQUIRE(m_tecioData.validZoneNum(___4655)); REQUIRE(0 < ___4333 && ___4333 <= static_cast<___4349>(m_tecioData.variableNames().size())); Zone_s const* zonePtr = m_tecioData.zonePtrForVar(___4655, ___4333); if (zoneIsPartitioned(___4655)) { if (zonePtr->m_partitionMap.empty()) { *minVal = 0.0; *maxVal = 0.0; } else { *minVal = std::numeric_limits<double>::max(); *maxVal = -std::numeric_limits<double>::max(); for (Zone_s::ZoneMap::const_iterator valuePair = zonePtr->m_partitionMap.begin(); valuePair != zonePtr->m_partitionMap.end(); ++valuePair) { double partitionMinVal = 0.0; double partitionMaxVal = 0.0; valuePair->second->___2494[___4333 - 1]->___1757(partitionMinVal, partitionMaxVal); *minVal = std::min(*minVal, partitionMinVal); *maxVal = std::max(*maxVal, partitionMaxVal); } } } else if (zonePtr->___2494[___4333 - 1]) { zonePtr->___2494[___4333 - 1]->___1757(*minVal, *maxVal); } else { ___476(zonePtr->m_shareVarFromZone[___4333 - 1] != 0); *minVal = 0.0; *maxVal = 0.0; } ENSURE(*minVal <= *maxVal); return ___4224; } ___372 ___4014::___910( ___1359 ___1349, double* minVal, double* maxVal) const { toSzlioFieldData(___1349)->___1757(*minVal, *maxVal); return ___4224; } FieldDataType_e ___4014::___921(___4633 ___4655, ___4349 ___4365) { REQUIRE(m_tecioData.validZoneNum(___4655)); REQUIRE(0 < ___4365 && ___4365 <= static_cast<___4349>(m_tecioData.variableNames().size())); Zone_s const* zonePtr = m_tecioData.zonePtr(___4655); return zonePtr->___2458[___4365 - 1]; } ___1170 ___4014::___919(___4633 ___4655, ___4349 ___4365) { REQUIRE(m_tecioData.validZoneNum(___4655)); REQUIRE(0 < ___4365 && ___4365 <= static_cast<___4349>(m_tecioData.variableNames().size())); ___1170 shareCount = 0; ___3499 shareSet = ___920(___4655, ___4365); if (shareSet) { shareCount = checked_numeric_cast<___1170>(setGetMemberCount(shareSet)); ___3482(&shareSet); } return shareCount; } ___1359 ___4014::___916(___4633 ___4655, ___4349 ___4365) { REQUIRE(m_tecioData.validZoneNum(___4655)); REQUIRE(0 < ___4365 && ___4365 <= static_cast<___4349>(m_tecioData.variableNames().size())); Zone_s const* zonePtr = m_tecioData.zonePtrForVar(___4655, ___4365); if (zonePtr->___2494[___4365 - 1]->___2667 == ___4327) return ___915(___4655, ___4365);
else return ___914(___4655, ___4365); } ___1359 ___4014::___913(___4633 ___4655, ___4349 ___4365) { REQUIRE(m_tecioData.validZoneNum(___4655)); REQUIRE(0 < ___4365 && ___4365 <= static_cast<___4349>(m_tecioData.variableNames().size())); Zone_s const* zonePtr = m_tecioData.zonePtrForVar(___4655, ___4365); if (zonePtr->___2494[___4365 - 1]->___2667 == ___4325) return ___915(___4655, ___4365); else return ___914(___4655, ___4365); } ___1359 ___4014::___915(___4633 ___4655, ___4349 ___4365) { REQUIRE(m_tecioData.validZoneNum(___4655)); REQUIRE(0 < ___4365 && ___4365 <= static_cast<___4349>(m_tecioData.variableNames().size())); Zone_s const* zonePtr = m_tecioData.zonePtrForVar(___4655, ___4365); return toTecUtilFieldData(zonePtr->___2494[___4365 - 1].get()); } ___1359 ___4014::___914(___4633 ___4655, ___4349 ___4365) { REQUIRE(m_tecioData.validZoneNum(___4655)); REQUIRE(0 < ___4365 && ___4365 <= static_cast<___4349>(m_tecioData.variableNames().size())); Zone_s* zonePtr = m_tecioData.zonePtrForVar(___4655, ___4365); try { if (zonePtr->___2398[___4365 - 1]->storedValueCount() == 0) { Zone_s* connectivityZonePtr = m_tecioData.zonePtrForConnectivity(___4655); if (zonePtr->___2494[___4365 - 1]->___2667 == ___4325) zonePtr->___963(___4365, connectivityZonePtr->___2495.get()); else zonePtr->deriveCCValues(___4365, connectivityZonePtr->___2495.get()); } } catch (std::exception const&) { } return toTecUtilFieldData(zonePtr->___2398[___4365 - 1].get()); } ___1359 ___4014::___922(___4633 ___4655, ___4349 ___4365) { return ___915(___4655, ___4365); } namespace { double fieldValueGetFunction(___1359 ___1349, ___2225 ___2731) { REQUIRE(VALID_REF(___1349)); REQUIRE(0 <= ___2731); tecplot::tecioszl::___1360* const szlioFD = toSzlioFieldData(___1349); size_t index = static_cast<size_t>(___2731); REQUIRE(szlioFD->___2666 == 0 || index < szlioFD->___2666); if (index < szlioFD->___2666) return szlioFD->___1778(index); return 0.0; } void fieldValueSetFunction(___1359 ___1349, ___2225 ___2731, double ___4296) { REQUIRE(VALID_REF(___1349)); REQUIRE(0 <= ___2731); tecplot::tecioszl::___1360* const szlioFD = toSzlioFieldData(___1349); size_t index = static_cast<size_t>(___2731); REQUIRE(szlioFD->___2666 == 0 || index < szlioFD->___2666); if (index < szlioFD->___2666) szlioFD->___3502(index, ___4296); } } double ___4014::___907(___1359 ___1349, ___81 ___2731) { REQUIRE(VALID_REF(___1349)); REQUIRE(0 < ___2731); return fieldValueGetFunction(___1349, ___2731 - 1); } void ___4014::dataValueSetByRef(___1359 ___1349, ___81 ___2731, double ___4296)
{ REQUIRE(VALID_REF(___1349)); REQUIRE(0 < ___2731); fieldValueSetFunction(___1349, ___2731 - 1, ___4296); } void ___4014::___917(___4633 ___4655, ___4349 ___4365, void** ___878, FieldDataType_e* ___1361) { REQUIRE(m_tecioData.validZoneNum(___4655)); REQUIRE(0 < ___4365 && ___4365 <= static_cast<___4349>(m_tecioData.variableNames().size())); Zone_s const* zonePtr = m_tecioData.zonePtrForVar(___4655, ___4365); *___878 = zonePtr->___2494[___4365 - 1]->getRawPointer(); *___1361 = zonePtr->___2494[___4365 - 1]->___2457; } void ___4014::___923(___4633 ___4655, ___4349 ___4365, void** ___878, FieldDataType_e* ___1361) { ___917(___4655, ___4365, ___878, ___1361); } ___4633 ___4014::___912(___3499 ___4681, ___4633 ___4655, ___4349 ___4333) const { REQUIRE(m_tecioData.validZoneNum(___4655)); Zone_s const* zonePtr = m_tecioData.zonePtr(___4655); std::set<___3491>* ___4668 = reinterpret_cast<std::set<___3491>*>(___4681); if (zonePtr->m_shareVarFromZone.empty() || zonePtr->m_shareVarFromZone[___4333 - 1] == 0) return ___4033; else if (___4668 == NULL || ___4668->find(zonePtr->m_shareVarFromZone[___4333 - 1]) != ___4668->end()) return zonePtr->m_shareVarFromZone[___4333 - 1]; return ___4033; } ___3499 ___4014::___920(___4633 ___4655, ___4349 ___4365) const { REQUIRE(m_tecioData.validZoneNum(___4655)); REQUIRE(0 < ___4365 && ___4365 <= static_cast<___4349>(m_tecioData.variableNames().size())); ___4633 const ___341 = m_tecioData.baseZoneForVar(___4655, ___4365); try { std::set<___3491>* ___3356 = new std::set<___3491>; std::set<___3491> const zoneSet = m_tecioData.zoneSet(); for (std::set<___3491>::const_iterator zoneNumber = zoneSet.begin(); zoneNumber != zoneSet.end(); ++zoneNumber) { if (m_tecioData.baseZoneForVar(checked_numeric_cast<___4633>(*zoneNumber), ___4365) == ___341) ___3356->insert(*zoneNumber); } return reinterpret_cast<___3499>(___3356); } catch (...) { return NULL; } } ___372 ___4014::___924(___4633 ___4655, ___4349 ___4365) const { REQUIRE(m_tecioData.validZoneNum(___4655)); REQUIRE(0 < ___4365 && ___4365 <= static_cast<___4349>(m_tecioData.variableNames().size())); Zone_s const* zonePtr = m_tecioData.zonePtr(___4655); return (zonePtr->m_passiveVars[___4365 - 1] != 0); } ___1381 ___4014::___925(___1359 ___1307) { ___4276(___1307); return fieldValueGetFunction; } ___1382 ___4014::___926(___1359 ___1307) { ___4276(___1307); return fieldValueSetFunction; } FieldDataType_e ___4014::___918(___1359 ___1349) { return toSzlioFieldData(___1349)->___2457; } ___2725 ___4014::___865(___4633 ___4655) { REQUIRE(m_tecioData.validZoneNum(___4655)); Zone_s const* zonePtr = m_tecioData.zonePtrForConnectivity(___4655);
return toTecUtilNodeMap(zonePtr->___2495.get()); } ___2725 ___4014::___867(___4633 ___4655) { REQUIRE(m_tecioData.validZoneNum(___4655)); Zone_s const* zonePtr = m_tecioData.zonePtrForConnectivity(___4655); return toTecUtilNodeMap(zonePtr->___2495.get()); } ___2716 ___4014::___863( ___2725 ___2721, ___463 ___466, CellNodeIndex_t ___681) { tecplot::tecioszl::___2728* const szlioNM = toSzlioNodeMap(___2721); REQUIRE(VALID_REF(szlioNM)); REQUIRE(szlioNM->m_numCellsPerSection.size() == 0); size_t const section = 0; REQUIRE(0 < ___466 && ___466 <= static_cast<___463>(szlioNM->m_numCellsPerSection[section])); REQUIRE(0 < ___681 && ___681 <= szlioNM->m_numNodesPerCellPerSection[section]); ___463 ___460 = ___466 - 1; int64_t ___2714 = szlioNM->value(section, ___460 * szlioNM->m_numNodesPerCellPerSection[section] + ___681 - 1); return (___2716)___2714 + 1; } void ___4014::___868(___2725 ___2721, ___463 ___466, CellNodeIndex_t ___681, ___2716 ___2714) { tecplot::tecioszl::___2728* const szlioNM = toSzlioNodeMap(___2721); REQUIRE(VALID_REF(szlioNM)); REQUIRE(szlioNM->m_numCellsPerSection.size() == 0); size_t const section = 0; REQUIRE(0 < ___466 && ___466 <= static_cast<___463>(szlioNM->m_numCellsPerSection[section])); REQUIRE(0 < ___681 && ___681 <= szlioNM->m_numNodesPerCellPerSection[section]); szlioNM->___3502(section, (___466 - 1) * szlioNM->m_numNodesPerCellPerSection[section] + ___681 - 1, ___2714 - 1); } OffsetDataType_e ___4014::dataNodeGetRawItemType(___2725 ___2721) { REQUIRE(VALID_REF(___2721)); return toSzlioNodeMap(___2721)->getRawItemType(); } int32_t* ___4014::dataNodeGetRawPtrByRef(___2725 ___2721) { REQUIRE(VALID_REF(___2721)); return reinterpret_cast<int32_t*>(toSzlioNodeMap(___2721)->getRawPtr(0  )); } int64_t* ___4014::dataNodeGetRawPtrByRef64(___2725 ___2721) { REQUIRE(VALID_REF(___2721)); return reinterpret_cast<int64_t*>(toSzlioNodeMap(___2721)->getRawPtr(0  )); } void ___4014::dataNodeSectionArrayGetByRef(___2725 ___2721, ___1170 sectionIndex, ___2225 index, ___2225 count, int32_t* nodeArray) const { tecplot::tecioszl::___2728* const szlioNM = toSzlioNodeMap(___2721); REQUIRE(VALID_REF(szlioNM)); for (___2225 nOffset = 0; nOffset < count; ++nOffset) nodeArray[nOffset] = checked_numeric_cast<int32_t>(szlioNM->value(sectionIndex - 1, index + nOffset - 1) + 1); } void ___4014::dataNodeSectionArrayGetByRef(___2725 ___2721, ___1170 sectionIndex, ___2225 index, ___2225 count, int64_t* nodeArray) const { tecplot::tecioszl::___2728* const szlioNM = toSzlioNodeMap(___2721); REQUIRE(VALID_REF(szlioNM)); for (___2225 nOffset = 0; nOffset < count; ++nOffset) nodeArray[nOffset] = checked_numeric_cast<int64_t>(szlioNM->value(sectionIndex, index + nOffset - 1) + 1); } void ___4014::dataNodeSectionArraySetByRef(___2725 ___2721, ___1170 sectionIndex,
___2225 index, ___2225 count, int32_t const* nodeArray) { tecplot::tecioszl::___2728* const szlioNM = toSzlioNodeMap(___2721); REQUIRE(VALID_REF(szlioNM)); for (___2225 nOffset = 0; nOffset < count; ++nOffset) szlioNM->___3502(sectionIndex - 1, index + nOffset - 1, nodeArray[nOffset]); } void ___4014::dataNodeSectionArraySetByRef(___2725 ___2721, ___1170 sectionIndex, ___2225 index, ___2225 count, int64_t const* nodeArray) { tecplot::tecioszl::___2728* const szlioNM = toSzlioNodeMap(___2721); REQUIRE(VALID_REF(szlioNM)); for (___2225 nOffset = 0; nOffset < count; ++nOffset) szlioNM->___3502(sectionIndex - 1, index + nOffset - 1, nodeArray[nOffset]); } int32_t* ___4014::dataNodeSectionGetRawPtrByRef(___2725 ___2721, ___1170 sectionIndex) { REQUIRE(VALID_REF(___2721)); return reinterpret_cast<int32_t*>(toSzlioNodeMap(___2721)->getRawPtr(sectionIndex - 1)); } int64_t* ___4014::dataNodeSectionGetRawPtrByRef64(___2725 ___2721, ___1170 sectionIndex) { REQUIRE(VALID_REF(___2721)); return reinterpret_cast<int64_t*>(toSzlioNodeMap(___2721)->getRawPtr(sectionIndex - 1)); } void ___4014::feCellTypeGetNumNodes(FECellShape_e         cellShape, ___1170            gridOrder, FECellBasisFunction_e basisFn, ___1170*           numCornerNodes, ___1170*           ___2819) const { std::tie(*numCornerNodes, *___2819) = numNodesForFECellType(cellShape, gridOrder, basisFn); } ___2740 ___4014::dataNodeToElemMapGetReadableRef(___4633 ___4655) const { REQUIRE(m_tecioData.validZoneNum(___4655)); Zone_s* zonePtr = m_tecioData.zonePtrForConnectivity(___4655); if (!zonePtr->m_nodeToElemMap) zonePtr->m_nodeToElemMap.reset(new ___2741(*zonePtr->___2495, zonePtr->___2680.___1668())); return toTecUtilNodeToElemMap(zonePtr->m_nodeToElemMap.get()); } ___463 ___4014::dataNodeToElemMapGetNumElems(___2740 nodeToElemMap, ___2716 ___2707) const { tecplot::tecioszl::___2741* const szlioNEM = toSzlioNodeToElemMap(nodeToElemMap); REQUIRE(VALID_REF(szlioNEM)); REQUIRE(0 < ___2707 && ___2707 <= szlioNEM->m_nodeCount); return szlioNEM->m_elemIndex[___2707] - szlioNEM->m_elemIndex[___2707 - 1]; } ___463 ___4014::dataNodeToElemMapGetElem(___2740 nodeToElemMap, ___2716 ___2707, ___463 elemOffset) const { tecplot::tecioszl::___2741* const szlioNEM = toSzlioNodeToElemMap(nodeToElemMap); REQUIRE(VALID_REF(szlioNEM)); REQUIRE(0 < ___2707 && ___2707 <= szlioNEM->m_nodeCount); REQUIRE(0 < elemOffset && elemOffset <= szlioNEM->m_elemIndex[___2707] - szlioNEM->m_elemIndex[___2707 - 1]); return szlioNEM->m_elem[szlioNEM->m_elemIndex[___2707 - 1] + elemOffset - 1] + 1; } FaceNeighborMode_e ___4014::___834(___4633 ___4655) const { REQUIRE(m_tecioData.validZoneNum(___4655)); Zone_s const* zonePtr = m_tecioData.zonePtr(___4655); return zonePtr->___2456; } void ___4014::___835( ___1290 ___1272, ___2225 ___1142,
int32_t face, int32_t ___2690, ___2225* ___2689, ___4633* ___2693) const { Zone_s const* zonePtr = reinterpret_cast<Zone_s const*>(___1272); REQUIRE(VALID_REF(zonePtr)); Zone_s::___456 ___455; ___455.first = static_cast<int32_t>(___1142); ___455.second = face; Zone_s::___1274::const_iterator iter = zonePtr->___2455.find(___455); ___476(iter != zonePtr->___2455.end()); ___476(0 < ___2690 && ___2690 <= (___2225)iter->second.___2676.size()); *___2689 = iter->second.___2676[___2690 - 1].second; *___2693 = iter->second.___2676[___2690 - 1].first; } ___372 ___4014::___833( ___1290 ___1272, ___2225 ___1142, int32_t face, ___3499 ___4) const { ___4276(___4); Zone_s const* zonePtr = reinterpret_cast<Zone_s const*>(___1272); REQUIRE(VALID_REF(zonePtr)); Zone_s::___456 ___455; ___455.first = static_cast<int32_t>(___1142); ___455.second = face; Zone_s::___1274::const_iterator iter = zonePtr->___2455.find(___455); if (iter == zonePtr->___2455.end()) return ___1303; else return iter->second.___2486; } int32_t ___4014::___836(___1290 ___1272, ___2225 ___1142, int32_t face, ___372*  ) const { Zone_s const* zonePtr = reinterpret_cast<Zone_s const*>(___1272); REQUIRE(VALID_REF(zonePtr)); Zone_s::___456 ___455; ___455.first = static_cast<int32_t>(___1142); ___455.second = face; Zone_s::___1274::const_iterator iter = zonePtr->___2455.find(___455); if (iter == zonePtr->___2455.end()) return 0; else return (int32_t)iter->second.___2676.size(); } ___1290 ___4014::___837(___4633 ___4655) const { REQUIRE(m_tecioData.validZoneNum(___4655)); Zone_s* zonePtr = m_tecioData.zonePtrForConnectivity(___4655); return reinterpret_cast<___1290>(zonePtr); } ___372 ___4014::setAddMember(___3499 set, ___3491 ___2399, ___372 showErr) const { std::set<___3491>* setPtr = reinterpret_cast<std::set<___3491>*>(set); REQUIRE(VALID_REF(setPtr)); try { setPtr->insert(___2399); } catch (std::bad_alloc const&) { if (showErr) std::cerr << "Allocation failure adding member to set." << std::endl; return ___1303; } return ___4224; } ___3499 ___4014::setAlloc(___372 showErr) const { std::set<___3491>* ___3356 = NULL; try { ___3356 = new std::set<___3491>(); } catch (std::bad_alloc const&) { if (showErr) std::cerr << "Allocation failure allocating set." << std::endl; } return reinterpret_cast<___3499>(___3356); } void ___4014::___3482(___3499* set) const { REQUIRE(VALID_REF(set)); std::set<___3491>* setPtr = *(reinterpret_cast<std::set<___3491>**>(set)); REQUIRE(VALID_REF_OR_NULL(setPtr)); delete setPtr; *set = NULL; } ___3491 ___4014::___3489(___3499 set, ___3491 ___2399) const { std::set<___3491>* setPtr = reinterpret_cast<std::set<___3491>*>(set);
REQUIRE(VALID_REF(setPtr)); std::set<___3491>::iterator it; if (___2399 == ___4037) { it = setPtr->begin(); } else { it = setPtr->find(___2399); if (it != setPtr->end()) ++it; } if (it == setPtr->end()) return ___4037; else return *it; } ___3491 ___4014::setGetPrevMember(___3499 set, ___3491 ___2399) const { std::set<___3491>* setPtr = reinterpret_cast<std::set<___3491>*>(set); REQUIRE(VALID_REF(setPtr)); std::set<___3491>::reverse_iterator it; if (___2399 == ___4037) { it = setPtr->rbegin(); } else { it = setPtr->rbegin(); while (it != setPtr->rend() && *it != ___2399) ++it; if (it != setPtr->rend()) ++it; } if (it == setPtr->rend()) return ___4037; else return *it; } ___3491 ___4014::setGetMemberCount(___3499 set) const { std::set<___3491>* setPtr = reinterpret_cast<std::set<___3491>*>(set); REQUIRE(VALID_REF(setPtr)); return static_cast<___3491>(setPtr->size()); } ___372 ___4014::___3493(___3499 set, ___3491 ___2399) const { std::set<___3491>* setPtr = reinterpret_cast<std::set<___3491>*>(set); REQUIRE(VALID_REF(setPtr)); return setPtr->find(___2399) != setPtr->end(); } ___372 ___4014::setIsEqual(___3499 ___3475, ___3499 ___3476) const { std::set<___3491>* set1Ptr = reinterpret_cast<std::set<___3491>*>(___3475); std::set<___3491>* set2Ptr = reinterpret_cast<std::set<___3491>*>(___3476); REQUIRE(VALID_REF(set1Ptr) && VALID_REF(set2Ptr)); return *set1Ptr == *set2Ptr; } void ___4014::setRemoveMember(___3499 set, ___3491 ___2399) const { std::set<___3491>* setPtr = reinterpret_cast<std::set<___3491>*>(set); REQUIRE(VALID_REF(setPtr)); setPtr->erase(___2399); } void ___4014::___1555(GeomID_t ___1803, int32_t ___3155, ___2225 ___3139, double* x, double* ___4580) const { ___1554 const* ___1553 = reinterpret_cast<___1554*>(___1803); REQUIRE(VALID_REF(___1553)); REQUIRE(___1553->___2464 == GeomType_LineSegs); REQUIRE(0 < ___3155 && ___3155 <= (int32_t)___1553->___2462.size()); REQUIRE(0 < ___3139 && ___3139 <= (___2225)___1553->___2462[___3155 - 1].size()); *x = ___1553->___2462[___3155 - 1][___3139 - 1].x(); *___4580 = ___1553->___2462[___3155 - 1][___3139 - 1].___4580(); } void ___4014::___1556(GeomID_t ___1803, ___2225 ___3139, double* x, double* ___4580) const { ___1554 const* ___1553 = reinterpret_cast<___1554*>(___1803); REQUIRE(VALID_REF(___1553)); REQUIRE(___1553->___2464 == GeomType_LineSegs); REQUIRE(0 < ___3139 && ___3139 < (___2225)___1553->___2462[0].size()); *x = ___1553->___2462[0][___3139 - 1].x(); *___4580 = ___1553->___2462[0][___3139 - 1].___4580(); } void ___4014::___1558(GeomID_t ___1803, int32_t ___3155, ___2225 ___3139, double* x, double* ___4580, double* z) const { ___1554 const* ___1553 = reinterpret_cast<___1554*>(___1803); REQUIRE(VALID_REF(___1553)); REQUIRE(___1553->___2464 == GeomType_LineSegs && ___1553->___2614 == CoordSys_Grid3D); REQUIRE(0 < ___3155 && ___3155 <= (int32_t)___1553->___2462.size()); REQUIRE(0 < ___3139 && ___3139 <= (___2225)___1553->___2462[___3155 - 1].size());
*x = ___1553->___2462[___3155 - 1][___3139 - 1].x(); *___4580 = ___1553->___2462[___3155 - 1][___3139 - 1].___4580(); *z = ___1553->___2462[___3155 - 1][___3139 - 1].z(); } void ___4014::___1559(GeomID_t ___1803, ___2225 ___3139, double* x, double* ___4580, double* z) const { ___1554 const* ___1553 = reinterpret_cast<___1554*>(___1803); REQUIRE(VALID_REF(___1553)); REQUIRE(___1553->___2464 == GeomType_LineSegs && ___1553->___2614 == CoordSys_Grid3D); REQUIRE(0 < ___3139 && ___3139 < (___2225)___1553->___2462[0].size()); *x = ___1553->___2462[0][___3139 - 1].x(); *___4580 = ___1553->___2462[0][___3139 - 1].___4580(); *z = ___1553->___2462[0][___3139 - 1].z(); } double ___4014::___1562(GeomID_t ___1803) const { ___1554 const* ___1553 = reinterpret_cast<___1554*>(___1803); REQUIRE(VALID_REF(___1553)); return ___1553->___2338; } ArrowheadAttachment_e ___4014::___1563(GeomID_t ___1803) const { ___1554 const* ___1553 = reinterpret_cast<___1554*>(___1803); REQUIRE(VALID_REF(___1553)); return ___1553->___2339; } double ___4014::___1564(GeomID_t ___1803) const { ___1554 const* ___1553 = reinterpret_cast<___1554*>(___1803); REQUIRE(VALID_REF(___1553)); return ___1553->___2340; } ArrowheadStyle_e ___4014::___1565(GeomID_t ___1803) const { ___1554 const* ___1553 = reinterpret_cast<___1554*>(___1803); REQUIRE(VALID_REF(___1553)); return ___1553->___2341; } double ___4014::___1568(GeomID_t ___1803) const { ___1554 const* ___1553 = reinterpret_cast<___1554*>(___1803); REQUIRE(VALID_REF(___1553)); REQUIRE(___1553->___2464 == GeomType_Circle); REQUIRE(___1553->___2462.size() == 1); REQUIRE(___1553->___2462[0].size() == 1); return ___1553->___2462[0][0].x(); } int32_t ___4014::___1574(GeomID_t ___1803) const { ___1554 const* ___1553 = reinterpret_cast<___1554*>(___1803); REQUIRE(VALID_REF(___1553)); REQUIRE(___1553->___2464 == GeomType_Ellipse || ___1553->___2464 == GeomType_Circle); return static_cast<int32_t>(___1553->___2500); } void ___4014::___1575(GeomID_t ___1803, double* ___1822, double* ___4391) const { ___1554 const* ___1553 = reinterpret_cast<___1554*>(___1803); REQUIRE(VALID_REF(___1553)); REQUIRE(___1553->___2464 == GeomType_Ellipse); REQUIRE(___1553->___2462.size() == 1); REQUIRE(___1553->___2462.size() == 1); *___1822 = ___1553->___2462[0][0].x(); *___4391 = ___1553->___2462[0][0].___4580(); } void ___4014::___1589(GeomID_t ___1803, double* ___4571, double* ___4588, double* ___4712) const { ___1554 const* ___1553 = reinterpret_cast<___1554*>(___1803); REQUIRE(VALID_REF(___1553)); *___4571 = ___1553->___2615[0]; *___4588 = ___1553->___2615[1]; *___4712 = ___1553->___2615[2]; } Clipping_e ___4014::___1591(GeomID_t ___1803) const { ___1554 const* ___1553 = reinterpret_cast<___1554*>(___1803); REQUIRE(VALID_REF(___1553)); return ___1553->___2392; } ___514 ___4014::___1592(GeomID_t ___1803) const { ___1554 const* ___1553 = reinterpret_cast<___1554*>(___1803); REQUIRE(VALID_REF(___1553)); return ___1553->___2393; } DrawOrder_e ___4014::___1593(GeomID_t  ) const
{ return ___1112; } ___514 ___4014::___1594(GeomID_t ___1803) const { ___1554 const* ___1553 = reinterpret_cast<___1554*>(___1803); REQUIRE(VALID_REF(___1553)); return ___1553->___2460; } ___372 ___4014::___1595(GeomID_t ___1803) const { ___1554 const* ___1553 = reinterpret_cast<___1554*>(___1803); REQUIRE(VALID_REF(___1553)); return ___1553->___2484; } LinePattern_e ___4014::___1596(GeomID_t ___1803) const { ___1554 const* ___1553 = reinterpret_cast<___1554*>(___1803); REQUIRE(VALID_REF(___1553)); return ___1553->___2487; } double ___4014::___1597(GeomID_t ___1803) const { ___1554 const* ___1553 = reinterpret_cast<___1554*>(___1803); REQUIRE(VALID_REF(___1553)); return ___1553->___2488; } ___372 ___4014::___1598(GeomID_t ___1803, char** macroFunctionCmd) const { ___1554 const* ___1553 = reinterpret_cast<___1554*>(___1803); REQUIRE(VALID_REF(___1553)); *macroFunctionCmd = copyString(___1553->___2489); return ___4224; } GeomID_t ___4014::___1599(GeomID_t ___1803) const { ___1554 const* ___1553 = reinterpret_cast<___1554*>(___1803); REQUIRE(VALID_REF(___1553)); size_t nextIndex = std::distance(&m_tecioData.geoms()[0], ___1553) + 1; if (nextIndex == m_tecioData.geoms().size()) return ___4033; return reinterpret_cast<GeomID_t>(&m_tecioData.geoms()[nextIndex]); } double ___4014::___1600(GeomID_t ___1803) const { ___1554 const* ___1553 = reinterpret_cast<___1554*>(___1803); REQUIRE(VALID_REF(___1553)); return ___1553->___2613; } CoordSys_e ___4014::___1601(GeomID_t ___1803) const { ___1554 const* ___1553 = reinterpret_cast<___1554*>(___1803); REQUIRE(VALID_REF(___1553)); return ___1553->___2614; } GeomID_t ___4014::___1602(GeomID_t ___1803) const { ___1554 const* ___1553 = reinterpret_cast<___1554*>(___1803); REQUIRE(VALID_REF(___1553)); size_t geomIndex = std::distance(&m_tecioData.geoms()[0], ___1553); if (geomIndex == 0) return ___4033; return reinterpret_cast<GeomID_t>(&m_tecioData.geoms()[geomIndex - 1]); } Scope_e ___4014::___1603(GeomID_t ___1803) const { ___1554 const* ___1553 = reinterpret_cast<___1554*>(___1803); REQUIRE(VALID_REF(___1553)); return ___1553->___2617; } GeomForm_e ___4014::___1604(GeomID_t ___1803) const { ___1554 const* ___1553 = reinterpret_cast<___1554*>(___1803); REQUIRE(VALID_REF(___1553)); return ___1553->___2464; } ___4633 ___4014::___1605(GeomID_t ___1803) const { ___1554 const* ___1553 = reinterpret_cast<___1554*>(___1803); REQUIRE(VALID_REF(___1553)); return ___1553->___2675; } ___372 ___4014::___1608(GeomID_t ___1803) const { ___1554 const* ___1553 = reinterpret_cast<___1554*>(___1803); REQUIRE(VALID_REF(___1553)); return ___1553->___2482; } ___2225 ___4014::___1617(GeomID_t ___1803, int32_t ___3155) const { ___1554 const* ___1553 = reinterpret_cast<___1554*>(___1803); REQUIRE(VALID_REF(___1553)); REQUIRE(___1553->___2464 == GeomType_LineSegs); REQUIRE(0 < ___3155 && ___3155 <= (int32_t)___1553->___2462.size()); return (___2225)___1553->___2462[___3155 - 1].size(); } ___2225 ___4014::___1618(GeomID_t ___1803) const
{ ___1554 const* ___1553 = reinterpret_cast<___1554*>(___1803); REQUIRE(VALID_REF(___1553)); REQUIRE(___1553->___2464 == GeomType_LineSegs); return (___2225)___1553->___2462.size(); } ___2225 ___4014::___1624(GeomID_t ___1803) const { ___1554 const* ___1553 = reinterpret_cast<___1554*>(___1803); REQUIRE(VALID_REF(___1553)); REQUIRE(___1553->___2464 == GeomType_LineSegs); REQUIRE(___1553->___2462.size() == 1); return (___2225)___1553->___2462[0].size(); } void ___4014::___1626(GeomID_t ___1803, double* ___4455, double* ___1824) const { ___1554 const* ___1553 = reinterpret_cast<___1554*>(___1803); REQUIRE(VALID_REF(___1553)); REQUIRE(___1553->___2464 == GeomType_Rectangle); REQUIRE(___1553->___2462.size() == 1); *___4455 = ___1553->___2462[0][0].x(); *___1824 = ___1553->___2462[0][0].___4580(); } double ___4014::___1646(GeomID_t ___1803) const { ___1554 const* ___1553 = reinterpret_cast<___1554*>(___1803); REQUIRE(VALID_REF(___1553)); REQUIRE(___1553->___2464 == GeomType_Square); REQUIRE(___1553->___2462.size() == 1); return ___1553->___2462[0][0].x(); } ___514 ___4014::___4062(TextID_t ___4169) const { Text const* ___4040 = reinterpret_cast<Text*>(___4169); REQUIRE(VALID_REF(___4040)); return ___4040->___2626; } ___514 ___4014::___4063(TextID_t ___4169) const { Text const* ___4040 = reinterpret_cast<Text*>(___4169); REQUIRE(VALID_REF(___4040)); return ___4040->___2627; } double ___4014::___4064(TextID_t ___4169) const { Text const* ___4040 = reinterpret_cast<Text*>(___4169); REQUIRE(VALID_REF(___4040)); return ___4040->___2628; } double ___4014::___4065(TextID_t ___4169) const { Text const* ___4040 = reinterpret_cast<Text*>(___4169); REQUIRE(VALID_REF(___4040)); return ___4040->___2629; } TextBox_e ___4014::___4066(TextID_t ___4169) const { Text const* ___4040 = reinterpret_cast<Text*>(___4169); REQUIRE(VALID_REF(___4040)); return ___4040->___2630; } TextAnchor_e ___4014::___4082(TextID_t ___4169) const { Text const* ___4040 = reinterpret_cast<Text*>(___4169); REQUIRE(VALID_REF(___4040)); return ___4040->___2623; } void ___4014::___4083(TextID_t ___4169, double* ___4571, double* ___4588, double* ___4712) const { Text const* ___4040 = reinterpret_cast<Text*>(___4169); REQUIRE(VALID_REF(___4040)); REQUIRE(VALID_REF(___4571)); REQUIRE(VALID_REF(___4588)); REQUIRE(VALID_REF(___4712)); *___4571 = ___4040->___2624[0]; *___4588 = ___4040->___2624[1]; *___4712 = ___4040->___2624[2]; } double ___4014::___4084(TextID_t ___4169) const { Text const* ___4040 = reinterpret_cast<Text*>(___4169); REQUIRE(VALID_REF(___4040)); return ___4040->___2625; } Clipping_e ___4014::___4086(TextID_t ___4169) const { Text const* ___4040 = reinterpret_cast<Text*>(___4169); REQUIRE(VALID_REF(___4040)); return ___4040->___2631; } ___514 ___4014::___4087(TextID_t ___4169) const { Text const* ___4040 = reinterpret_cast<Text*>(___4169); REQUIRE(VALID_REF(___4040)); return ___4040->___2632; } double ___4014::___4088(TextID_t ___4169) const
{ Text const* ___4040 = reinterpret_cast<Text*>(___4169); REQUIRE(VALID_REF(___4040)); return ___4040->___2633; } double ___4014::___4089(TextID_t ___4169) const { Text const* ___4040 = reinterpret_cast<Text*>(___4169); REQUIRE(VALID_REF(___4040)); return ___4040->___2635; } ___372 ___4014::___4090(TextID_t ___4169, char** ___2328) const { Text const* ___4040 = reinterpret_cast<Text*>(___4169); REQUIRE(VALID_REF(___4040)); REQUIRE(VALID_REF(___2328)); if (!___4040->___2636.empty()) { *___2328 = copyString(___4040->___2636); return ___4224; } return ___1303; } TextID_t ___4014::___4091(TextID_t ___4169) const { Text const* ___4040 = reinterpret_cast<Text*>(___4169); REQUIRE(VALID_REF(___4040)); size_t nextIndex = std::distance(&m_tecioData.texts()[0], ___4040) + 1; if (nextIndex == m_tecioData.texts().size()) return ___4033; return reinterpret_cast<TextID_t>(&m_tecioData.texts()[nextIndex]); } CoordSys_e ___4014::___4092(TextID_t ___4169) const { Text const* ___4040 = reinterpret_cast<Text*>(___4169); REQUIRE(VALID_REF(___4040)); return ___4040->___2637; } TextID_t ___4014::___4093(TextID_t ___4169) const { Text const* ___4040 = reinterpret_cast<Text*>(___4169); REQUIRE(VALID_REF(___4040)); size_t textIndex = std::distance(&m_tecioData.texts()[0], ___4040); if (textIndex == 0) return ___4033; return reinterpret_cast<TextID_t>(&m_tecioData.texts()[textIndex - 1]); } Scope_e ___4014::___4094(TextID_t ___4169) const { Text const* ___4040 = reinterpret_cast<Text*>(___4169); REQUIRE(VALID_REF(___4040)); return ___4040->___2639; } Units_e ___4014::___4095(TextID_t ___4169) const { Text const* ___4040 = reinterpret_cast<Text*>(___4169); REQUIRE(VALID_REF(___4040)); return ___4040->___2640; } ___372 ___4014::___4096(TextID_t ___4169, char** ___4124) const { Text const* ___4040 = reinterpret_cast<Text*>(___4169); REQUIRE(VALID_REF(___4040)); REQUIRE(VALID_REF(___4124)); if (!___4040->___2641.empty()) { *___4124 = copyString(___4040->___2641); return ___4224; } return ___1303; } char* ___4014::___4097(TextID_t ___4169) const { Text const* ___4040 = reinterpret_cast<Text*>(___4169); REQUIRE(VALID_REF(___4040)); return copyString(___4040->___2642); } ___372 ___4014::___4098(TextID_t ___4169) const { Text const* ___4040 = reinterpret_cast<Text*>(___4169); REQUIRE(VALID_REF(___4040)); return ___4040->___2643; } ___372 ___4014::___4099(TextID_t ___4169) const { Text const* ___4040 = reinterpret_cast<Text*>(___4169); REQUIRE(VALID_REF(___4040)); return ___4040->___2644; } ___4633 ___4014::___4100(TextID_t ___4169) const { Text const* ___4040 = reinterpret_cast<Text*>(___4169); REQUIRE(VALID_REF(___4040)); return ___4040->___2645; } ___372 ___4014::___4103(TextID_t ___4169) const { Text const* ___4040 = reinterpret_cast<Text*>(___4169); REQUIRE(VALID_REF(___4040)); return ___4040->___2634; } ___372 ___4014::___4302(___1359 ASSERT_ONLY(___1349)) const
{ REQUIRE(VALID_REF(___1349)); return ___4224; } ___372 ___4014::___4307(___2725 ASSERT_ONLY(___2721)) const { REQUIRE(VALID_REF(___2721)); return ___4224; } PlotType_e ___4014::___1511() const { return ___3113; } ___2662 ___4014::___4150() { return new ___2663; } void ___4014::___4151(___2662* mutex) { delete *mutex; *mutex = NULL; } void ___4014::___4152(___2662 mutex) {
 #if defined TECIOMPI
___476(___1303); ___4276(mutex);
 #else
mutex->lock();
 #endif
} void ___4014::___4153(___2662 mutex) {
 #if defined TECIOMPI
___4276(mutex);
 #else
mutex->unlock();
 #endif
} void ___4014::___4154(___4158 ___2116, ___90 ___2121, ___2118 ___2117) {
 #if defined TECIOMPI
___4276(___2117); ___2116(___2121);
 #else
___2117->addJob(___2116, ___2121);
 #endif
} int ___4014::___4155() {
 #if defined TECIOMPI
return 1;
 #else
return ___2120::___2825();
 #endif
} ___2118 ___4014::___4156() { return new ___2120; } void ___4014::___4157(___2118* ___2117) { delete *___2117; *___2117 = NULL; } void ___4014::___4159(___2118 ___2117) {
 #if defined TECIOMPI
___4276(___2117);
 #else
___2117->wait();
 #endif
} int32_t ___4014::datasetGetNumPartitionFiles() const { return 0; } int32_t ___4014::zoneGetOwnerProcess(tecplot::___3931::___4633 ___4655) const { REQUIRE(m_tecioData.validZoneNum(___4655)); REQUIRE(!zoneIsPartitioned(___4655)); Zone_s const* zonePtr = m_tecioData.zonePtr(___4655); ___476(IMPLICATION(!zonePtr->m_partitionOwners.empty(), zonePtr->m_partitionOwners.size() == 1)); if (zonePtr->m_partitionOwners.empty()) return 0; return zonePtr->m_partitionOwners[0]; } int32_t ___4014::zonePartitionGetOwnerProcess(tecplot::___3931::___4633 ___4655, tecplot::___3931::___4633 partitionNum) const { REQUIRE(m_tecioData.validZoneNum(___4655)); REQUIRE(zoneIsPartitioned(___4655)); Zone_s const* zonePtr = m_tecioData.zonePtr(___4655); ___476(IMPLICATION(!zonePtr->m_partitionOwners.empty(), static_cast<size_t>(partitionNum) <= zonePtr->m_partitionOwners.size())); if (zonePtr->m_partitionOwners.empty()) return 0; return zonePtr->m_partitionOwners[partitionNum - 1]; } ___372 ___4014::zoneIsPartitioned(___4633 ___4655) const { REQUIRE(m_tecioData.validZoneNum(___4655)); Zone_s const* zonePtr = m_tecioData.zonePtr(___4655); if (zonePtr->m_partitionOwners.empty()) return zonePtr->m_partitionMap.empty() ? ___1303 : ___4224; return (zonePtr->m_partitionOwners.size() > 1); } ___4633 ___4014::zoneGetNumPartitions(___4633 ___4655) const { REQUIRE(m_tecioData.validZoneNum(___4655)); Zone_s const* zonePtr = m_tecioData.zonePtr(___4655); if (zonePtr->m_partitionOwners.empty()) return static_cast<___4633>(zonePtr->m_partitionMap.size()); return static_cast<___4633>(zonePtr->m_partitionOwners.size()); } namespace { Zone_s* getPartitionPtr(Zone_s::ZoneMap const& partitionMap, ___4633 partitionNum) { REQUIRE(partitionNum > 0); Zone_s::ZoneMap::const_iterator it = partitionMap.find(partitionNum - 1); if (it == partitionMap.end()) return NULL; else return it->second.get(); } } ___372 ___4014::zonePartitionGetSectionMetrics( ___4262 ASSERT_ONLY(dataSetID), ___4633 ___4655, ___4633 partitionNum, ___1170 section, FECellShape_e* cellShape, ___1170* gridOrder, FECellBasisFunction_e* basisFn, ___2225* numElements, ___1170* numCornersPerElem, ___1170* numNodesPerElem) const { REQUIRE(dataSetID == 0); REQUIRE(m_tecioData.validZoneNum(___4655)); REQUIRE(___4617(___4655) != ___4701 && ___4617(___4655) != ___4695 && ___4617(___4655) != ___4696); ASSERT_ONLY(___1170 numSections = 0); REQUIRE(zoneGetNumSections(dataSetID, ___4655, &numSections) && section <= numSections); REQUIRE(VALID_REF(cellShape)); REQUIRE(VALID_REF(gridOrder)); REQUIRE(VALID_REF(basisFn)); REQUIRE(VALID_REF(numElements)); Zone_s const* const zonePtr = m_tecioData.zonePtr(___4655); Zone_s const* partitionPtr = getPartitionPtr(zonePtr->m_partitionMap, partitionNum); return getSectionMetrics( *partitionPtr, section-1, *cellShape, *gridOrder, *basisFn, *numElements, *numCornersPerElem, *numNodesPerElem);
} void ___4014::zonePartitionGetIJK(___4633 ___4655, ___4633 partitionNum, ___1842& ___1859) const { REQUIRE(m_tecioData.validZoneNum(___4655)); REQUIRE(zoneIsPartitioned(___4655)); REQUIRE(m_tecioData.validPartitionNum(___4655, partitionNum)); Zone_s const* zonePtr = m_tecioData.zonePtr(___4655); Zone_s const* partitionPtr = getPartitionPtr(zonePtr->m_partitionMap, partitionNum); ___1859 = partitionPtr->___2680; } void ___4014::zonePartitionGetIJKOffset(tecplot::___3931::___4633 ___4655, tecplot::___3931::___4633 partitionNum, tecplot::___3931::___1842& ___1860) const { REQUIRE(m_tecioData.validZoneNum(___4655)); REQUIRE(zoneIsPartitioned(___4655)); REQUIRE(___4638(___4655)); Zone_s const* zonePtr = m_tecioData.zonePtr(___4655); Zone_s const* partitionPtr = getPartitionPtr(zonePtr->m_partitionMap, partitionNum); ___476(partitionPtr != NULL); ___1860 = partitionPtr->m_partitionOffset; } ___372 ___4014::dataValueGetMinMaxByZonePartitionVar( ___4633 ___4655, ___4633 partitionNum, ___4349 ___4333, double* minVal, double* maxVal) const { REQUIRE(m_tecioData.validZoneNum(___4655)); REQUIRE(zoneIsPartitioned(___4655)); REQUIRE(m_tecioData.validPartitionNum(___4655, partitionNum)); REQUIRE(0 < ___4333 && ___4333 <= static_cast<___4349>(m_tecioData.variableNames().size())); Zone_s const* zonePtr = m_tecioData.zonePtrForVar(___4655, ___4333); Zone_s const* partitionPtr = getPartitionPtr(zonePtr->m_partitionMap, partitionNum); partitionPtr->___2494[___4333 - 1]->___1757(*minVal, *maxVal); return ___4224; } ___1359 ___4014::dataValuePartitionGetReadableNLRef( ___4633 ___4655, ___4633 partitionNum, ___4349 ___4365) const { REQUIRE(m_tecioData.validZoneNum(___4655)); REQUIRE(zoneIsPartitioned(___4655)); REQUIRE(m_tecioData.validPartitionNum(___4655, partitionNum)); Zone_s const* zonePtr = m_tecioData.zonePtrForVar(___4655, ___4365); REQUIRE(zonePtr != NULL); Zone_s const* partitionPtr = getPartitionPtr(zonePtr->m_partitionMap, partitionNum); ___476(partitionPtr != NULL); REQUIRE(0 < ___4365 && ___4365 <= static_cast<___4349>(m_tecioData.variableNames().size())); if (partitionPtr->___2494[___4365 - 1]->___2667 == ___4327) return dataValuePartitionGetReadableNativeRef(___4655, partitionNum, ___4365); else return dataValuePartitionGetReadableDerivedRef(___4655, partitionNum, ___4365); } ___1359 ___4014::dataValuePartitionGetReadableCCRef( ___4633 ___4655, ___4633 partitionNum, ___4349 ___4365) const { REQUIRE(m_tecioData.validZoneNum(___4655)); REQUIRE(zoneIsPartitioned(___4655)); REQUIRE(m_tecioData.validPartitionNum(___4655, partitionNum)); REQUIRE(0 < ___4365 && ___4365 <= static_cast<___4349>(m_tecioData.variableNames().size())); Zone_s const* zonePtr = m_tecioData.zonePtrForVar(___4655, ___4365); Zone_s const* partitionPtr = getPartitionPtr(zonePtr->m_partitionMap, partitionNum); if (partitionPtr->___2494[___4365 - 1]->___2667 == ___4325)
return dataValuePartitionGetReadableNativeRef(___4655, partitionNum, ___4365); else return dataValuePartitionGetReadableDerivedRef(___4655, partitionNum, ___4365); } ___1359 ___4014::dataValuePartitionGetReadableNativeRef( ___4633 ___4655, ___4633 partitionNum, ___4349 ___4365) const { REQUIRE(m_tecioData.validZoneNum(___4655)); REQUIRE(zoneIsPartitioned(___4655)); REQUIRE(m_tecioData.validPartitionNum(___4655, partitionNum)); REQUIRE(0 < ___4365 && ___4365 <= static_cast<___4349>(m_tecioData.variableNames().size())); Zone_s const* zonePtr = m_tecioData.zonePtrForVar(___4655, ___4365); Zone_s const* partitionPtr = getPartitionPtr(zonePtr->m_partitionMap, partitionNum); return toTecUtilFieldData(partitionPtr->___2494[___4365 - 1].get()); } ___1359 ___4014::dataValuePartitionGetReadableDerivedRef( ___4633 ___4655, ___4633 partitionNum, ___4349 ___4365) const { REQUIRE(m_tecioData.validZoneNum(___4655)); REQUIRE(zoneIsPartitioned(___4655)); REQUIRE(m_tecioData.validPartitionNum(___4655, partitionNum)); REQUIRE(0 < ___4365 && ___4365 <= static_cast<___4349>(m_tecioData.variableNames().size())); Zone_s const* zonePtr = m_tecioData.zonePtrForVar(___4655, ___4365); Zone_s* partitionPtr = getPartitionPtr(zonePtr->m_partitionMap, partitionNum); try { if (partitionPtr->___2398[___4365 - 1]->storedValueCount() == 0) { Zone_s* connectivityZonePtr = m_tecioData.zonePtrForConnectivity(___4655); Zone_s* connectivityPartitionPtr = getPartitionPtr(connectivityZonePtr->m_partitionMap, partitionNum); if (partitionPtr->___2494[___4365 - 1]->___2667 == ___4325) partitionPtr->___963(___4365, connectivityPartitionPtr->___2495.get()); else partitionPtr->deriveCCValues(___4365, connectivityPartitionPtr->___2495.get()); } } catch (std::exception const&) { } return toTecUtilFieldData(partitionPtr->___2398[___4365 - 1].get()); } ___1359 ___4014::dataValuePartitionGetWritableNativeRef( ___4633 ___4655, ___4633 partitionNum, ___4349 ___4365) const { REQUIRE(m_tecioData.validZoneNum(___4655)); REQUIRE(zoneIsPartitioned(___4655)); REQUIRE(m_tecioData.validPartitionNum(___4655, partitionNum)); REQUIRE(0 < ___4365 && ___4365 <= static_cast<___4349>(m_tecioData.variableNames().size())); return dataValuePartitionGetReadableNativeRef(___4655, partitionNum, ___4365); } void ___4014::dataValuePartitionGetReadableRawPtr( ___4633 ___4655, ___4633 partitionNum, ___4349 ___4365, void** ___878, FieldDataType_e* ___1361) const { REQUIRE(m_tecioData.validZoneNum(___4655)); REQUIRE(zoneIsPartitioned(___4655)); REQUIRE(m_tecioData.validPartitionNum(___4655, partitionNum)); REQUIRE(0 < ___4365 && ___4365 <= static_cast<___4349>(m_tecioData.variableNames().size())); Zone_s const* zonePtr = m_tecioData.zonePtrForVar(___4655, ___4365); Zone_s const* partitionPtr = getPartitionPtr(zonePtr->m_partitionMap, partitionNum); *___878 = partitionPtr->___2494[___4365 - 1]->getRawPointer();
*___1361 = partitionPtr->___2494[___4365 - 1]->___2457; } void ___4014::dataValuePartitionGetWritableRawPtr( ___4633 ___4655, ___4633 partitionNum, ___4349 ___4365, void** ___878, FieldDataType_e* ___1361) const { dataValuePartitionGetReadableRawPtr(___4655, partitionNum, ___4365, ___878, ___1361); } ___2725 ___4014::dataNodePartitionGetReadableRef( ___4633 ___4655, ___4633 partitionNum) const { REQUIRE(m_tecioData.validZoneNum(___4655)); REQUIRE(zoneIsPartitioned(___4655)); REQUIRE(m_tecioData.validPartitionNum(___4655, partitionNum)); Zone_s const* zonePtr = m_tecioData.zonePtrForConnectivity(___4655); Zone_s const* partitionPtr = getPartitionPtr(zonePtr->m_partitionMap, partitionNum); return toTecUtilNodeMap(partitionPtr->___2495.get()); } ___2725 ___4014::dataNodePartitionGetWritableRef( ___4633 ___4655, ___4633 partitionNum) const { REQUIRE(m_tecioData.validZoneNum(___4655)); REQUIRE(zoneIsPartitioned(___4655)); REQUIRE(m_tecioData.validPartitionNum(___4655, partitionNum)); return dataNodePartitionGetReadableRef(___4655, partitionNum); } ___2740 ___4014::dataNodeToElemMapPartitionGetReadableRef( tecplot::___3931::___4633 ___4655, tecplot::___3931::___4633 partitionNum ) const { REQUIRE(m_tecioData.validZoneNum(___4655)); REQUIRE(zoneIsPartitioned(___4655)); REQUIRE(m_tecioData.validPartitionNum(___4655, partitionNum)); Zone_s const* zonePtr = m_tecioData.zonePtrForConnectivity(___4655); Zone_s* partitionPtr = getPartitionPtr(zonePtr->m_partitionMap, partitionNum); if (!partitionPtr->m_nodeToElemMap) partitionPtr->m_nodeToElemMap.reset(new ___2741(*partitionPtr->___2495, partitionPtr->___2680.___1668())); return toTecUtilNodeToElemMap(partitionPtr->m_nodeToElemMap.get()); } GhostInfo_pa ___4014::zoneGhostNodeInfoGetRef(___4633 ___4655) const { REQUIRE(m_tecioData.validZoneNum(___4655)); Zone_s const* zonePtr = m_tecioData.zonePtr(___4655); return &zonePtr->m_ghostNodeInfo; } GhostInfo_pa ___4014::zoneGhostCellInfoGetRef(___4633 ___4655) const { REQUIRE(m_tecioData.validZoneNum(___4655)); Zone_s const* zonePtr = m_tecioData.zonePtr(___4655); return &zonePtr->m_ghostCellInfo; } GhostInfo_pa ___4014::zonePartitionGhostNodeInfoGetRef( tecplot::___3931::___4633 ___4655, tecplot::___3931::___4633 partitionNum) const { REQUIRE(m_tecioData.validZoneNum(___4655)); REQUIRE(zoneIsPartitioned(___4655)); REQUIRE(m_tecioData.validPartitionNum(___4655, partitionNum)); Zone_s const* zonePtr = m_tecioData.zonePtr(___4655); Zone_s const* partitionPtr = getPartitionPtr(zonePtr->m_partitionMap, partitionNum); return &partitionPtr->m_ghostNodeInfo; } GhostInfo_pa ___4014::zonePartitionGhostCellInfoGetRef(tecplot::___3931::___4633 ___4655, tecplot::___3931::___4633 partitionNum) const { REQUIRE(m_tecioData.validZoneNum(___4655)); REQUIRE(zoneIsPartitioned(___4655)); REQUIRE(m_tecioData.validPartitionNum(___4655, partitionNum));
Zone_s const* zonePtr = m_tecioData.zonePtr(___4655); Zone_s const* partitionPtr = getPartitionPtr(zonePtr->m_partitionMap, partitionNum); return &partitionPtr->m_ghostCellInfo; } ___81 ___4014::ghostInfoGetNumItemsByRef( GhostInfo_pa ghostInfo, ___1170   sectionIndex) const { REQUIRE(VALID_REF(ghostInfo)); REQUIRE(ghostInfo->m_items.empty() || (1 <= sectionIndex && sectionIndex <= checked_numeric_cast<___1170>(ghostInfo->m_baseOffsetPerSection.size()))); if (ghostInfo->m_items.empty()) return static_cast<___81>(0); else return sectionIndex < checked_numeric_cast<___1170>(ghostInfo->m_baseOffsetPerSection.size()) ? static_cast<___81>(ghostInfo->m_baseOffsetPerSection[sectionIndex] - ghostInfo->m_baseOffsetPerSection[sectionIndex-1]) : static_cast<___81>(ghostInfo->m_items.size() - ghostInfo->m_baseOffsetPerSection[sectionIndex-1]); } ___81 ___4014::ghostInfoGetItemByRef( GhostInfo_pa ghostInfo, ___1170   sectionIndex, ___81   itemNum) const { REQUIRE(VALID_REF(ghostInfo)); REQUIRE(1 <= sectionIndex && sectionIndex <= checked_numeric_cast<___1170>(ghostInfo->m_baseOffsetPerSection.size())); REQUIRE(0 < itemNum && itemNum <= static_cast<___81>(ghostInfo->m_items.size())); return static_cast<___81>(ghostInfo->m_items[ghostInfo->m_baseOffsetPerSection[sectionIndex-1] + itemNum-1]); } ItemAddress64::___2978 ___4014::ghostInfoGetNeighborByRef( GhostInfo_pa ghostInfo, ___81 itemNum) const { REQUIRE(VALID_REF(ghostInfo)); REQUIRE(0 < itemNum && itemNum <= static_cast<___81>(ghostInfo->m_neighbors.size())); return ghostInfo->m_neighbors[itemNum - 1]; } ___81 ___4014::ghostInfoGetNeighborItemByRef( GhostInfo_pa ghostInfo, ___81 itemNum) const { REQUIRE(VALID_REF(ghostInfo)); REQUIRE(0 < itemNum && itemNum <= static_cast<___81>(ghostInfo->m_neighborItems.size())); return static_cast<___81>(ghostInfo->m_neighborItems[itemNum - 1]); } }}
