 #pragma once
#include "ThirdPartyHeadersBegin.h"
#include <algorithm>
#include <vector>
#include <boost/array.hpp>
#include <boost/shared_ptr.hpp>
#include "ThirdPartyHeadersEnd.h"
#include "ItemAddress.h"
#include "AltTecUtil.h"
namespace tecplot { namespace ___3931 { typedef boost::shared_ptr<class ___2722> ___2727; namespace { template <typename NODE_TYPE> void transformNodesToOneBasedValues( NODE_TYPE const* inputItBegin, NODE_TYPE const* inputItEnd, NODE_TYPE*       outputIt) { for (NODE_TYPE const* srcIt = inputItBegin; srcIt < inputItEnd; ++srcIt) { *outputIt = *srcIt + 1; ++outputIt; } } } class ___2722 { public: explicit ___2722(___37* tecUtil, ___1170 zone, bool writable = false); bool ___2065() const { bool ___3356 = m_tecUtil != nullptr && ___2495 != nullptr && VALID_ENUM(___2682, ZoneType_e) && VALID_ENUM(m_offsetDataType, OffsetDataType_e) && m_numSections               >  0 && m_rawNodeMapPtr32.size()    == (size_t)m_numSections && m_rawNodeMapPtr64.size()    == (size_t)m_numSections && ___2390.size()          == (size_t)m_numSections && m_cumulativeNumCells.size() == (size_t)m_numSections && m_numNodesPerCell.size()    == (size_t)m_numSections; int64_t cellCount{}; for (___1170 i = 0; ___3356 && i < m_numSections; ++i) { ___3356 = !(m_rawNodeMapPtr32[i] != nullptr && m_rawNodeMapPtr64[i] != nullptr) && 2 <= m_numNodesPerCell[i] && m_numNodesPerCell[i] <= checked_numeric_cast<int32_t>(MAX_NODES_PER_ELEM); cellCount += ___2390[i]; } return ___3356 && cellCount > 0; } OffsetDataType_e getOffsetDataType() const { return m_offsetDataType; } template <typename NODE_TYPE> void getElemNodes( ___1170  sectionIndex, ___463 startElemIndex, ___463 numElements, NODE_TYPE*  elemNodes) const { REQUIRE(sizeof(NODE_TYPE) == (m_offsetDataType == OffsetDataType_32Bit ? sizeof(int32_t) : sizeof(int64_t))); REQUIRE(1 <= sectionIndex && sectionIndex <= m_numSections); REQUIRE(1 <= startElemIndex && startElemIndex-1+numElements <= ___2390[sectionIndex-1]); REQUIRE(numElements > 0); REQUIRE(VALID_REF(elemNodes)); int32_t const numNodesPerCell = m_numNodesPerCell[sectionIndex-1]; ___463 const baseNodeOffset = (startElemIndex-1) * numNodesPerCell; NODE_TYPE const* const nodes = m_offsetDataType == OffsetDataType_32Bit ? reinterpret_cast<NODE_TYPE const*>(m_rawNodeMapPtr32[sectionIndex-1]) : reinterpret_cast<NODE_TYPE const*>(m_rawNodeMapPtr64[sectionIndex-1]); ___463 const numElemNodes = numElements * numNodesPerCell; if (nodes != NULL) transformNodesToOneBasedValues(nodes+baseNodeOffset, nodes+baseNodeOffset+numElemNodes, elemNodes); else m_tecUtil->dataNodeSectionArrayGetByRef(___2495, sectionIndex, baseNodeOffset+1, numElemNodes, elemNodes); } ___463 ___1764(___1170 sectionIndex) const { REQUIRE(1 <= sectionIndex && sectionIndex <= m_numSections); return ___2390[sectionIndex-1]; } int32_t getNumNodesPerCell(___1170 sectionIndex) const { REQUIRE(1 <= sectionIndex && sectionIndex <= m_numSections); return m_numNodesPerCell[sectionIndex-1]; } ZoneType_e ___4689() const { ENSURE(___2682 != ___4701); return ___2682; } struct SectionCell { ___1170 const  sectionIndex; ___463 const ___460; SectionCell(___1170 sectionIndex, ___463 ___460) : sectionIndex(sectionIndex), ___460(___460) {}
}; SectionCell convertGlobalCell(___463 globalCell) const { std::vector<___463>::const_iterator firstCumulativeNumCells = m_cumulativeNumCells.begin(); std::vector<___463>::const_iterator cumulativeNumCells = std::upper_bound( firstCumulativeNumCells, m_cumulativeNumCells.end(), globalCell-1); REQUIRE(cumulativeNumCells != m_cumulativeNumCells.end()); ___1170 const section = checked_numeric_cast<___1170>( std::distance(firstCumulativeNumCells, cumulativeNumCells)); ___463 const baseGlobalCellOffset = section == 0 ? 0 : m_cumulativeNumCells[section-1]; ___463 const cellInSection = (globalCell-1) - baseGlobalCellOffset; ENSURE(0 <= section && section < m_numSections); ENSURE(0 <= cellInSection && cellInSection < m_cumulativeNumCells[section]); return SectionCell(section+1,cellInSection+1); } ___1170 numSections() const { ENSURE((___2682 == ZoneType_FEMixed && m_numSections >= 1) || (___2682 != ZoneType_FEMixed && m_numSections == 1)); return m_numSections; } private: ___2722() : m_tecUtil(NULL) , ___2682(___4700) , m_numSections(-1) , ___2495(NULL) , m_offsetDataType(OffsetDataType_Invalid) { } ___37*              m_tecUtil; ZoneType_e               ___2682; ___1170               m_numSections; ___2725               ___2495; OffsetDataType_e         m_offsetDataType; std::vector<int32_t*>    m_rawNodeMapPtr32; std::vector<int64_t*>    m_rawNodeMapPtr64; std::vector<___463> ___2390; std::vector<___463> m_cumulativeNumCells; std::vector<int32_t>     m_numNodesPerCell; }; }}
