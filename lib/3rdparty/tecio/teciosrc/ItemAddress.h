 #pragma once
#include "ThirdPartyHeadersBegin.h"
#include <type_traits>
#include "ThirdPartyHeadersEnd.h"
#include "CodeContract.h"
#include "StandardIntegralTypes.h"
namespace tecplot {
 #define SIZE_IN_BITS(___1835) (sizeof(___1835)*8u)
 #define VALID_ITEM_ADDRESS_PARTITION(itemAddressPartition) \
 ((itemAddressPartition) != tecplot::ItemAddress64::INVALID_PARTITION && \
 (SIZE_IN_BITS(tecplot::ItemAddress64::___2978) == tecplot::ItemAddress64::PartitionBitSize || \
 (SIZE_IN_BITS(tecplot::ItemAddress64::___2978) > tecplot::ItemAddress64::PartitionBitSize && \
 uint64_t(itemAddressPartition) >> tecplot::ItemAddress64::PartitionBitSize == uint64_t(0))))
 #define VALID_ITEM_ADDRESS_SECTION_OFFSET(itemAddressSectionOffset) \
 ((itemAddressSectionOffset) != tecplot::ItemAddress64::INVALID_SECTION_OFFSET && \
 (SIZE_IN_BITS(tecplot::ItemAddress64::SectionOffset_t) == tecplot::ItemAddress64::SectionOffsetBitSize || \
 (SIZE_IN_BITS(tecplot::ItemAddress64::SectionOffset_t) > tecplot::ItemAddress64::SectionOffsetBitSize && \
 uint64_t(itemAddressSectionOffset) >> tecplot::ItemAddress64::SectionOffsetBitSize == uint64_t(0))))
 #define VALID_ITEM_ADDRESS_SUBZONE_OFFSET(itemAddressSubzoneOffset) \
 ((itemAddressSubzoneOffset) != tecplot::ItemAddress64::INVALID_SUBZONE_OFFSET && \
 (SIZE_IN_BITS(tecplot::ItemAddress64::SubzoneOffset_t) == tecplot::ItemAddress64::SubzoneOffsetBitSize || \
 (SIZE_IN_BITS(tecplot::ItemAddress64::SubzoneOffset_t) > tecplot::ItemAddress64::SubzoneOffsetBitSize && \
 uint64_t(itemAddressSubzoneOffset) >> tecplot::ItemAddress64::SubzoneOffsetBitSize == uint64_t(0))))
 #define VALID_ITEM_ADDRESS_ITEM_OFFSET(itemAddressItemOffset) \
 ((itemAddressItemOffset) != tecplot::ItemAddress64::INVALID_ITEM_OFFSET && \
 (SIZE_IN_BITS(tecplot::ItemAddress64::ItemOffset_t) == tecplot::ItemAddress64::ItemOffsetBitSize || \
 (SIZE_IN_BITS(tecplot::ItemAddress64::ItemOffset_t) > tecplot::ItemAddress64::ItemOffsetBitSize && \
 uint64_t(itemAddressItemOffset) >> tecplot::ItemAddress64::ItemOffsetBitSize == uint64_t(0))))
 #define VALID_UNIFORM_ITEM_ADDRESS(___2087) \
 ((___2087).___2063())
 #define VALID_SZL_ITEM_ADDRESS(___2087) \
 ((___2087).isSzlItem() && \
 VALID_ITEM_ADDRESS_PARTITION((___2087).___2975()) && \
 VALID_ITEM_ADDRESS_SECTION_OFFSET((___2087).sectionOffset()) && \
 VALID_ITEM_ADDRESS_SUBZONE_OFFSET((___2087).subzoneOffset()) && \
 VALID_ITEM_ADDRESS_ITEM_OFFSET((___2087).itemOffset()))
 #define VALID_ITEM_ADDRESS(___2087) \
 (VALID_UNIFORM_ITEM_ADDRESS(___2087) || \
 VALID_SZL_ITEM_ADDRESS(___2087))
 #define VALID_ITEM_ADDRESS_SUBZONE_ADDRESS(subzoneAddress) \
 (VALID_ITEM_ADDRESS_PARTITION((subzoneAddress).___2975()) && \
 VALID_ITEM_ADDRESS_SECTION_OFFSET((subzoneAddress).sectionOffset()) && \
 VALID_ITEM_ADDRESS_SUBZONE_OFFSET((subzoneAddress).subzoneOffset()))
template <typename ITEM_TYPE> class ___2088 { public: static_assert(std::is_same<ITEM_TYPE,int32_t>::value || std::is_same<ITEM_TYPE,int64_t>::value, "ITEM_TYPE must be a signed int32_t or int64_t type"); using SIGNED_INTEGER = ITEM_TYPE; using UNSIGNED_INTEGER = typename std::make_unsigned<SIGNED_INTEGER>::type; using ___2978 = uint32_t; using SectionOffset_t = uint32_t; using SubzoneIndex_t = uint64_t; using SubzoneOffset_t = uint32_t; using ItemOffset_t = uint16_t; using ___4259 = SIGNED_INTEGER; static constexpr uint32_t ___15 = 1u; static constexpr uint32_t SectionOffsetBitSize = 4u; static constexpr uint32_t ItemOffsetBitSize = 8u; static_assert(SIZE_IN_BITS(UNSIGNED_INTEGER)/2u > SectionOffsetBitSize, "Not sufficient bits available for subzones."); static constexpr uint32_t SubzoneOffsetBitSize = SIZE_IN_BITS(UNSIGNED_INTEGER)/2u - SectionOffsetBitSize; static_assert(SIZE_IN_BITS(UNSIGNED_INTEGER) > ___15 + SectionOffsetBitSize + SubzoneOffsetBitSize + ItemOffsetBitSize, "Not sufficient bits available for partitions."); static constexpr uint32_t PartitionBitSize = SIZE_IN_BITS(UNSIGNED_INTEGER) - (___15 + SectionOffsetBitSize + SubzoneOffsetBitSize + ItemOffsetBitSize); static_assert(SIZE_IN_BITS(UNSIGNED_INTEGER) > ___15 + SectionOffsetBitSize, "Not sufficient bits available for uniform offsets."); static constexpr uint32_t ___4257 = SIZE_IN_BITS(UNSIGNED_INTEGER) - (___15 + SectionOffsetBitSize); static constexpr uint32_t SzlAddressType     = 0u; static constexpr uint32_t UniformAddressType = 1u; static constexpr SectionOffset_t INVALID_SECTION_OFFSET = static_cast<SectionOffset_t>((uint64_t(1) << SectionOffsetBitSize)); static constexpr SectionOffset_t MAX_SECTION_OFFSET = INVALID_SECTION_OFFSET - static_cast<SectionOffset_t>(1); static constexpr ItemOffset_t INVALID_ITEM_OFFSET = static_cast<ItemOffset_t>((uint64_t(1) << ItemOffsetBitSize)); static constexpr ItemOffset_t MAX_ITEM_OFFSET = INVALID_ITEM_OFFSET - static_cast<ItemOffset_t>(1); static constexpr ___2978 INVALID_PARTITION = static_cast<___2978>((uint64_t(1) << PartitionBitSize) - uint64_t(1)); static constexpr ___2978 UNKNOWN_PARTITION = 0u; static constexpr ___2978 MAX_PARTITION = INVALID_PARTITION - static_cast<___2978>(1); static constexpr SubzoneOffset_t INVALID_SUBZONE_OFFSET = static_cast<SubzoneOffset_t>((uint64_t(1) << SubzoneOffsetBitSize) - uint64_t(1)); static constexpr SubzoneOffset_t MAX_SUBZONE_OFFSET = INVALID_SUBZONE_OFFSET - static_cast<SubzoneOffset_t>(1); static constexpr ___4259 INVALID_UNIFORM_OFFSET = static_cast<___4259>((uint64_t(1) << (___4257 - 1u))); static constexpr ___4259 MAX_UNIFORM_OFFSET = INVALID_UNIFORM_OFFSET - static_cast<___4259>(1); private: struct BaseAddress_s { UNSIGNED_INTEGER ___14:___15; UNSIGNED_INTEGER sectionOffset:SectionOffsetBitSize; }; struct SzlItemAddress_s
{ UNSIGNED_INTEGER ___14:___15; UNSIGNED_INTEGER sectionOffset:SectionOffsetBitSize; UNSIGNED_INTEGER ___2975:PartitionBitSize; UNSIGNED_INTEGER subzoneOffset:SubzoneOffsetBitSize; UNSIGNED_INTEGER itemOffset:ItemOffsetBitSize; }; struct ___4255 { UNSIGNED_INTEGER ___14:___15; UNSIGNED_INTEGER sectionOffset:SectionOffsetBitSize; SIGNED_INTEGER   ___2863:___4257; }; public: class SubzoneAddress { public: SubzoneAddress(); SubzoneAddress( ___2978     ___2975, SectionOffset_t sectionOffset, SubzoneOffset_t subzoneOffset); ___2978 ___2975() const; SectionOffset_t sectionOffset() const; SubzoneOffset_t subzoneOffset() const; bool operator==(SubzoneAddress const& ___2886) const; bool operator!=(SubzoneAddress const& ___2886) const; bool operator<(SubzoneAddress const& ___2886) const; bool operator<=(SubzoneAddress const& ___2886) const; bool operator>(SubzoneAddress const& ___2886) const; bool operator>=(SubzoneAddress const& ___2886) const; UNSIGNED_INTEGER toRawBits() const; static SubzoneAddress fromRawBits(UNSIGNED_INTEGER ___3268); private: union { BaseAddress_s    baseAddress; SzlItemAddress_s szlItemAddress; UNSIGNED_INTEGER ___3268; } m; }; ___2088(); ___2088(___2088<int32_t> const& ___2886); ___2088(___2088<int64_t> const& ___2886); ___2088(___2088&& ___2886) = default; ___2088( ___2978     ___2975, SectionOffset_t sectionOffset, SubzoneOffset_t subzoneOffset, ItemOffset_t    itemOffset); ___2088( SubzoneAddress subzoneAddress, ItemOffset_t   itemOffset); explicit ___2088(___4259 ___4256); ___2088( SectionOffset_t sectionOffset, ___4259 ___4256); bool ___2063() const; bool isSzlItem() const; uint32_t ___14() const; SubzoneAddress subzoneAddress() const; ___2978 ___2975() const; SectionOffset_t sectionOffset() const; SubzoneOffset_t subzoneOffset() const; ItemOffset_t itemOffset() const; ___4259 ___4256() const; UNSIGNED_INTEGER toRawBits() const; static ___2088 fromRawBits(UNSIGNED_INTEGER ___3268); ___2088& operator=(___2088 const& ___2886) = default; ___2088& operator=(___2088&& ___2886) = default; bool operator==(___2088 const& ___2886) const; bool operator!=(___2088 const& ___2886) const; bool operator<(___2088 const& ___2886) const; bool operator<=(___2088 const& ___2886) const; bool operator>(___2088 const& ___2886) const; bool operator>=(___2088 const& ___2886) const; private:
 #if !defined NO_ASSERTS
static bool ___4304();
 #endif
union { BaseAddress_s    baseAddress; SzlItemAddress_s szlItemAddress; ___4255 ___4254; UNSIGNED_INTEGER ___3268; } m; }; using ItemAddress32 = ___2088<int32_t>; using ItemAddress64 = ___2088<int64_t>; static_assert(sizeof(ItemAddress32) == sizeof(ItemAddress32::SIGNED_INTEGER) && sizeof(ItemAddress64) == sizeof(ItemAddress64::SIGNED_INTEGER), "The size of the ItemAddress union must be the same size as the ITEM_TYPE."); template <typename ITEM_TYPE> inline ___2088<ITEM_TYPE>::___2088() { INVARIANT(___4304()); } template <> inline ___2088<int64_t>::___2088(___2088<int32_t> const& ___2886) { m.baseAddress.___14   = ___2886.___14(); m.baseAddress.sectionOffset = ___2886.sectionOffset(); if (___2886.isSzlItem()) { m.szlItemAddress.___2975     = ___2886.___2975(); m.szlItemAddress.subzoneOffset = ___2886.subzoneOffset(); m.szlItemAddress.itemOffset    = ___2886.itemOffset(); } else { m.___4254.___2863 = ___2886.___4256(); } } template <> inline ___2088<int32_t>::___2088(___2088<int64_t> const& ___2886) { REQUIRE(IMPLICATION(___2886.isSzlItem() && sizeof(___2088) < sizeof(___2886), ___2886.___2975()     <= MAX_PARTITION && ___2886.sectionOffset() <= MAX_SECTION_OFFSET && ___2886.subzoneOffset() <= MAX_SUBZONE_OFFSET && ___2886.itemOffset()    <= MAX_ITEM_OFFSET)); REQUIRE(IMPLICATION(___2886.___2063() && sizeof(___2088) < sizeof(___2886), ___2886.sectionOffset() <= MAX_SECTION_OFFSET && ___2886.___4256() <= MAX_UNIFORM_OFFSET)); m.baseAddress.___14   = ___2886.___14(); m.baseAddress.sectionOffset = ___2886.sectionOffset(); if (___2886.isSzlItem()) { m.szlItemAddress.___2975     = ___2886.___2975(); m.szlItemAddress.subzoneOffset = ___2886.subzoneOffset(); m.szlItemAddress.itemOffset    = ___2886.itemOffset(); } else { m.___4254.___2863 = ___2886.___4256(); } } template <> inline ___2088<int32_t>::___2088(___2088<int32_t> const&) = default; template <> inline ___2088<int64_t>::___2088(___2088<int64_t> const&) = default; template <typename ITEM_TYPE> inline ___2088<ITEM_TYPE>::___2088( ___2978     ___2975, SectionOffset_t sectionOffset, SubzoneOffset_t subzoneOffset, ItemOffset_t    itemOffset) { INVARIANT(___4304()); REQUIRE(SIZE_IN_BITS(ITEM_TYPE) == 64u); REQUIRE(VALID_ITEM_ADDRESS_PARTITION(___2975)); REQUIRE(VALID_ITEM_ADDRESS_SECTION_OFFSET(sectionOffset)); REQUIRE(VALID_ITEM_ADDRESS_SUBZONE_OFFSET(subzoneOffset)); REQUIRE(VALID_ITEM_ADDRESS_ITEM_OFFSET(itemOffset)); m.baseAddress.___14   = SzlAddressType; m.baseAddress.sectionOffset = sectionOffset; m.szlItemAddress.___2975     = ___2975; m.szlItemAddress.subzoneOffset = subzoneOffset; m.szlItemAddress.itemOffset    = itemOffset; } template <typename ITEM_TYPE> inline ___2088<ITEM_TYPE>::___2088( SubzoneAddress subzoneAddress, ItemOffset_t   itemOffset) { INVARIANT(___4304()); REQUIRE(SIZE_IN_BITS(ITEM_TYPE) == 64u); REQUIRE(VALID_ITEM_ADDRESS_SUBZONE_ADDRESS(subzoneAddress));
REQUIRE(VALID_ITEM_ADDRESS_ITEM_OFFSET(itemOffset)); m.baseAddress.___14   = SzlAddressType; m.baseAddress.sectionOffset = subzoneAddress.sectionOffset(); m.szlItemAddress.___2975     = subzoneAddress.___2975(); m.szlItemAddress.subzoneOffset = subzoneAddress.subzoneOffset(); m.szlItemAddress.itemOffset    = itemOffset; } template <typename ITEM_TYPE> inline ___2088<ITEM_TYPE>::___2088(___4259 ___4256) { INVARIANT(___4304()); REQUIRE(SIZE_IN_BITS(ITEM_TYPE) == 32u || SIZE_IN_BITS(ITEM_TYPE) == 64u); m.baseAddress.___14   = UniformAddressType; m.baseAddress.sectionOffset = 0u; m.___4254.___2863 = ___4256; } template <typename ITEM_TYPE> inline ___2088<ITEM_TYPE>::___2088( SectionOffset_t sectionOffset, ___4259 ___4256) { INVARIANT(___4304()); REQUIRE(SIZE_IN_BITS(ITEM_TYPE) == 32u || SIZE_IN_BITS(ITEM_TYPE) == 64u); m.baseAddress.___14   = UniformAddressType; m.baseAddress.sectionOffset = sectionOffset; m.___4254.___2863 = ___4256; } template <typename ITEM_TYPE> inline bool ___2088<ITEM_TYPE>::___2063() const { ENSURE(m.baseAddress.___14 == SzlAddressType || m.baseAddress.___14 == UniformAddressType); return m.baseAddress.___14 == UniformAddressType; } template <typename ITEM_TYPE> inline bool ___2088<ITEM_TYPE>::isSzlItem() const { ENSURE(m.baseAddress.___14 == SzlAddressType || m.baseAddress.___14 == UniformAddressType); return m.baseAddress.___14 == SzlAddressType; } template <typename ITEM_TYPE> inline uint32_t ___2088<ITEM_TYPE>::___14() const { REQUIRE(isSzlItem() || ___2063()); return m.baseAddress.___14; } template <typename ITEM_TYPE> inline typename ___2088<ITEM_TYPE>::SubzoneAddress ___2088<ITEM_TYPE>::subzoneAddress() const { REQUIRE(isSzlItem()); return SubzoneAddress( m.szlItemAddress.___2975, m.baseAddress.sectionOffset, m.szlItemAddress.subzoneOffset); } template <typename ITEM_TYPE> inline typename ___2088<ITEM_TYPE>::___2978 ___2088<ITEM_TYPE>::___2975() const { REQUIRE(isSzlItem()); ENSURE(VALID_ITEM_ADDRESS_PARTITION(m.szlItemAddress.___2975)); return m.szlItemAddress.___2975; } template <typename ITEM_TYPE> inline typename ___2088<ITEM_TYPE>::SectionOffset_t ___2088<ITEM_TYPE>::sectionOffset() const { REQUIRE(isSzlItem() || ___2063()); ENSURE(VALID_ITEM_ADDRESS_SECTION_OFFSET(m.baseAddress.sectionOffset)); return m.baseAddress.sectionOffset; } template <typename ITEM_TYPE> inline typename ___2088<ITEM_TYPE>::SubzoneOffset_t ___2088<ITEM_TYPE>::subzoneOffset() const { REQUIRE(isSzlItem()); ENSURE(VALID_ITEM_ADDRESS_SUBZONE_OFFSET(m.szlItemAddress.subzoneOffset)); return m.szlItemAddress.subzoneOffset; } template <typename ITEM_TYPE> inline typename ___2088<ITEM_TYPE>::ItemOffset_t ___2088<ITEM_TYPE>::itemOffset() const { REQUIRE(isSzlItem()); ENSURE(VALID_ITEM_ADDRESS_ITEM_OFFSET(m.szlItemAddress.itemOffset));
return m.szlItemAddress.itemOffset; } template <typename ITEM_TYPE> inline typename ___2088<ITEM_TYPE>::___4259 ___2088<ITEM_TYPE>::___4256() const { REQUIRE(___2063()); return m.___4254.___2863; } template <typename ITEM_TYPE> inline typename ___2088<ITEM_TYPE>::UNSIGNED_INTEGER ___2088<ITEM_TYPE>::toRawBits() const { return m.___3268; } template <typename ITEM_TYPE> inline typename tecplot::___2088<ITEM_TYPE> ___2088<ITEM_TYPE>::fromRawBits(___2088<ITEM_TYPE>::UNSIGNED_INTEGER ___3268) { ___2088<ITEM_TYPE> ___3356; ___3356.m.___3268 = ___3268; ENSURE(VALID_ITEM_ADDRESS(___3356)); return ___3356; } template <typename ITEM_TYPE> inline bool ___2088<ITEM_TYPE>::operator==(___2088 const& ___2886) const { REQUIRE(VALID_ITEM_ADDRESS(___2886));
 #if defined LINUX
 #pragma GCC diagnostic push
 #pragma GCC diagnostic ignored "-Wmaybe-uninitialized"
 #endif
return m.___3268 == ___2886.m.___3268;
 #if defined LINUX
 #pragma GCC diagnostic pop
 #endif
} template <typename ITEM_TYPE> inline bool ___2088<ITEM_TYPE>::operator!=(___2088 const& ___2886) const { return !(*this == ___2886); } template <typename ITEM_TYPE> inline bool ___2088<ITEM_TYPE>::operator<(___2088 const& ___2886) const { REQUIRE(VALID_ITEM_ADDRESS(___2886)); uint32_t const thisType = ___14(); uint32_t const otherType = ___2886.___14(); if (thisType != otherType) { return thisType < otherType; } else if (thisType == tecplot::___2088<ITEM_TYPE>::UniformAddressType) { if (sectionOffset() == ___2886.sectionOffset()) return ___4256() < ___2886.___4256(); else return sectionOffset() < ___2886.sectionOffset(); } else if (___2975() == ___2886.___2975()) { if (sectionOffset() == ___2886.sectionOffset()) { if (subzoneOffset() == ___2886.subzoneOffset()) return itemOffset() < ___2886.itemOffset(); else return subzoneOffset() < ___2886.subzoneOffset(); } else { return sectionOffset() < ___2886.sectionOffset(); } } else { return ___2975() < ___2886.___2975(); } } template <typename ITEM_TYPE> inline bool ___2088<ITEM_TYPE>::operator<=(___2088 const& ___2886) const { return *this < ___2886 || *this == ___2886; } template <typename ITEM_TYPE> inline bool ___2088<ITEM_TYPE>::operator>(___2088 const& ___2886) const { return !(*this <= ___2886); } template <typename ITEM_TYPE> inline bool ___2088<ITEM_TYPE>::operator>=(___2088 const& ___2886) const { return !(*this < ___2886); }
 #if !defined NO_ASSERTS
template <typename ITEM_TYPE> inline bool ___2088<ITEM_TYPE>::___4304() { return (SIZE_IN_BITS(___2978)     >= PartitionBitSize     && SIZE_IN_BITS(SectionOffset_t) >  SectionOffsetBitSize && SIZE_IN_BITS(SubzoneOffset_t) >= SubzoneOffsetBitSize && SIZE_IN_BITS(ItemOffset_t)    >  ItemOffsetBitSize    && SIZE_IN_BITS(___4259) >= ___4257 && ___15 + SectionOffsetBitSize + ___4257 == SIZE_IN_BITS(___2088) && ___15 + PartitionBitSize + SectionOffsetBitSize + SubzoneOffsetBitSize + ItemOffsetBitSize == SIZE_IN_BITS(___2088)); }
 #endif
template <typename ITEM_TYPE> inline ___2088<ITEM_TYPE>::SubzoneAddress::SubzoneAddress() { INVARIANT(SIZE_IN_BITS(ITEM_TYPE) == 64u); } template <typename ITEM_TYPE> inline ___2088<ITEM_TYPE>::SubzoneAddress::SubzoneAddress( ___2978     ___2975, SectionOffset_t sectionOffset, SubzoneOffset_t subzoneOffset) { INVARIANT(SIZE_IN_BITS(ITEM_TYPE) == 64u); REQUIRE(VALID_ITEM_ADDRESS_PARTITION(___2975) || ___2975 == ___2088<ITEM_TYPE>::INVALID_PARTITION); REQUIRE(VALID_ITEM_ADDRESS_SECTION_OFFSET(sectionOffset)); REQUIRE(VALID_ITEM_ADDRESS_SUBZONE_OFFSET(subzoneOffset)); m.baseAddress.___14   = SzlAddressType; m.baseAddress.sectionOffset = sectionOffset; m.szlItemAddress.___2975     = ___2975; m.szlItemAddress.subzoneOffset = subzoneOffset; m.szlItemAddress.itemOffset    = 0u; } template <typename ITEM_TYPE> inline typename ___2088<ITEM_TYPE>::___2978 ___2088<ITEM_TYPE>::SubzoneAddress::___2975() const { REQUIRE(VALID_ITEM_ADDRESS_PARTITION(m.szlItemAddress.___2975) || m.szlItemAddress.___2975 == ___2088<ITEM_TYPE>::INVALID_PARTITION); REQUIRE(VALID_ITEM_ADDRESS_SECTION_OFFSET(m.baseAddress.sectionOffset)); REQUIRE(VALID_ITEM_ADDRESS_SUBZONE_OFFSET(m.szlItemAddress.subzoneOffset)); return m.szlItemAddress.___2975; } template <typename ITEM_TYPE> inline typename ___2088<ITEM_TYPE>::SectionOffset_t ___2088<ITEM_TYPE>::SubzoneAddress::sectionOffset() const { REQUIRE(VALID_ITEM_ADDRESS_PARTITION(m.szlItemAddress.___2975) || m.szlItemAddress.___2975 == ___2088<ITEM_TYPE>::INVALID_PARTITION); REQUIRE(VALID_ITEM_ADDRESS_SECTION_OFFSET(m.baseAddress.sectionOffset)); REQUIRE(VALID_ITEM_ADDRESS_SUBZONE_OFFSET(m.szlItemAddress.subzoneOffset)); return m.baseAddress.sectionOffset; } template <typename ITEM_TYPE> inline typename ___2088<ITEM_TYPE>::SubzoneOffset_t ___2088<ITEM_TYPE>::SubzoneAddress::subzoneOffset() const { REQUIRE(VALID_ITEM_ADDRESS_PARTITION(m.szlItemAddress.___2975) || m.szlItemAddress.___2975 == ___2088<ITEM_TYPE>::INVALID_PARTITION); REQUIRE(VALID_ITEM_ADDRESS_SECTION_OFFSET(m.baseAddress.sectionOffset)); REQUIRE(VALID_ITEM_ADDRESS_SUBZONE_OFFSET(m.szlItemAddress.subzoneOffset)); return m.szlItemAddress.subzoneOffset; } template <typename ITEM_TYPE> inline bool ___2088<ITEM_TYPE>::SubzoneAddress::operator==(SubzoneAddress const& ___2886) const { REQUIRE(VALID_ITEM_ADDRESS_PARTITION(m.szlItemAddress.___2975) || m.szlItemAddress.___2975 == ___2088<ITEM_TYPE>::INVALID_PARTITION); REQUIRE(VALID_ITEM_ADDRESS_SECTION_OFFSET(m.baseAddress.sectionOffset)); REQUIRE(VALID_ITEM_ADDRESS_SUBZONE_OFFSET(m.szlItemAddress.subzoneOffset));
 #if defined LINUX
 #pragma GCC diagnostic push
 #pragma GCC diagnostic ignored "-Wmaybe-uninitialized"
 #endif
return m.___3268 == ___2886.m.___3268;
 #if defined LINUX
 #pragma GCC diagnostic pop
 #endif
} template <typename ITEM_TYPE> inline bool ___2088<ITEM_TYPE>::SubzoneAddress::operator!=(SubzoneAddress const& ___2886) const { return !(*this == ___2886); } template <typename ITEM_TYPE> inline bool ___2088<ITEM_TYPE>::SubzoneAddress::operator<(SubzoneAddress const& ___2886) const { REQUIRE(VALID_ITEM_ADDRESS_PARTITION(m.szlItemAddress.___2975) || m.szlItemAddress.___2975 == ___2088<ITEM_TYPE>::INVALID_PARTITION); REQUIRE(VALID_ITEM_ADDRESS_SECTION_OFFSET(m.baseAddress.sectionOffset)); REQUIRE(VALID_ITEM_ADDRESS_SUBZONE_OFFSET(m.szlItemAddress.subzoneOffset)); if (___2975() == ___2886.___2975()) { if (sectionOffset() == ___2886.sectionOffset()) return subzoneOffset() < ___2886.subzoneOffset(); else return sectionOffset() < ___2886.sectionOffset(); } else { return ___2975() < ___2886.___2975(); } } template <typename ITEM_TYPE> inline bool ___2088<ITEM_TYPE>::SubzoneAddress::operator<=(SubzoneAddress const& ___2886) const { return *this < ___2886 || *this == ___2886; } template <typename ITEM_TYPE> inline bool ___2088<ITEM_TYPE>::SubzoneAddress::operator>(SubzoneAddress const& ___2886) const { return !(*this <= ___2886); } template <typename ITEM_TYPE> inline bool ___2088<ITEM_TYPE>::SubzoneAddress::operator>=(SubzoneAddress const& ___2886) const { return !(*this < ___2886); } template <typename ITEM_TYPE> inline typename ___2088<ITEM_TYPE>::UNSIGNED_INTEGER ___2088<ITEM_TYPE>::SubzoneAddress::toRawBits() const { return m.___3268; } template <typename ITEM_TYPE> inline typename tecplot::___2088<ITEM_TYPE>::SubzoneAddress ___2088<ITEM_TYPE>::SubzoneAddress::fromRawBits(___2088<ITEM_TYPE>::UNSIGNED_INTEGER ___3268) { ___2088<ITEM_TYPE>::SubzoneAddress ___3356; ___3356.m.___3268 = ___3268; ENSURE(VALID_ITEM_ADDRESS_PARTITION(___3356.m.szlItemAddress.___2975) || ___3356.m.szlItemAddress.___2975 == ___2088<ITEM_TYPE>::INVALID_PARTITION); ENSURE(VALID_ITEM_ADDRESS_SECTION_OFFSET(___3356.m.baseAddress.sectionOffset)); ENSURE(VALID_ITEM_ADDRESS_SUBZONE_OFFSET(___3356.m.szlItemAddress.subzoneOffset)); return ___3356; } }
