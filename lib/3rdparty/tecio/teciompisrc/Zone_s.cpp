#include "Zone_s.h"
#include "ThirdPartyHeadersBegin.h"
#include <algorithm>
#include <array>
#include <limits>
#include <sstream>
#include <boost/make_shared.hpp>
#include <boost/scoped_array.hpp>
#include <boost/shared_ptr.hpp>
#include "ThirdPartyHeadersEnd.h"
#include "FieldData_s.h"
 #if !defined TECIOMPI
#include "JobControl_s.h"
 #endif
#include "TecioData.h"
#include "feCellTypeMetrics.h"
#include "zoneUtil.h"
using namespace tecplot::___3931; namespace tecplot { namespace tecioszl { namespace {
 #define MIN_NODES_FOR_MULTITHREAD 100000 
 #define MIN_CELLS_FOR_MULTITHREAD 50000 
void getZoneCounts(int64_t& nodeCount, int64_t& cellCount, ___1842 const& zoneSize, ZoneType_e ___4689) { if (___4689 == ___4701) { nodeCount = (int64_t)zoneSize.i() * zoneSize.___2103() * zoneSize.___2132(); ___81 iMax = zoneSize.i(); ___81 jMax = zoneSize.___2103(); ___81 kMax = zoneSize.___2132(); if (kMax > 1) --kMax; else if (jMax > 1) --jMax; else if (iMax > 1) --iMax; cellCount = (int64_t)iMax * jMax * kMax; } else { nodeCount = (int64_t)zoneSize.i(); cellCount = (int64_t)zoneSize.___2103(); } } } Zone_s::Zone_s( std::string const& ___4687, ZoneType_e ___4689, int64_t iMin, int64_t jMin, int64_t kMin, int64_t ___1907, int64_t ___2114, int64_t ___2159, std::vector<FECellShape_e> const& cellShapes, std::vector<int32_t> const& gridOrders, std::vector<FECellBasisFunction_e> const& basisFns, std::vector<int64_t> const& numElementsPerSection, double ___3638, int32_t ___3783, ___1170 ___2972, int64_t ___2800, FaceNeighborMode_e ___1282, int64_t ___4190, int64_t ___2784, int64_t ___4186, std::vector<FieldDataType_e> const& ___1370, std::vector<int> const& passiveVarVector, std::vector<ValueLocation_e> const& ___4323, std::vector<___1170> const& shareVarFromZoneVector, ___1170 ___3547) : ___2681(___4687) , ___2682(___4689) , m_zoneDimension(-1) , m_partitionOffset((___81)(iMin - 1), (___81)(jMin - 1), (___81)(kMin - 1)) , ___2680((___81)(___1907 - iMin + 1), (___81)(___2114 - jMin + 1), (___81)(___2159 - kMin + 1)) , ___2619(___3638) , ___2620(___3783) , ___2612(___2972) , ___2501(___2800) , ___2456(___1282) , ___2649(___4190) , ___2499(___2784) , ___2648(___4186) , ___2458(___1370) , m_passiveVars(passiveVarVector) , ___2668(___4323) , m_shareVarFromZone(shareVarFromZoneVector) , m_shareConnectivityFromZone(___3547) , ___2395(static_cast<size_t>(-1)) , ___2343(new AuxData_s) { REQUIRE(___4687.size() > 0); REQUIRE(VALID_ENUM(___4689, ZoneType_e)); REQUIRE(iMin > 0); REQUIRE(jMin > 0); REQUIRE(kMin > 0); REQUIRE(0 < ___1907); REQUIRE(0 < ___2114); REQUIRE(IMPLICATION(___4689 == ___4701 || ___4689 == ___4695 || ___4689 == ___4696, 0 < ___2159)); REQUIRE(IMPLICATION(___4689 == ZoneType_FEMixed, cellShapes.size() == gridOrders.size() && cellShapes.size() == basisFns.size() && cellShapes.size() == numElementsPerSection.size() )); REQUIRE("solutionTime can be anything"); REQUIRE(0 <= ___3783); REQUIRE(0 <= ___2972); REQUIRE(0 <= ___2800); REQUIRE(___2668.size() > 0); REQUIRE(VALID_ENUM(___1282, FaceNeighborMode_e) || ___1282 == ___1286);
REQUIRE(IMPLICATION(___4689 == ___4696, 0 <= ___4190)); REQUIRE(IMPLICATION(___4689 == ___4696 || ___4689 == ___4695, 0 <= ___2784)); REQUIRE(IMPLICATION(___4689 == ___4696 || ___4689 == ___4695, 0 <= ___4186)); try { int64_t nodeCount; int64_t cellCount; getZoneCounts(nodeCount, cellCount, ___2680, ___2682); if (___2682 == ___4701) { std::array<int64_t,3> const dims = {___2680.i(), ___2680.___2103(), ___2680.___2132()}; m_zoneDimension = checked_numeric_cast<int32_t>( std::count_if(dims.begin(),dims.end(),[](int64_t dim){return dim > 1;})); if (m_zoneDimension == 0) m_zoneDimension = 1; } else if (___2682 == ZoneType_FEMixed) { m_cellShapes.resize(cellShapes.size()); m_gridOrders.resize(gridOrders.size()); m_basisFns.resize(basisFns.size()); m_numElementsPerSection.resize(numElementsPerSection.size()); for (std::vector<FECellShape_e>::size_type sec=0; sec<cellShapes.size(); ++sec) { m_cellShapes[sec] = cellShapes[sec]; m_gridOrders[sec] = gridOrders[sec]; m_basisFns[sec] = basisFns[sec]; m_numElementsPerSection[sec] = numElementsPerSection[sec]; } m_zoneDimension = feMixedZoneDimension(m_cellShapes[0]); } else { if (___2682 == ___4693) ___2680.___3495(2); else if (___2682 == ___4699) ___2680.___3495(3); else if (___2682 == ___4697 || ___2682 == ___4698) ___2680.___3495(4); else if (___2682 == ___4692) ___2680.___3495(8); else {___476(___2682 == ___4695 || ___2682 == ___4696);} m_zoneDimension = feNonMixedZoneDimension(___2682); } ___2494.resize(___2668.size()); ___2398.resize(___2668.size()); std::set<___3491> zoneSet; ___1170 numVarsShared = 0; for(size_t ___4289 = 0; ___4289 < ___2668.size(); ++___4289) { ___2494[___4289] = TypedFieldDataFactory().make(___2458[___4289]); ___2398[___4289] = TypedFieldDataFactory().make(___2458[___4289]); if (m_passiveVars[___4289] == 0 && m_shareVarFromZone[___4289] == 0) { if (___2395 == static_cast<size_t>(-1)) ___2395 = ___4289; if (___2668[___4289] == ___4327) { ___2494[___4289]->___2667 = ___4327; ___2494[___4289]->___2666 = nodeCount; ___2398[___4289]->___2667 = ___4325; ___2398[___4289]->___2666 = cellCount; } else { ___2494[___4289]->___2667 = ___4325; ___2494[___4289]->___2666 = cellCount; ___2398[___4289]->___2667 = ___4327; ___2398[___4289]->___2666 = nodeCount; } } } m_allVarsAreShared = numVarsShared == static_cast<___1170>(___2668.size()); if (!m_shareConnectivityFromZone && ___2682 != ___4701) { if (___2682 == ZoneType_FEMixed) { std::vector<int32_t> numNodesPerCellPerSection; numNodesPerCellPerSection.resize(cellShapes.size());
for (size_t section=0; section < cellShapes.size(); ++section) { ___1170 numEdges; ___1170 numFacesOrEdges; ___1170 ___2787; ___1170 ___2819; ___1170 numHighOrderNodes; ___1170 numNaturalSubElems; ___1170 const MAX_NUM_FACES_PER_ELEM = 6; std::vector<___1170> numCornersPerFaceOrEdge(MAX_NUM_FACES_PER_ELEM); std::vector<___1170> numNodesPerFaceOrEdge(MAX_NUM_FACES_PER_ELEM); std::vector<___1170> numHighOrderNodesPerFaceOrEdge(MAX_NUM_FACES_PER_ELEM); tecplot::feCellTypeMetrics( m_cellShapes[section], m_gridOrders[section], FECellBasisFunction_Lagrangian, numEdges, numFacesOrEdges, ___2787, ___2819, numHighOrderNodes, numNaturalSubElems, numCornersPerFaceOrEdge.begin(), numNodesPerFaceOrEdge.begin(), numHighOrderNodesPerFaceOrEdge.begin()); numNodesPerCellPerSection[section] = ___2819; } ___2495 = ___2728::makePtr(___2680.___1668(), m_numElementsPerSection, numNodesPerCellPerSection); } else { ___2495 = ___2728::makePtr( ___2680.___1668(), ___2114, ___2680.___1667()); } } } catch (std::bad_alloc const&) { std::cerr << "Failed to allocate sufficient resources to create zone.\n"; throw; } } Zone_s::Zone_s( Zone_s const* partitionParent, int64_t iMin, int64_t jMin, int64_t kMin, int64_t ___1907, int64_t ___2114, int64_t ___2159) { REQUIRE(VALID_REF(partitionParent)); REQUIRE(iMin > 0); REQUIRE(jMin > 0); REQUIRE(kMin > 0); REQUIRE(___1907      <= partitionParent->___2680.i()); REQUIRE(___2114 <= partitionParent->___2680.___2103()); REQUIRE(___2159    <= partitionParent->___2680.___2132()); REQUIRE(___1907 > iMin); REQUIRE(___2114 > jMin); REQUIRE(___2159 > kMin); *this = Zone_s(partitionParent->___2681, partitionParent->___2682, iMin, jMin, kMin, ___1907, ___2114, ___2159, partitionParent->m_cellShapes, partitionParent->m_gridOrders, partitionParent->m_basisFns, partitionParent->m_numElementsPerSection, partitionParent->___2619, partitionParent->___2620, partitionParent->___2612, 0, partitionParent->___2456, 0, 0, 0, partitionParent->___2458, partitionParent->m_passiveVars, partitionParent->___2668, partitionParent->m_shareVarFromZone, partitionParent->m_shareConnectivityFromZone); } namespace { struct FENodalValueDerivationData { ___2716 begin; ___2716 end; ___1360* nativeFieldData; ___1360* derivedFieldData; ___2741* nodeToElemMap; double minVal; double maxVal; FENodalValueDerivationData(___2716 begin, ___2716 end, ___1360* nativeFieldData, ___1360* derivedFieldData, ___2741* nodeToElemMap) : begin(begin) , end(end) , nativeFieldData(nativeFieldData) , derivedFieldData(derivedFieldData) , nodeToElemMap(nodeToElemMap) , minVal(std::numeric_limits<double>::max()) , maxVal(-std::numeric_limits<double>::max()) {} }; inline double getValueFromTypedRawPtr(void* rawPtr, int64_t index, FieldDataType_e type)
{ REQUIRE(VALID_REF(rawPtr)); REQUIRE(0 <= index); REQUIRE(VALID_ENUM(type, FieldDataType_e)); double value; switch(type) { case FieldDataType_Float: value = checked_numeric_cast<double>(((float*)(rawPtr))[index]); break; case FieldDataType_Double: value = ((double*)(rawPtr))[index]; break; case FieldDataType_Int32: value = checked_numeric_cast<double>(((int32_t*)(rawPtr))[index]); break; case FieldDataType_Int16: value = checked_numeric_cast<double>(((int16_t*)(rawPtr))[index]); break; case FieldDataType_Byte: value = checked_numeric_cast<double>(((uint8_t*)(rawPtr))[index]); break; case ___1363: value = checked_numeric_cast<double>((((uint8_t*)(rawPtr))[index / 8] >> (index % 8)) & 1); break; case ___1366: value = checked_numeric_cast<double>(((int64_t*)(rawPtr))[index]); break; default: ___476(___1303); value = 0.0; break; } return value; } inline void setValueToTypedRawPtr(void* rawPtr, int64_t index, FieldDataType_e type, double value) { REQUIRE(VALID_REF(rawPtr)); REQUIRE(0 <= index); REQUIRE(VALID_ENUM(type, FieldDataType_e)); switch(type) { case FieldDataType_Float: ((float*)(rawPtr))[index] = checked_numeric_cast<float>(value); break; case FieldDataType_Double: ((double*)(rawPtr))[index] = value; break; case FieldDataType_Int32: ((int32_t*)(rawPtr))[index] = checked_numeric_cast<int32_t>(value); break; case FieldDataType_Int16: ((int16_t*)(rawPtr))[index] = checked_numeric_cast<int16_t>(value); break; case FieldDataType_Byte: ((uint8_t*)(rawPtr))[index] = checked_numeric_cast<uint8_t>(value); break; case ___1363: if (value < 1.0) { value = 0.0; ((uint8_t *)(rawPtr))[index / 8] &= ~(checked_numeric_cast<uint8_t>(01) << (index % 8)); } else { value = 1.0; ((uint8_t *)(rawPtr))[index / 8] |= checked_numeric_cast<uint8_t>(01) << (index % 8); } break; case ___1366: ((int64_t*)(rawPtr))[index] = checked_numeric_cast<int64_t>(value); break; default: ___476(___1303); break; } } void deriveRangeOfNodalValues(___90 threadData) { FENodalValueDerivationData* derivationData = reinterpret_cast<FENodalValueDerivationData*>(threadData); REQUIRE(derivationData->derivedFieldData->___2457 == derivationData->nativeFieldData->___2457); void* rawCCPtr = derivationData->nativeFieldData->getRawPointer(); void* rawNodalPtr = derivationData->derivedFieldData->getRawPointer(); FieldDataType_e ___1361 = derivationData->nativeFieldData->___2457; for(___2716 ___2707 = derivationData->begin; ___2707 < derivationData->end; ++___2707) { double value = 0.0; ___463 startingIndex = derivationData->nodeToElemMap->m_elemIndex[___2707]; ___463 howManyCells = derivationData->nodeToElemMap->cellCountForNode(___2707); for(___463 whichCell = 0; whichCell < howManyCells; ++whichCell) { ___463 ___447 = derivationData->nodeToElemMap->m_elem[startingIndex + whichCell]; value += getValueFromTypedRawPtr(rawCCPtr, ___447, ___1361); } value /= howManyCells; setValueToTypedRawPtr(rawNodalPtr, ___2707, ___1361, value);
derivationData->minVal = std::min(derivationData->minVal, value); derivationData->maxVal = std::max(derivationData->maxVal, value); } } } void Zone_s::___963(___4349 ___4365, ___2728* ___2721) { REQUIRE(0 < ___4365 && ___4365 <= static_cast<___4349>(___2494.size())); REQUIRE(___2494[___4365 - 1]->___2667 == ___4325); ___1360::Ptr nativeFieldData = ___2494[___4365 - 1]; ___1360::Ptr derivedFieldData = ___2398[___4365 - 1]; derivedFieldData->assignValues(derivedFieldData->___2666, 0.0); if (___2682 == ___4701) { boost::scoped_array<uint16_t> divisor(new uint16_t[derivedFieldData->___2666]); for(size_t i = 0; i < derivedFieldData->___2666; ++i) divisor[i] = 0; int64_t const ___459 = std::max(int64_t(1), (int64_t)(___2680.i() - 1)); int64_t const ___464 = std::max(int64_t(1), (int64_t)(___2680.___2103() - 1)); int64_t const ___465 = std::max(int64_t(1), (int64_t)(___2680.___2132() - 1)); int64_t const nodeIMax = ___2680.i(); int64_t const nodeJMax = ___2680.___2103(); int64_t const nodeKMax = ___2680.___2132(); std::vector<int64_t> nodes; for (int64_t i = 0; i < ___459; ++i) { for (int64_t ___2103 = 0; ___2103 < ___464; ++___2103) { for (int64_t ___2132 = 0; ___2132 < ___465; ++___2132) { int64_t const index = (___2132 * nodeJMax + ___2103) * nodeIMax + i; nodes.resize(0); nodes.push_back(index); if (nodeIMax > 1) { nodes.push_back(index + 1); } if (nodeJMax > 1) { size_t count = nodes.size(); for(size_t n = 0; n < count; ++n) { nodes.push_back(nodes[n] + nodeIMax); } } if (nodeKMax > 1) { size_t count = nodes.size(); for(size_t n = 0; n < count; ++n) { nodes.push_back(nodes[n] + nodeIMax * nodeJMax); } } for(size_t n = 0; n < nodes.size(); ++n) { derivedFieldData->___3502(nodes[n], derivedFieldData->___1778(nodes[n]) + nativeFieldData->___1778(index)); ++divisor[nodes[n]]; } } } } for(size_t n = 0; n < derivedFieldData->storedValueCount(); ++n) derivedFieldData->___3502((___81)n, derivedFieldData->___1778(n) / (double)divisor[n]); } else { ___476(VALID_REF(___2721)); if (!m_nodeToElemMap) m_nodeToElemMap.reset(new ___2741(*___2721, ___2680.___1668()));
 #if !defined TECIOMPI
int numThreads = 1; if (m_nodeToElemMap->m_nodeCount >= MIN_NODES_FOR_MULTITHREAD) numThreads = std::min(___2120::___2825(), checked_numeric_cast<int>((m_nodeToElemMap->m_nodeCount - 1) / MIN_NODES_FOR_MULTITHREAD + 1)); if (numThreads == 1) {
 #endif
FENodalValueDerivationData derivationData(0, ___2680.___1668(), nativeFieldData.get(), derivedFieldData.get(), m_nodeToElemMap.get()); deriveRangeOfNodalValues((___90)&derivationData); derivedFieldData->___3497(derivationData.minVal, derivationData.maxVal);
 #if !defined TECIOMPI
} else { std::vector<boost::shared_ptr<FENodalValueDerivationData> > nodalDerivationData; for(int i = 0; i < numThreads; ++i) { ___2716 const begin = static_cast<___2716>((size_t)m_nodeToElemMap->m_nodeCount * i / numThreads); ___2716 const end = static_cast<___2716>((size_t)m_nodeToElemMap->m_nodeCount * (i + 1) / numThreads); nodalDerivationData.push_back(boost::make_shared<FENodalValueDerivationData>( begin, end, nativeFieldData.get(), derivedFieldData.get(), m_nodeToElemMap.get())); } ___2120 ___2117; for(int i = 0; i < numThreads; ++i) ___2117.addJob(deriveRangeOfNodalValues, reinterpret_cast<___90>(nodalDerivationData[i].get())); ___2117.wait(); double minVal = std::numeric_limits<double>::max(); double maxVal = -std::numeric_limits<double>::max(); for(int i = 0; i < numThreads; ++i) { minVal = std::min(minVal, nodalDerivationData[i]->minVal); maxVal = std::max(maxVal, nodalDerivationData[i]->maxVal); } derivedFieldData->___3497(minVal, maxVal); }
 #endif
} } namespace { struct FECCValueDerivationData { int64_t begin; int64_t end; ___1360* nativeFieldData; ___1360* derivedFieldData; ___2728* ___2721; int32_t section; double minVal; double maxVal; FECCValueDerivationData(int64_t begin, int64_t end, ___1360* nativeFieldData, ___1360* derivedFieldData, ___2728* ___2721, int32_t section) : begin(begin) , end(end) , nativeFieldData(nativeFieldData) , derivedFieldData(derivedFieldData) , ___2721(___2721) , section(section) , minVal(std::numeric_limits<double>::max()) , maxVal(-std::numeric_limits<double>::max()) {} }; void deriveRangeOfCCValues(___90 threadData) { FECCValueDerivationData* derivationData = reinterpret_cast<FECCValueDerivationData*>(threadData); REQUIRE(derivationData->derivedFieldData->___2457 == derivationData->nativeFieldData->___2457); void* rawNodalPtr = derivationData->nativeFieldData->getRawPointer(); void* rawCCPtr = derivationData->derivedFieldData->getRawPointer(); FieldDataType_e ___1361 = derivationData->nativeFieldData->___2457; for(int64_t ___447 = derivationData->begin; ___447 < derivationData->end; ++___447) { double value = 0.0; CellNodeIndex_t ___2819 = checked_numeric_cast<CellNodeIndex_t>(derivationData->___2721->m_numNodesPerCellPerSection[derivationData->section]); for(CellNodeIndex_t ___2707 = 0; ___2707 < ___2819; ++___2707) { int64_t nodeValue = derivationData->___2721->value(derivationData->section, ___447 * ___2819 + ___2707); value += getValueFromTypedRawPtr(rawNodalPtr, nodeValue, ___1361); } value /= ___2819; setValueToTypedRawPtr(rawCCPtr, ___447, ___1361, value); derivationData->minVal = std::min(derivationData->minVal, value); derivationData->maxVal = std::max(derivationData->maxVal, value); } } } void Zone_s::deriveCCValues(___4349 ___4365, ___2728* ___2721) { REQUIRE(0 < ___4365 && ___4365 <= static_cast<___4349>(___2494.size())); REQUIRE(___2494[___4365 - 1]->___2667 == ___4327); ___1360::Ptr nativeFieldData = ___2494[___4365 - 1]; ___1360::Ptr derivedFieldData = ___2398[___4365 - 1]; derivedFieldData->assignValues(derivedFieldData->___2666, 0.0); if (___2682 == ___4701) { int64_t const ___459 = std::max(int64_t(1), (int64_t)(___2680.i() - 1)); int64_t const ___464 = std::max(int64_t(1), (int64_t)(___2680.___2103() - 1)); int64_t const ___465 = std::max(int64_t(1), (int64_t)(___2680.___2132() - 1)); int64_t const nodeIMax = ___2680.i(); int64_t const nodeJMax = ___2680.___2103(); int64_t const nodeKMax = ___2680.___2132(); std::vector<int64_t> nodes; for (int64_t i = 0; i < ___459; ++i) { for (int64_t ___2103 = 0; ___2103 < ___464; ++___2103) { for (int64_t ___2132 = 0; ___2132 < ___465; ++___2132) { int64_t const index = (___2132 * nodeJMax + ___2103) * nodeIMax + i; nodes.resize(0); nodes.push_back(index); if (nodeIMax > 1) { nodes.push_back(index + 1); } if (nodeJMax > 1) { size_t count = nodes.size(); for(size_t n = 0; n < count; ++n) { nodes.push_back(nodes[n] + nodeIMax);
} } if (nodeKMax > 1) { size_t count = nodes.size(); for(size_t n = 0; n < count; ++n) { nodes.push_back(nodes[n] + nodeIMax * nodeJMax); } } double value = 0.0; for(size_t n = 0; n < nodes.size(); ++n) value += nativeFieldData->___1778(nodes[n]); derivedFieldData->___3502(index, value / nodes.size()); } } } } else { ___476(VALID_REF(___2721)); double minVal = std::numeric_limits<double>::max(); double maxVal = -std::numeric_limits<double>::max(); for (int32_t section = 0; section < checked_numeric_cast<int32_t>(___2721->m_numCellsPerSection.size()); ++section) { size_t ___2779 = ___2721->m_numCellsPerSection[section];
 #if !defined TECIOMPI
int numThreads = 1; if (___2779 >= MIN_CELLS_FOR_MULTITHREAD) { numThreads = std::min(___2120::___2825(), checked_numeric_cast<int>((___2779 - 1) / MIN_CELLS_FOR_MULTITHREAD + 1)); } if (numThreads == 1) {
 #endif
FECCValueDerivationData derivationData( 0, ___2779, nativeFieldData.get(), derivedFieldData.get(), ___2721, section); deriveRangeOfCCValues((___90)&derivationData); minVal = std::min(minVal, derivationData.minVal); maxVal = std::max(maxVal, derivationData.maxVal);
 #if !defined TECIOMPI
} else { std::vector<boost::shared_ptr<FECCValueDerivationData> > derivationData; for (int i = 0; i < numThreads; ++i) { ___463 const begin = static_cast<___463>((size_t)___2779 * i / numThreads); ___463 const end = static_cast<___463>((size_t)___2779 * (i + 1) / numThreads); derivationData.push_back(boost::make_shared<FECCValueDerivationData>( begin, end, nativeFieldData.get(), derivedFieldData.get(), ___2721, section)); } ___2120 ___2117; for (int i = 0; i < numThreads; ++i) { ___2117.addJob(deriveRangeOfCCValues, reinterpret_cast<___90>(derivationData[i].get())); } ___2117.wait(); for (int i = 0; i < numThreads; ++i) { minVal = std::min(minVal, derivationData[i]->minVal); maxVal = std::max(maxVal, derivationData[i]->maxVal); } }
 #endif
} derivedFieldData->___3497(minVal, maxVal); } } Zone_s::Zone_s() {} void Zone_s::writeToFile(FileWriterInterface& outputFile, bool ___4477) const { ___4541(outputFile, ___2681, ___4477); writeScalar(outputFile, (uint32_t)___2682, ___4477); writeScalar(outputFile, m_partitionOffset.i(), ___4477); writeScalar(outputFile, m_partitionOffset.___2103(), ___4477); writeScalar(outputFile, m_partitionOffset.___2132(), ___4477); writeScalar(outputFile, ___2680.i(), ___4477); writeScalar(outputFile, ___2680.___2103(), ___4477); writeScalar(outputFile, ___2680.___2132(), ___4477); writeScalar(outputFile, ___2619, ___4477); writeScalar(outputFile, ___2620, ___4477); writeScalar(outputFile, ___2612, ___4477); writeScalar(outputFile, ___2501, ___4477); writeScalar(outputFile, (uint32_t)___2456, ___4477); writeScalar(outputFile, ___2649, ___4477); writeScalar(outputFile, ___2499, ___4477); writeScalar(outputFile, ___2648, ___4477); std::vector<uint32_t>tempFieldDataTypes(___2458.begin(), ___2458.end()); writeVector(outputFile, tempFieldDataTypes, ___4477); writeVector(outputFile, m_passiveVars, ___4477); std::vector<uint32_t> tempValueLocations(___2668.begin(), ___2668.end()); writeVector(outputFile, tempValueLocations, ___4477); writeVector(outputFile, m_shareVarFromZone, ___4477); writeScalar(outputFile, m_shareConnectivityFromZone, ___4477); m_ghostNodeInfo.writeToFile(outputFile, ___4477); m_ghostCellInfo.writeToFile(outputFile, ___4477); writeVectorOfPtrs(outputFile, ___2494, ___4477); writeScalar(outputFile, (uint64_t)___2395, ___4477); if (___2682 != ___4701) ___2495->writeToFile(outputFile, ___4477); writeMapOfPairsToObjects(outputFile, ___2455, ___4477); ___2343->writeToFile(outputFile, ___4477); writeMapOfScalarsToPtrs(outputFile, m_partitionMap, ___4477); writeVector(outputFile, m_partitionOwners, ___4477); } uint64_t Zone_s::sizeInFile(bool ___4477) const { uint64_t sizeInFile = 0; sizeInFile += stringSizeInFile(___2681, ___4477); sizeInFile += scalarSizeInFile((uint32_t)___2682, ___4477); sizeInFile += scalarSizeInFile(m_partitionOffset.i(), ___4477); sizeInFile += scalarSizeInFile(m_partitionOffset.___2103(), ___4477); sizeInFile += scalarSizeInFile(m_partitionOffset.___2132(), ___4477); sizeInFile += scalarSizeInFile(___2680.i(), ___4477); sizeInFile += scalarSizeInFile(___2680.___2103(), ___4477); sizeInFile += scalarSizeInFile(___2680.___2132(), ___4477); sizeInFile += scalarSizeInFile(___2619, ___4477); sizeInFile += scalarSizeInFile(___2620, ___4477); sizeInFile += scalarSizeInFile(___2612, ___4477); sizeInFile += scalarSizeInFile(___2501, ___4477); sizeInFile += scalarSizeInFile((uint32_t)___2456, ___4477); sizeInFile += scalarSizeInFile(___2649, ___4477);
sizeInFile += scalarSizeInFile(___2499, ___4477); sizeInFile += scalarSizeInFile(___2648, ___4477); std::vector<uint32_t> tempFieldDataTypes(___2458.size()); sizeInFile += vectorSizeInFile(tempFieldDataTypes, ___4477); sizeInFile += vectorSizeInFile(m_passiveVars, ___4477); std::vector<uint32_t> tempValueLocations(___2668.size()); sizeInFile += vectorSizeInFile(tempValueLocations, ___4477); sizeInFile += vectorSizeInFile(m_shareVarFromZone, ___4477); sizeInFile += scalarSizeInFile(m_shareConnectivityFromZone, ___4477); sizeInFile += m_ghostNodeInfo.sizeInFile(___4477); sizeInFile += m_ghostCellInfo.sizeInFile(___4477); sizeInFile += vectorOfPtrsSizeInFile(___2494, ___4477); sizeInFile += scalarSizeInFile((uint64_t)___2395, ___4477); if (___2682 != ___4701) sizeInFile += ___2495->sizeInFile(___4477); sizeInFile += mapOfPairsToObjectsSizeInFile(___2455, ___4477); sizeInFile += ___2343->sizeInFile(___4477); sizeInFile += mapOfScalarsToPtrsSizeInFile(m_partitionMap, ___4477); sizeInFile += vectorSizeInFile(m_partitionOwners, ___4477); return sizeInFile; } boost::shared_ptr<Zone_s> Zone_s::makePtr(___1397& inputFile, bool readASCII) { Zone_s* newZone = new Zone_s; readString(inputFile, newZone->___2681, readASCII); READ_ENUM(newZone->___2682, ZoneType_e, inputFile, readASCII); ___81 i, ___2103, ___2132; readScalar(inputFile, i, readASCII); readScalar(inputFile, ___2103, readASCII); readScalar(inputFile, ___2132, readASCII); newZone->m_partitionOffset = ___1842(i, ___2103, ___2132); readScalar(inputFile, i, readASCII); readScalar(inputFile, ___2103, readASCII); readScalar(inputFile, ___2132, readASCII); newZone->___2680 = ___1842(i, ___2103, ___2132); readScalar(inputFile, newZone->___2619, readASCII); readScalar(inputFile, newZone->___2620, readASCII); readScalar(inputFile, newZone->___2612, readASCII); readScalar(inputFile, newZone->___2501, readASCII); READ_ENUM(newZone->___2456, FaceNeighborMode_e, inputFile, readASCII); readScalar(inputFile, newZone->___2649, readASCII); readScalar(inputFile, newZone->___2499, readASCII); readScalar(inputFile, newZone->___2648, readASCII); READ_ENUM_VECTOR(newZone->___2458, FieldDataType_e, inputFile, readASCII); readVector(inputFile, newZone->m_passiveVars, readASCII); READ_ENUM_VECTOR(newZone->___2668, ValueLocation_e, inputFile, readASCII); readVector(inputFile, newZone->m_shareVarFromZone, readASCII); readScalar(inputFile, newZone->m_shareConnectivityFromZone, readASCII); newZone->m_ghostNodeInfo = GhostInfo_s(inputFile, readASCII); newZone->m_ghostCellInfo = GhostInfo_s(inputFile, readASCII); readVectorOfPtrs(inputFile, newZone->___2494, readASCII); newZone->___2398.resize(newZone->___2494.size()); readScalar(inputFile, newZone->___2395, readASCII);
if (newZone->___2682 != ___4701) newZone->___2495 = ___2728::makePtr(inputFile, readASCII); readMapOfPairsToObjects(inputFile, newZone->___2455, readASCII); newZone->___2343 = AuxData_s::makePtr(inputFile, readASCII); readMapOfScalarsToPtrs(inputFile, newZone->m_partitionMap, readASCII); readVector(inputFile, newZone->m_partitionOwners, readASCII); int64_t nodeCount; int64_t cellCount; getZoneCounts(nodeCount, cellCount, newZone->___2680, newZone->___2682); for(size_t ___4289 = 0; ___4289 < newZone->___2398.size(); ++___4289) { newZone->___2398[___4289] = TypedFieldDataFactory().make(newZone->___2458[___4289]); if (newZone->___2668[___4289] == ___4327) { newZone->___2398[___4289]->___2667 = ___4325; newZone->___2398[___4289]->___2666 = cellCount; } else { newZone->___2398[___4289]->___2667 = ___4327; newZone->___2398[___4289]->___2666 = nodeCount; } } return boost::shared_ptr<Zone_s>(newZone); } }}
