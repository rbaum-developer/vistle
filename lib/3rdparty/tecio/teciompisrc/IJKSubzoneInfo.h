 #pragma once
#include "ThirdPartyHeadersBegin.h"
#   include <algorithm>
#include "ThirdPartyHeadersEnd.h"
#include "SzlFileLoader.h"
#include "IJK.h"
namespace tecplot { namespace ___3931 { class IJKSubzoneInfo { private: ___1842 m_zoneIJKDim; ___1842 m_zoneLastIJKIndex; ___1842 m_subzoneItemsMaxIJKDim; ItemAddress64::___2978 m_partition; ___1842 m_subzoneTilingIJKDim; ___1842 m_subzoneTilingIJKShift; ItemAddress64::SubzoneOffset_t m_numSubzones;
 #if !defined NO_ASSERTS
bool ___2490;
 #endif
public: IJKSubzoneInfo( ___1842 const&               zoneIJKDim, ___1842 const&               subzoneMaxIJKDim, ItemAddress64::___2978 ___2975, bool                     minimizeNumSubzones) : m_zoneIJKDim(zoneIJKDim) , m_zoneLastIJKIndex(zoneIJKDim.maxOp(1)-1) , m_subzoneItemsMaxIJKDim(subzoneMaxIJKDim) , m_partition(___2975) , m_subzoneTilingIJKDim(numSubzonesForDirection(zoneIJKDim.i(), ItemAddress64::ItemOffset_t(subzoneMaxIJKDim.i()), minimizeNumSubzones), numSubzonesForDirection(zoneIJKDim.___2103(), ItemAddress64::ItemOffset_t(subzoneMaxIJKDim.___2103()), minimizeNumSubzones), numSubzonesForDirection(zoneIJKDim.___2132(), ItemAddress64::ItemOffset_t(subzoneMaxIJKDim.___2132()), minimizeNumSubzones)) , m_subzoneTilingIJKShift(subzoneShiftForDirection(zoneIJKDim.i(), ItemAddress64::ItemOffset_t(subzoneMaxIJKDim.i()), minimizeNumSubzones), subzoneShiftForDirection(zoneIJKDim.___2103(), ItemAddress64::ItemOffset_t(subzoneMaxIJKDim.___2103()), minimizeNumSubzones), subzoneShiftForDirection(zoneIJKDim.___2132(), ItemAddress64::ItemOffset_t(subzoneMaxIJKDim.___2132()), minimizeNumSubzones)) , m_numSubzones( ItemAddress64::SubzoneOffset_t(m_subzoneTilingIJKDim.blockSize()) )
 #if !defined NO_ASSERTS
, ___2490(minimizeNumSubzones)
 #endif
{ REQUIRE(zoneIJKDim>0); REQUIRE(subzoneMaxIJKDim>0); } IJKSubzoneInfo() : m_zoneIJKDim(0,0,0) , m_zoneLastIJKIndex(0,0,0) , m_subzoneItemsMaxIJKDim(0,0,0) , m_partition(0) , m_subzoneTilingIJKDim(0,0,0) , m_subzoneTilingIJKShift(0,0,0) , m_numSubzones(0)
 #if !defined NO_ASSERTS
, ___2490(0)
 #endif
{} ~IJKSubzoneInfo() {} inline void swap(IJKSubzoneInfo& ___2886) { using std::swap; swap(m_zoneIJKDim, ___2886.m_zoneIJKDim); swap(m_zoneLastIJKIndex, ___2886.m_zoneLastIJKIndex); swap(m_subzoneItemsMaxIJKDim, ___2886.m_subzoneItemsMaxIJKDim); swap(m_partition, ___2886.m_partition); swap(m_subzoneTilingIJKDim, ___2886.m_subzoneTilingIJKDim); swap(m_subzoneTilingIJKShift, ___2886.m_subzoneTilingIJKShift); swap(m_numSubzones, ___2886.m_numSubzones);
 #if !defined NO_ASSERTS
swap(___2490, ___2886.___2490);
 #endif
} inline void reset( ___1842 const& zoneIJKSize, ___1842 const& subzoneIJKMax, bool       minimizeNumSubzones = DEFAULT_MINIMIZE_IJK_NUM_SUBZONES) { REQUIRE(zoneIJKSize>0); REQUIRE(subzoneIJKMax>0); REQUIRE(minimizeNumSubzones==DEFAULT_MINIMIZE_IJK_NUM_SUBZONES); m_zoneIJKDim = zoneIJKSize; m_zoneLastIJKIndex = zoneIJKSize.maxOp(1)-1; m_subzoneItemsMaxIJKDim = subzoneIJKMax; m_subzoneTilingIJKDim = ___1842( numSubzonesForDirection(zoneIJKSize.i(), ItemAddress64::ItemOffset_t(subzoneIJKMax.i()), minimizeNumSubzones), numSubzonesForDirection(zoneIJKSize.___2103(), ItemAddress64::ItemOffset_t(subzoneIJKMax.___2103()), minimizeNumSubzones), numSubzonesForDirection(zoneIJKSize.___2132(), ItemAddress64::ItemOffset_t(subzoneIJKMax.___2132()), minimizeNumSubzones) ); m_subzoneTilingIJKShift = ___1842( subzoneShiftForDirection(zoneIJKSize.i(), ItemAddress64::ItemOffset_t(subzoneIJKMax.i()), minimizeNumSubzones), subzoneShiftForDirection(zoneIJKSize.___2103(), ItemAddress64::ItemOffset_t(subzoneIJKMax.___2103()), minimizeNumSubzones), subzoneShiftForDirection(zoneIJKSize.___2132(), ItemAddress64::ItemOffset_t(subzoneIJKMax.___2132()), minimizeNumSubzones) ); m_numSubzones = ItemAddress64::SubzoneOffset_t(m_subzoneTilingIJKDim.blockSize()); } inline bool ___2065() const { return m_zoneIJKDim > 0 && m_subzoneItemsMaxIJKDim > 0; } inline bool validSubzone(ItemAddress64::SubzoneOffset_t ___3878) const { return ___3878 < getNumSzs(); } inline bool validSzAddress(ItemAddress64::SubzoneAddress const& szAddress) const { return validSubzone(szAddress.subzoneOffset()) && szAddress.___2975() == m_partition; } inline bool validItemAddress(ItemAddress64 const& ___2087) const { return validSzAddress(___2087.subzoneAddress()) && ___2087.itemOffset() < numItemsInSz(___2087.subzoneOffset()); } ___81 getNumItems(void) const { return m_zoneIJKDim.blockSize(); } ___1842 const& ijkDim(void) const { return m_zoneIJKDim; } ___1842 const& ijkLastIndex(void) const { ___476(m_zoneLastIJKIndex == m_zoneIJKDim.maxOp(1)-1); return m_zoneLastIJKIndex; } ItemAddress64::SubzoneOffset_t getNumSzs(void) const { ENSURE(m_numSubzones == ItemAddress64::SubzoneOffset_t(m_subzoneTilingIJKDim.blockSize())); ENSURE(m_numSubzones == calcNumSubzones(m_zoneIJKDim, m_subzoneItemsMaxIJKDim, ___2490)); return m_numSubzones; } static inline ItemAddress64::SubzoneOffset_t numSubzonesForDirection( ___81                  itemIndexDim, ItemAddress64::ItemOffset_t subzoneIndexMax, bool                        minimizeNumSubzones = DEFAULT_MINIMIZE_IJK_NUM_SUBZONES) { REQUIRE(itemIndexDim>0); REQUIRE(subzoneIndexMax<=ItemAddress64::MAX_ITEM_OFFSET+1); ItemAddress64::SubzoneOffset_t numSubzonesForDir; if ( minimizeNumSubzones ) { numSubzonesForDir = ItemAddress64::SubzoneOffset_t( (itemIndexDim+subzoneIndexMax-1)/subzoneIndexMax ); } else { numSubzonesForDir = ItemAddress64::SubzoneOffset_t( 1+(itemIndexDim/subzoneIndexMax) ); } ENSURE(numSubzonesForDir>0); ENSURE((___81)numSubzonesForDir*subzoneIndexMax>=itemIndexDim); ENSURE( IMPLICATION(minimizeNumSubzones, ___81(numSubzonesForDir-1)*subzoneIndexMax<itemIndexDim) );
return numSubzonesForDir; } static ItemAddress64::SubzoneOffset_t calcNumSubzones( ___1842 const& zoneIJKDim, ___1842 const& subzoneIJKMax, bool       minimizeIJKNumSubzones) { REQUIRE(zoneIJKDim>0); REQUIRE(subzoneIJKMax>0); ___1842 const subzoneTilingIJK( numSubzonesForDirection(zoneIJKDim.i(), ItemAddress64::ItemOffset_t(subzoneIJKMax.i()), minimizeIJKNumSubzones), numSubzonesForDirection(zoneIJKDim.___2103(), ItemAddress64::ItemOffset_t(subzoneIJKMax.___2103()), minimizeIJKNumSubzones), numSubzonesForDirection(zoneIJKDim.___2132(), ItemAddress64::ItemOffset_t(subzoneIJKMax.___2132()), minimizeIJKNumSubzones)); ItemAddress64::SubzoneOffset_t const numSubzones = ItemAddress64::SubzoneOffset_t(subzoneTilingIJK.blockSize()); ENSURE(numSubzones>0 && numSubzones <= zoneIJKDim.blockSize()); return numSubzones; } static inline ItemAddress64::ItemOffset_t subzoneShiftForDirection( ___81                  itemIndexDim, ItemAddress64::ItemOffset_t subzoneIndexMax, bool                        minimizeNumSubzones = DEFAULT_MINIMIZE_IJK_NUM_SUBZONES) { REQUIRE(itemIndexDim>0); REQUIRE(subzoneIndexMax>=3 && subzoneIndexMax<=ItemAddress64::MAX_ITEM_OFFSET+1); ItemAddress64::ItemOffset_t const remainder = ItemAddress64::ItemOffset_t(itemIndexDim % subzoneIndexMax); ItemAddress64::ItemOffset_t subzoneShift = (subzoneIndexMax-remainder)/2; if ( minimizeNumSubzones && remainder == 0 ) subzoneShift = 0; ENSURE(subzoneShift<subzoneIndexMax); return subzoneShift; } ___1842 itemIJKStart(___1842 const& szIJK) const { INVARIANT(m_subzoneTilingIJKShift<m_subzoneItemsMaxIJKDim); ___1842 const indexStart = m_subzoneTilingIJKShift.maxOp(szIJK*m_subzoneItemsMaxIJKDim) - m_subzoneTilingIJKShift; ENSURE(indexStart >= 0); return indexStart; } ___1842 itemIJKEnd(___1842 const& szIJK) const { INVARIANT(m_subzoneTilingIJKShift < m_subzoneItemsMaxIJKDim); ___1842 const indexEnd = m_zoneIJKDim.minOp((szIJK + 1)*m_subzoneItemsMaxIJKDim - m_subzoneTilingIJKShift) - 1; ENSURE(indexEnd<m_zoneIJKDim); return indexEnd; } ___1842 szIJKAtSzIndex(ItemAddress64::SubzoneOffset_t ___3878) const { REQUIRE(validSubzone(___3878)); ___1842 const subzoneIJK = m_subzoneTilingIJKDim.ijkAtOffset(___3878); ENSURE(subzoneIJK<m_subzoneTilingIJKDim); return subzoneIJK; } ItemAddress64::SubzoneAddress szAddressAtSzIJK(___1842 const& szIJK) const { REQUIRE(szIJK<m_subzoneTilingIJKDim); size_t const section = 0; ItemAddress64::SubzoneAddress const szAddress(m_partition, section, static_cast<ItemAddress64::SubzoneOffset_t>(m_subzoneTilingIJKDim.offsetAtIJK(szIJK))); ENSURE(validSzAddress(szAddress)); ENSURE(szIJKAtSzIndex(szAddress.subzoneOffset())==szIJK); return szAddress; } void subzoneIJKStartAndEnd( ItemAddress64::SubzoneOffset_t ___3878, ___1842&                           ___1878, ___1842&                           ___1850) const { REQUIRE(___3878 < getNumSzs()); ___1842 const szIJK = szIJKAtSzIndex(___3878); ___1878 = itemIJKStart(szIJK); ___1850 = itemIJKEnd(szIJK); ENSURE(___1878<m_zoneIJKDim); ENSURE(___1850<m_zoneIJKDim); ENSURE(szAddressAtItemIJK(___1878).subzoneOffset() == ___3878);
ENSURE(szAddressAtItemIJK(___1850).subzoneOffset()==___3878); } ___1842 subzoneIJKStart(ItemAddress64::SubzoneOffset_t ___3878) const { REQUIRE(___3878 < getNumSzs()); ___1842 const szIJK = szIJKAtSzIndex(___3878); ___1842 const ___1878 = itemIJKStart(szIJK); ENSURE(___1878<m_zoneIJKDim); ENSURE(szAddressAtItemIJK(___1878).subzoneOffset() == ___3878); return ___1878; } ___1842 subzoneIJKEnd(ItemAddress64::SubzoneOffset_t ___3878) const { REQUIRE(___3878 < getNumSzs()); ___1842 const szIJK = szIJKAtSzIndex(___3878); ___1842 const ___1850 = itemIJKEnd(szIJK); ENSURE(___1850 < m_zoneIJKDim); ENSURE(szAddressAtItemIJK(___1850).subzoneOffset() == ___3878); return ___1850; } ___1842 szIJKAtItemIJK(___1842 const& itemIJK) const { REQUIRE(itemIJK < m_zoneIJKDim); ___1842 const szIJK = (itemIJK+m_subzoneTilingIJKShift) / m_subzoneItemsMaxIJKDim; ENSURE(szIJK < m_subzoneTilingIJKDim); return szIJK; } ItemAddress64::SubzoneAddress szAddressAtItemIJK(___1842 const& itemIJK) const { REQUIRE(itemIJK<m_zoneIJKDim); size_t const section = 0; ___1842 const subzoneIJK = szIJKAtItemIJK(itemIJK); ItemAddress64::SubzoneAddress const szAddress(m_partition, section, static_cast<ItemAddress64::SubzoneOffset_t>(m_subzoneTilingIJKDim.offsetAtIJK(subzoneIJK))); ENSURE(validSzAddress(szAddress)); return szAddress; } ItemAddress64::SubzoneAddress szAddressAtItemIndex(___81 itemIndex) const { REQUIRE(itemIndex<getNumItems()); ___1842 const itemIJK = m_zoneIJKDim.ijkAtOffset(itemIndex); ItemAddress64::SubzoneAddress const szAddress = szAddressAtItemIJK(itemIJK); ENSURE(validSzAddress(szAddress)); return szAddress; } ItemAddress64 itemAddressAtItemIJK( ___1842 const& itemIJK, ___1842 const& szIJK) const { REQUIRE(itemIJK<m_zoneIJKDim); REQUIRE(szIJK<m_subzoneTilingIJKDim); size_t const section = 0; ItemAddress64::SubzoneOffset_t const szOffset = static_cast<ItemAddress64::SubzoneOffset_t>(m_subzoneTilingIJKDim.offsetAtIJK(szIJK)); ___1842 const ___1878 = itemIJKStart(szIJK); ___1842 const ___1850   = itemIJKEnd(szIJK); ___1842 const localMax = ___1850-___1878+1; ___1842 const localIJK = itemIJK-___1878; ___476(localIJK<=localMax); ItemAddress64::ItemOffset_t const itemOffset = ItemAddress64::ItemOffset_t(localMax.offsetAtIJK(localIJK)); ENSURE(itemOffset<localMax.blockSize()); return ItemAddress64(m_partition,section,szOffset,itemOffset); } ___1842 subzoneIJKDim(ItemAddress64::SubzoneOffset_t ___3878) const { REQUIRE(validSubzone(___3878)); ___1842 szIJKStart, szIJKEnd; subzoneIJKStartAndEnd(___3878, szIJKStart, szIJKEnd); ___1842 const szIJKDim = szIJKEnd-szIJKStart+1; return szIJKDim; } ItemAddress64::ItemOffset_t numItemsInSz(ItemAddress64::SubzoneOffset_t ___3878) const { REQUIRE(validSubzone(___3878)); return ItemAddress64::ItemOffset_t(subzoneIJKDim(___3878).blockSize()); } ItemAddress64 itemAddressAtItemIJK(___1842 const& itemIJK) const { REQUIRE(itemIJK<m_zoneIJKDim); ___1842 const szIJK = szIJKAtItemIJK(itemIJK); return itemAddressAtItemIJK(itemIJK, szIJK); } ___1842 itemIJKAtItemAddress(ItemAddress64 ___2087) const { REQUIRE(validItemAddress(___2087));
ItemAddress64::SubzoneOffset_t const ___3878 = ___2087.subzoneOffset(); ___1842 ___1878, ___1850; subzoneIJKStartAndEnd(___3878, ___1878, ___1850); ItemAddress64::ItemOffset_t const ___2863 = ___2087.itemOffset(); ___1842 const ijkRange = ___1850-___1878+1; ___1842 const ___1860 = ijkRange.ijkAtOffset(___2863); ___1842 const itemIJK = ___1878 + ___1860; ENSURE(itemIJK<m_zoneIJKDim); ENSURE(itemAddressAtItemIJK(itemIJK)==___2087); return itemIJK; } inline ItemAddress64 itemAddressAtItemIndex(___81 itemIndex) const { REQUIRE(itemIndex<getNumItems()); ___1842 const itemIJK = itemIJKAtItemIndex(itemIndex); ItemAddress64 const ___2087 = itemAddressAtItemIJK(itemIJK); return ___2087; } inline ___81 itemIndexAtItemAddress(ItemAddress64 ___2087) const { REQUIRE(validItemAddress(___2087)); ___1842 const itemIJK = itemIJKAtItemAddress(___2087); ___81 const itemIndex = itemIndexAtItemIJK(itemIJK); ENSURE(itemIndex<getNumItems()); ENSURE(itemAddressAtItemIndex(itemIndex)==___2087); return itemIndex; } inline ___81 itemIndexAtItemIJK(___1842 const& itemIJK) const { REQUIRE(itemIJK < m_zoneIJKDim); ___81 const itemIndex = m_zoneIJKDim.offsetAtIJK(itemIJK); ENSURE(itemIndex<getNumItems()); return itemIndex; } ___1842 itemIJKAtItemIndex(___81 itemIndex) const { REQUIRE(itemIndex<getNumItems()); ___1842 const itemIJK = m_zoneIJKDim.ijkAtOffset(itemIndex); ENSURE(itemIJK < m_zoneIJKDim); ENSURE(itemIndexAtItemIJK(itemIJK)==itemIndex); return itemIJK; } ItemAddress64::SubzoneOffset_t subzoneOffsetAtItemIndex(___81 itemIndex) const { REQUIRE(itemIndex < getNumItems()); ___1842 const itemIJK = itemIJKAtItemIndex(itemIndex); ___1842 const szIJK = szIJKAtItemIJK(itemIJK); ItemAddress64::SubzoneOffset_t const szOffset = static_cast<ItemAddress64::SubzoneOffset_t>(m_subzoneTilingIJKDim.offsetAtIJK(szIJK)); ENSURE(validSubzone(szOffset)); return szOffset; } ___372 getSubzonesOnIndexPlane( IJKPlanes_e                              whichPlane, ___81                               planeIndex, ___3267<ItemAddress64::SubzoneAddress>& szAddresses) const; ___372 getSubzonesOnIndexLine( IJKLines_e                               whichLine, ___81                               mIndex, ___81                               nIndex, ___3267<ItemAddress64::SubzoneAddress>& szAddresses) const; }; }}
