#include "NonSzZoneVariableWriter.h"
#include "ThirdPartyHeadersBegin.h"
#include <boost/scoped_array.hpp>
#include <stdexcept>
#include "ThirdPartyHeadersEnd.h"
#include "AltTecUtil.h"
#include "FieldData.h"
#include "fileStuff.h"
#include "FileWriterInterface.h"
#include "ItemSetIterator.h"
#include "writeValueArray.h"
namespace tecplot { namespace ___3931 { namespace { char const* CC_FIELD_DATA_MARKER_LABEL = "ccFieldDataMarker*"; char const* NODAL_FIELD_DATA_MARKER_LABEL = "nodalFieldDataMarker*"; char const* VARIABLE_NUM_LABEL = "variableNum*"; char const* FIELD_DATA_LABEL = "FieldData"; } NonSzZoneVariableWriter::NonSzZoneVariableWriter( ItemSetIterator& varIter, ___4633      zone, ___4633      ___341, ___37&      ___36) : m_varIter(varIter) , ___2675(zone) , m_baseZone(___341) , ___2335(___36) , m_zoneNumberLabel(SZPLT_ZONE_NUM_DESCRIPTION) {} uint64_t NonSzZoneVariableWriter::varHeaderSizeInFile(bool ___2000) { if (___2000) return 3 * valueSizeInFile<uint32_t, false>(___2000); return 0; } uint64_t NonSzZoneVariableWriter::varSizeInFile(___4349 ___4333, bool ___2000) const { uint64_t ___3356 = varHeaderSizeInFile(___2000); ___1350 ___1349(&___2335, ___2675 + 1, ___4333 + 1); if (___1349.___2065()) { switch (___1349.getValueType()) { case FieldDataType_Float: ___3356 += arraySizeInFile<float, false>(static_cast<size_t>(___1349.___1781()), ___2000); break; case FieldDataType_Double: ___3356 += arraySizeInFile<double, false>(static_cast<size_t>(___1349.___1781()), ___2000); break; case FieldDataType_Int32: ___3356 += arraySizeInFile<int32_t, false>(static_cast<size_t>(___1349.___1781()), ___2000); break; case FieldDataType_Int16: ___3356 += arraySizeInFile<int16_t, false>(static_cast<size_t>(___1349.___1781()), ___2000); break; case FieldDataType_Byte: ___3356 += arraySizeInFile<uint8_t, false>(static_cast<size_t>(___1349.___1781()), ___2000); break; case ___1363: ___3356 += arraySizeInFile<uint8_t, false>(static_cast<size_t>(numBytesForNumBits(___1349.___1781())), ___2000); break; default: throw std::runtime_error("Unsupported variable type."); break; } } return ___3356; } ___372 NonSzZoneVariableWriter::writeVarHeader( FileWriterInterface& file, ValueLocation_e      ___4323, ___4349           ___4333) { ___372 ___2037 = ___4224; REQUIRE(file.___2039()); REQUIRE(___4323 == ___4325 || ___4323 == ___4327); if (file.___2000()) { if ( ___4323 == ___4325 ) ___2037 = ___2037 && writeValue<uint32_t, false, 0>(file, CC_FIELD_DATA_MARKER_LABEL, SZPLT_CC_FIELD_DATA_MARKER); else ___2037 = ___2037 && writeValue<uint32_t, false, 0>(file, NODAL_FIELD_DATA_MARKER_LABEL, SZPLT_NODAL_FIELD_DATA_MARKER); ___2037 = ___2037 && writeValue<uint32_t, false, 0>(file, VARIABLE_NUM_LABEL, (___4333 - m_varIter.baseItem() + 1)); ___2037 = ___2037 && writeValue<uint32_t, false, 0>(file, m_zoneNumberLabel.c_str(), (___2675 - m_baseZone + 1)); } ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } namespace { template <typename T, bool isBitArray> ___372 writeFieldData( FileWriterInterface& szpltFile, ___1350 const&     ___1349) { ___372 ___2037 = ___4224; size_t ___4322 = static_cast<size_t>(___1349.___1781()); void* rawPointer = ___1349.getRawPointer();
if (rawPointer) { ___2037 = ___4560<T, false, 0>(szpltFile, FIELD_DATA_LABEL, ___2743, ___4322, (T*)rawPointer); } else { boost::scoped_array<T> array; array.reset(new T[___4322]); if (___2037) { for (size_t i = 0; i < ___4322; ++i) { double ___4296 = ___1349.___1778(static_cast<___2225>(i) + 1); array[i] = static_cast<T>(___4296); } ___2037 = ___2037 && ___4560<T, false, 0>(szpltFile, FIELD_DATA_LABEL, ___2743, ___4322, array.get()); } } ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } template <> ___372 writeFieldData<uint8_t, true>( FileWriterInterface& szpltFile, ___1350 const&     ___1349) { REQUIRE(___1349.getValueType() == ___1363); ___372 ___2037 = ___4224; ___1350 tempFieldData; size_t ___4322 = static_cast<size_t>(___1349.___1781()); size_t ___2777 = numBytesForNumBits(___4322); void* rawPointer = ___1349.getRawPointer(); if (!rawPointer) { tempFieldData.allocate(___1349.getValueType(), ___1349.___1784(), ___1349.___1781()); rawPointer = tempFieldData.getRawPointer(); if (rawPointer == NULL) throw std::bad_alloc(); for (___2225 i = 1; i <= ___1349.___1781(); ++i) tempFieldData.___3502(i, ___1349.___1778(i)); } ___2037 = ___2037 && ___4560<uint8_t, false, 0>(szpltFile, FIELD_DATA_LABEL, ___2743, ___2777, (uint8_t*)rawPointer); ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } } ___372 NonSzZoneVariableWriter::writeVar( FileWriterInterface& szpltFile, ___1350 const&     ___1349) { ___372 ___2037 = ___4224; switch (___1349.getValueType()) { case FieldDataType_Float: ___2037 = writeFieldData<float, false>(szpltFile, ___1349); break; case FieldDataType_Double: ___2037 = writeFieldData<double, false>(szpltFile, ___1349); break; case FieldDataType_Int32: ___2037 = writeFieldData<int32_t, false>(szpltFile, ___1349); break; case FieldDataType_Int16: ___2037 = writeFieldData<int16_t, false>(szpltFile, ___1349); break; case FieldDataType_Byte: ___2037 = writeFieldData<uint8_t, false>(szpltFile, ___1349); break; case ___1363: ___2037 = writeFieldData<uint8_t, true>(szpltFile, ___1349); break; default: throw std::runtime_error("Unsupported variable type."); break; } ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } }}
