 #pragma once
#include "ThirdPartyHeadersBegin.h"
#include <exception>
#include <string>
#include <boost/unordered_set.hpp>
#include "ThirdPartyHeadersEnd.h"
#include "ThirdPartyHeadersBegin.h"
#include <boost/array.hpp>
#include "ThirdPartyHeadersEnd.h"
#include "SzlFileLoader.h"
#include "NodeMap.h"
#include "FEZoneInfo.h"
#include "ClassMacros.h"
namespace tecplot { namespace ___3931 { static uint16_t const MAX_ENTRIES_FOR_2_BIT_COMPRESSION = 4; static uint16_t const MAX_ENTRIES_FOR_4_BIT_COMPRESSION = 16; static uint16_t const MAX_ENTRIES_FOR_8_BIT_COMPRESSION = 256; class ___1337 { UNCOPYABLE_CLASS(___1337); public: static uint16_t const MAX_NUM_ENTRIES_IN_SUBZONE = (ItemAddress64::MAX_ITEM_OFFSET+1)*MAX_NODES_PER_ELEM; static uint16_t const MAX_REFERENCED_NODE_SUBZONES = MAX_NUM_ENTRIES_IN_SUBZONE; class Error : public std::exception { public: explicit Error(std::string const& what) : m_what(what) {} ~Error() throw() {}; char const* what() const throw() { return m_what.c_str(); } private: std::string m_what; }; ___1337(); ~___1337(); template <typename NODE_TYPE> void ___534( ___2727                     ___2721, ___1348 const&              ___1347, ItemAddress64::SectionOffset_t section, ItemAddress64::SubzoneOffset_t ___467); ItemAddress64::ItemOffset_t ___2780() const; uint16_t numRefNszs() const; uint16_t numRefPartitions() const; ItemAddress64::SubzoneAddress const* refPtnNszs() const; size_t refPtnOffsetsNumBytes() const; uint8_t const* refPtn2BitOffsets() const; uint8_t const* refPtn4BitOffsets() const; uint8_t const* refPtn8BitOffsets() const; uint16_t const* refPtn16BitOffsets() const; uint32_t const* ___3317() const; size_t refNszOffsetsNumBytes() const; uint8_t const* refNsz2BitOffsets() const; uint8_t const* ___3319() const; uint8_t const* ___3320() const; uint16_t const* ___3318() const; uint8_t const* ___2762() const; private: ItemAddress64::ItemOffset_t m_numCellsInSubzone; boost::array<uint32_t, MAX_NUM_ENTRIES_IN_SUBZONE> m_refPtnArray; size_t                                                  m_refPtnOffsetsNumBytes; boost::array<uint8_t, (MAX_NUM_ENTRIES_IN_SUBZONE+1)/4> m_refPtn2BitOffsets; boost::array<uint8_t, (MAX_NUM_ENTRIES_IN_SUBZONE+1)/2> m_refPtn4BitOffsets; boost::array<uint8_t,  MAX_NUM_ENTRIES_IN_SUBZONE>      m_refPtn8BitOffsets; boost::array<uint16_t, MAX_NUM_ENTRIES_IN_SUBZONE>      m_refPtn16BitOffsets; uint16_t m_numRefNszs; boost::array<ItemAddress64,MAX_NUM_ENTRIES_IN_SUBZONE>                    m_szCoordinateArray; boost::array<ItemAddress64::SubzoneOffset_t,MAX_REFERENCED_NODE_SUBZONES> m_refNszArray; size_t                                                  m_refNszOffsetsNumBytes; boost::array<uint8_t,(MAX_NUM_ENTRIES_IN_SUBZONE+1)/4>  m_refNsz2BitOffsets; boost::array<uint8_t,(MAX_NUM_ENTRIES_IN_SUBZONE+1)/2>  m_refNsz4BitOffsets; boost::array<uint8_t,MAX_NUM_ENTRIES_IN_SUBZONE>        m_refNsz8BitOffsets; boost::array<uint16_t,MAX_NUM_ENTRIES_IN_SUBZONE>       m_refNsz16BitOffsets; boost::array<uint8_t,MAX_NUM_ENTRIES_IN_SUBZONE>        m_nszOffsets; uint16_t m_numRefPartitions; boost::array<ItemAddress64::SubzoneAddress, MAX_NUM_ENTRIES_IN_SUBZONE> m_ptnNszReferences; SubzoneAddressSet m_refPtnNszSet; boost::array<ItemAddress64::SubzoneAddress, MAX_NUM_ENTRIES_IN_SUBZONE> m_refPtnNszArray;
}; }}
