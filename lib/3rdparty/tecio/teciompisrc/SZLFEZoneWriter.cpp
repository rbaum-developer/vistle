#include "SZLFEZoneWriter.h"
#include "ThirdPartyHeadersBegin.h"
#include <utility>
#include <boost/assign.hpp>
#include <boost/bind/bind.hpp>
#include <boost/function.hpp>
#include <boost/make_shared.hpp>
#include <boost/unordered_set.hpp>
#include "ThirdPartyHeadersEnd.h"
 #if !defined TECIOMPI
#include "AtomicMinMax.h"
 #endif
#include "BitArray.h"
#include "checkPercentDone.h"
#include "FECellSubzoneCompressor.h"
#include "FieldData.h"
#include "gatherOffsets.h"
#include "IJKZoneInfo.h"
#include "ItemSetIterator.h"
#include "NodeMap.h"
#include "writeValueArray.h"
 #define MINMAX_MAX_TASKS_PER_CORE 2 
 #define MINMAX_MIN_CSZ_TASK_SIZE 16 
 #define MINMAX_MIN_NODE_TASK_SIZE 16 
 #define FEWRITER_MIN_CSZS_PER_CHUNK 1000 
 #define FEWRITER_MAX_CSZS_PER_CHUNK 1000 
namespace tecplot { namespace ___3931 { SZLFEZoneWriter::SZLFEZoneWriter( uint32_t                                   fileVersion, ItemSetIterator&                           varIter, ___4633                                zone, ___4633                                ___341, std::vector<___372> const&              ___4561, ___372                                  ___4496, ___37&                                ___36, boost::shared_ptr<___1348 const> const& zoneInfo) : ___4706(fileVersion, varIter, zone, ___341, ___4561, ___4496, ___36) , m_headerWriter(fileVersion, varIter, zone, ___341, ___36, *zoneInfo, (___4496 == ___4224), ___2671, m_secCszConnectivityFileLocs, m_nszConnectivityFileLocs, m_secNumCszs, m_secNumRefNodeSubzones, m_numRefCellSubzones, m_secCszIncludesPartitionOffsetsBitArray, m_nszIncludesPartitionOffsetsBitArray) , m_feZoneInfo(zoneInfo) , m_zoneNumberLabel(SZPLT_ZONE_NUM_DESCRIPTION) { ___4349 const numVarsToWrite = m_varIter.___2810(); if (!___2671.alloc(numVarsToWrite, ___330)) { std::ostringstream ___2890; ___2890 << "Unable to allocate arrays for outputting zone " << zone; throw std::runtime_error(___2890.str()); } } SZLFEZoneWriter::~SZLFEZoneWriter() {} void SZLFEZoneWriter::setZoneNumberLabel(std::string const& zoneNumberLabel) { REQUIRE(!zoneNumberLabel.empty()); m_zoneNumberLabel = zoneNumberLabel; } namespace { template <typename NODE_TYPE> void calculateAndApplyCellMinMaxesUsingNodesOfType( ItemAddress64::SectionOffset_t                                           section, std::pair<ItemAddress64::SubzoneOffset_t,ItemAddress64::SubzoneOffset_t> cellSubzoneRange, ___1348 const&                                                        ___1347, ___2722 const&                                                           ___2721, ___1350 const&                                                         nlFieldData, ___1350 const&                                                         ccFieldData,
 #if defined TECIOMPI
___2479&                                                         cszMinMaxArray, ___2479&                                                         ___2760
 #else
___2238<___225<double> >&                            cszMinMaxArray, ___2238<___225<double> >&                            ___2760
 #endif
) { REQUIRE(___2721.___2065()); REQUIRE(nlFieldData.___2065()); int32_t const numNodesPerCell = ___1347.getNumNodesPerCell(section); boost::array<NODE_TYPE,MAX_NODES_PER_ELEM> elemNodes; ___81 const baseCell = ccFieldData.___2065() ? ___1347.baseCellAtSection(section) : 0; for (ItemAddress64::SubzoneOffset_t ___467 = cellSubzoneRange.first; ___467 < cellSubzoneRange.second; ++___467) { ItemAddress64::ItemOffset_t const ___2780 = ___1347.___2780(section, ___467); for (ItemAddress64::ItemOffset_t cszOffset = 0; cszOffset < ___2780; cszOffset++) { ItemAddress64 const ___686(ItemAddress64::UNKNOWN_PARTITION, section, ___467, cszOffset); ___463 const zoneCell = ___1347.cellAtItemAddress(___686); ___2721.getElemNodes<NODE_TYPE>(section+1, zoneCell+1, 1, elemNodes.data()); ___2477 cellMinMax; for (int32_t nOffset = 0; nOffset < numNodesPerCell; ++nOffset) cellMinMax.include(nlFieldData.___1778(elemNodes[nOffset])); for (int32_t nOffset = 0; nOffset < numNodesPerCell; ++nOffset) { ItemAddress64 const& ___2757 = ___1347.itemAddressAtNode(elemNodes[nOffset]-1); ItemAddress64::___2978 const ___2975 = ___2757.___2975(); if (___2975 == ___1347.getPartition()) { ItemAddress64::SubzoneOffset_t const ___2732 = ___2757.subzoneOffset(); ___2760[___2732].include(cellMinMax); } } if ( ccFieldData.___2065() ) cellMinMax.include(ccFieldData.___1778(baseCell + zoneCell + 1)); cszMinMaxArray[___467].include(cellMinMax); } } } } namespace { void calculateAndApplyCellMinMaxes( ItemAddress64::SectionOffset_t                                           section, std::pair<ItemAddress64::SubzoneOffset_t,ItemAddress64::SubzoneOffset_t> cellSubzoneRange, ___1348 const&                                                        ___1347, ___2722 const&                                                           ___2721, ___1350 const&                                                         nlFieldData, ___1350 const&                                                         ccFieldData,
 #if defined TECIOMPI
___2479&                                                         cszMinMaxArray, ___2479&                                                         ___2760
 #else
___2238<___225<double> >&                            cszMinMaxArray, ___2238<___225<double> >&                            ___2760
 #endif
) { if (___2721.getOffsetDataType() == OffsetDataType_32Bit) calculateAndApplyCellMinMaxesUsingNodesOfType<int32_t>( section, cellSubzoneRange, ___1347, ___2721, nlFieldData, ccFieldData, cszMinMaxArray, ___2760); else calculateAndApplyCellMinMaxesUsingNodesOfType<int64_t>( section, cellSubzoneRange, ___1347, ___2721, nlFieldData, ccFieldData, cszMinMaxArray, ___2760); } } namespace {
 #if !defined TECIOMPI
void applyNodalValuesToNodeSubzoneMinMaxes( ___2716 nodeStart, ___2716 nodeEnd, ___1350 const& ___1349, ___1348 const& ___1347, boost::unordered_set<___2716> const& ghostNodeSet,
 #if defined TECIOMPI
___2479& ___2760
 #else
___2238<___225<double> >& ___2760
 #endif
) { REQUIRE(___1349.___2065()); for (___2716 ___4653 = nodeStart; ___4653 < nodeEnd; ++___4653) { if (ghostNodeSet.find(___4653) == ghostNodeSet.end()) { double const ___4296 = ___1349.___1778(___4653 + 1); ItemAddress64 const& ___2757 = ___1347.itemAddressAtNode(___4653); ___476 (___2757.___2975() == ___1347.getPartition()); ItemAddress64::SubzoneOffset_t const ___2755 = ___2757.subzoneOffset(); ___2760[___2755].include(___4296); } } } typedef boost::function<void(void)> VoidFunction; void threadPoolJob(___90 ___2121) { VoidFunction* voidFunction = reinterpret_cast<VoidFunction*>(___2121); (*voidFunction)(); delete voidFunction; } ___372 calculateAndApplyCellMinMaxesMultithreaded( ___37&                     ___36, ___1348 const&               ___1347, ___4633                     zone, ___2722&                        ___2721, ___1350 const&                nlFieldData, ___1350 const&                ccFieldData, ___2238<___2479>& secCszMinMaxArray, ___2479&                    ___2760) { ___2238<___2238<___225<double> > > atomicSecCszMinMaxArray; ___2238<___225<double> > atomicNszMinMaxArray; ItemAddress64::SubzoneOffset_t const ___2821 = ___1347.___2821(); ___372 ___2037 = atomicNszMinMaxArray.alloc(___2821); ___2037 = ___2037 && atomicSecCszMinMaxArray.alloc(___1347.getNumSections()); for (ItemAddress64::SectionOffset_t section = 0; ___2037 && section < ___1347.getNumSections(); ++section) ___2037 = atomicSecCszMinMaxArray[section].alloc(___1347.numCszsInSection(section)); if (___2037) { size_t const maxNumTasks = static_cast<size_t>(___36.___4155() * MINMAX_MAX_TASKS_PER_CORE); ___2118 ___2117 = ___36.___4156(); for (ItemAddress64::SectionOffset_t section = 0; section < ___1347.getNumSections(); ++section) { ItemAddress64::SubzoneOffset_t const ___2781 = ___1347.numCszsInSection(section); size_t const numCszTasksAtMinJobSize = static_cast<size_t>(___2781 + MINMAX_MIN_CSZ_TASK_SIZE - 1) / MINMAX_MIN_CSZ_TASK_SIZE; size_t const numCszTasks = std::min(numCszTasksAtMinJobSize, maxNumTasks); ItemAddress64::SubzoneOffset_t cellSubzoneStart = 0; for (size_t task = 1; task <= numCszTasks; ++task) { ItemAddress64::SubzoneOffset_t const cellSubzoneEnd = static_cast<ItemAddress64::SubzoneOffset_t>(___2781 * task / numCszTasks); ___476(cellSubzoneStart < cellSubzoneEnd); VoidFunction* voidFunction = new VoidFunction(boost::bind( &calculateAndApplyCellMinMaxes, section, std::make_pair(cellSubzoneStart,cellSubzoneEnd), boost::ref(___1347), boost::ref(___2721), boost::ref(nlFieldData), boost::ref(ccFieldData), boost::ref(atomicSecCszMinMaxArray[section]), boost::ref(atomicNszMinMaxArray))); ___36.___4154(threadPoolJob, (___90)voidFunction, ___2117); cellSubzoneStart = cellSubzoneEnd; } } ___2716 const ___2819 = ___1347.___1766();
size_t const numNodesTasksAtMinJobSize = static_cast<size_t>(___2819 + MINMAX_MIN_NODE_TASK_SIZE - 1) / MINMAX_MIN_NODE_TASK_SIZE; size_t const numNodeTasks = std::min(numNodesTasksAtMinJobSize, maxNumTasks); boost::unordered_set<___2716> ghostNodeSet; GhostInfo_pa ghostNodeInfo = ___36.zoneGhostNodeInfoGetRef(zone + 1); if (ghostNodeInfo) { for (___81 i = 0; i < ___36.ghostInfoGetNumItemsByRef(ghostNodeInfo,1 ); ++i) ghostNodeSet.insert(static_cast<___2716>(___36.ghostInfoGetItemByRef(ghostNodeInfo,1 ,i+1) - 1)); } ___2716 nodeStart = 0; for (size_t task = 1; task <= numNodeTasks; ++task) { ___2716 const nodeEnd = static_cast<___2716>(___2819 * task / numNodeTasks); ___476(nodeStart < nodeEnd); VoidFunction *voidFunction = new VoidFunction(boost::bind( applyNodalValuesToNodeSubzoneMinMaxes, nodeStart, nodeEnd, nlFieldData, boost::ref(___1347), boost::ref(ghostNodeSet), boost::ref(atomicNszMinMaxArray))); ___36.___4154(threadPoolJob, (___90)voidFunction, ___2117); nodeStart = nodeEnd; } ___36.___4159(___2117); ___36.___4157(&___2117); if (___2037) { for (ItemAddress64::SectionOffset_t section = 0; section < ___1347.getNumSections(); ++section) { ItemAddress64::SubzoneOffset_t const ___2781 = ___1347.numCszsInSection(section); for (ItemAddress64::SubzoneOffset_t ___467 = 0; ___467 < ___2781; ++___467) { ___476(atomicSecCszMinMaxArray[section][___467].___2065()); secCszMinMaxArray[section][___467].include(atomicSecCszMinMaxArray[section][___467].minValue()); secCszMinMaxArray[section][___467].include(atomicSecCszMinMaxArray[section][___467].maxValue()); } } atomicSecCszMinMaxArray.___935(); for (ItemAddress64::SubzoneOffset_t ___2732 = 0; ___2037 && ___2732 < ___2821; ++___2732) { ___476(atomicNszMinMaxArray[___2732].___2065()); ___2760[___2732].include(atomicNszMinMaxArray[___2732].minValue()); ___2760[___2732].include(atomicNszMinMaxArray[___2732].maxValue()); } atomicNszMinMaxArray.___935(); } } ENSURE(VALID_BOOLEAN(___2037)); return ___2037; }
 #endif 
___372 ___1665( ___37&                     ___36, ___1348 const&               ___1347, ___4633                     zone, ___4349                      fileVar, ___1350 const&                nlFieldData, ___1350 const&                ccFieldData, ___2238<___2479>& secCszMinMaxArray, ___2479&                    ___2760) { REQUIRE(zone >= 0); REQUIRE(fileVar >= 0); REQUIRE(nlFieldData.___2065()); REQUIRE("ccFieldData might be invalid if not CC data"); ___372 ___2037 = ___4224; ___2727 ___2721 = boost::make_shared<___2722>(&___36, zone + 1); if (!___2721->___2065()) ___2037 = ___1303; if (___2037) {
 #ifndef NO_ASSERTS
ItemAddress64::SubzoneOffset_t const ___2821 = ___1347.___2821(); for (ItemAddress64::SubzoneOffset_t ___2732 = 0; ___2732 < ___2821; ___2732++) ___476(!___2760[___2732].___2065()); for (ItemAddress64::SectionOffset_t section = 0; section < ___1347.getNumSections(); ++section) for (ItemAddress64::SubzoneOffset_t ___467 = 0; ___467 < ___1347.numCszsInSection(section); ___467++) ___476(!secCszMinMaxArray[section][___467].___2065());
 #endif
___1348::NszMinMaxMap const& nszMinMaxes = ___1347.getNszMinMaxes(); for (___1348::NszMinMaxMap::const_iterator valuePair = nszMinMaxes.begin(); valuePair != nszMinMaxes.end(); ++valuePair) { ___2760[valuePair->first].include(valuePair->second[fileVar]); }
 #if defined TECIOMPI
for (ItemAddress64::SectionOffset_t section = 0; section < ___1347.getNumSections(); ++section) calculateAndApplyCellMinMaxes( section, std::make_pair(0,___1347.numCszsInSection(section)), ___1347, *___2721, nlFieldData, ccFieldData, secCszMinMaxArray[section], ___2760);
 #else
___2037 = calculateAndApplyCellMinMaxesMultithreaded( ___36, ___1347, zone, *___2721, nlFieldData, ccFieldData, secCszMinMaxArray, ___2760);
 #endif
} ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } } ___372 SZLFEZoneWriter::calculateVarSubzoneMinMaxes( ___4349                      datasetVar, ___2479&                    ___2760, ___2238<___2479>& secCszMinMaxArray) { REQUIRE(secCszMinMaxArray.empty()); REQUIRE(___2760.empty()); REQUIRE(m_writeVariables[datasetVar - m_varIter.baseItem()]); ___372 ___2037 = ___4224; ___2037 = ___2037 && ___2760.alloc(m_feZoneInfo->___2821(), ___2477()); ___2037 = ___2037 && secCszMinMaxArray.alloc(m_feZoneInfo->getNumSections()); for (ItemAddress64::SectionOffset_t section = 0; ___2037 && section < m_feZoneInfo->getNumSections(); ++section) ___2037 = secCszMinMaxArray[section].alloc(m_feZoneInfo->numCszsInSection(section), ___2477()); if (___2037) { if (___2335.___908(___2675 + 1, datasetVar + 1) == ___4327) { ___1350 nlFieldData(&___2335, ___2675 + 1, datasetVar + 1, false , false/*___962*/); ___1350 ccFieldData; ___2037 = nlFieldData.___2065() && ___1665(___2335, *m_feZoneInfo, ___2675, datasetVar - m_varIter.baseItem(), nlFieldData, ccFieldData, secCszMinMaxArray, ___2760); } else { ___1350 nlFieldData(&___2335, ___2675 + 1, datasetVar + 1, false , true/*___962*/); ___1350 ccFieldData(&___2335, ___2675 + 1, datasetVar + 1, false , false/*___962*/); ___2037 = nlFieldData.___2065() && ccFieldData.___2065() && ___1665(___2335, *m_feZoneInfo, ___2675, datasetVar - m_varIter.baseItem(), nlFieldData, ccFieldData, secCszMinMaxArray, ___2760); } } return ___2037; } ___372 SZLFEZoneWriter::___4498( FileWriterInterface&           file, ItemAddress64::SubzoneOffset_t ___467) { ___372 ___2037 = ___4224; REQUIRE(file.___2039()); if (file.___2000()) { ___2037 = writeValue<uint32_t, false, 0>(file, "cszConnectivityMarker*", SZPLT_CSZ_CONNECTIVITY_MARKER) && writeValue<uint32_t, false, 0>(file, m_zoneNumberLabel.c_str(), (___2675 - m_baseZone + 1)) && writeValue<uint64_t, false, 0>(file, "subzoneNum*", ___467 + 1); } ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } uint64_t SZLFEZoneWriter::cszConnectivityHeaderFileSize(bool ___2000) { uint64_t ___3356 = 0; if (___2000) { ___3356 += 2 * valueSizeInFile<uint32_t, false>(___2000) + valueSizeInFile<uint64_t, false>(___2000); } return ___3356; } ___372 SZLFEZoneWriter::___4497( FileWriterInterface&             file, ItemAddress64::SectionOffset_t   section, ___1337 const&   compressor, bool                             outputPartitionIndices) { REQUIRE(file.___2039()); ___372 ___2037 = ___4224; if (outputPartitionIndices) { if (compressor.numRefPartitions() <= MAX_REFS_FOR_2_BIT_COMPRESSION) { uint8_t const* refPtn2BitOffsets = compressor.refPtn2BitOffsets(); ___2037 = ___2037 && ___4560<uint8_t, true, 0>(file, "refPtn2BitOffsets", ___2743, compressor.refPtnOffsetsNumBytes(), refPtn2BitOffsets, ___944 / 4); } else if (compressor.numRefPartitions() <= MAX_REFS_FOR_4_BIT_COMPRESSION)
{ uint8_t const* refPtn4BitOffsets = compressor.refPtn4BitOffsets(); ___2037 = ___2037 && ___4560<uint8_t, true, 0>(file, "refPtn4BitOffsets", ___2743, compressor.refPtnOffsetsNumBytes(), refPtn4BitOffsets, ___944 / 2); } else if (compressor.numRefPartitions() <= MAX_REFS_FOR_8_BIT_COMPRESSION) { uint8_t const* refPtn8BitOffsets = compressor.refPtn8BitOffsets(); ___2037 = ___2037 && ___4560<uint8_t, true, 0>(file, "refPtn8BitOffsets", ___2743, compressor.refPtnOffsetsNumBytes(), refPtn8BitOffsets); } else { ___476(compressor.refPtnOffsetsNumBytes() == 0); uint16_t const* refPtn16BitOffsets = compressor.refPtn16BitOffsets(); ___2037 = ___2037 && ___4560<uint16_t, true, 0>(file, "refPtn16BitOffsets", ___2743, compressor.numRefNszs(), refPtn16BitOffsets); } } ___2037 = ___2037 && ___4560<uint32_t, false, 1>(file, CSZ_CONNECT_REF_NSZ_ARRAY_DESCRIPTION, ___2743, compressor.numRefNszs(), &compressor.___3317()[0]); size_t ___2793 = static_cast<size_t>(compressor.___2780() * m_feZoneInfo->getNumNodesPerCell(section)); if (compressor.numRefNszs() <= MAX_REFS_FOR_2_BIT_COMPRESSION) { uint8_t const* refNsz2BitOffsets = compressor.refNsz2BitOffsets(); ___2037 = ___2037 && ___4560<uint8_t, true, 0>(file, CSZ_CONNECT_REF_NSZ_OFFSET_2BIT_ARRAY_DESCRIPTION, ___2743, compressor.refNszOffsetsNumBytes(), refNsz2BitOffsets, m_feZoneInfo->getNumNodesPerCell(section)/4); } else if (compressor.numRefNszs() <= MAX_REFS_FOR_4_BIT_COMPRESSION) { uint8_t const* ___3319 = compressor.___3319(); ___2037 = ___2037 && ___4560<uint8_t, true, 0>(file, CSZ_CONNECT_REF_NSZ_OFFSET_4BIT_ARRAY_DESCRIPTION, ___2743, compressor.refNszOffsetsNumBytes(), ___3319, m_feZoneInfo->getNumNodesPerCell(section)/2); } else if (compressor.numRefNszs() <= MAX_REFS_FOR_8_BIT_COMPRESSION) { uint8_t const* ___3320 = compressor.___3320(); ___2037 = ___2037 && ___4560<uint8_t, true, 0>(file, CSZ_CONNECT_REF_NSZ_OFFSET_8BIT_ARRAY_DESCRIPTION, ___2743, compressor.refNszOffsetsNumBytes(), ___3320, m_feZoneInfo->getNumNodesPerCell(section)); } else { ___476(compressor.refNszOffsetsNumBytes() == 0); uint16_t const* ___3318 = compressor.___3318(); ___2037 = ___2037 && ___4560<uint16_t, true, 0>(file, CSZ_CONNECT_REF_NSZ_OFFSET_16BIT_ARRAY_DESCRIPTION, ___2743, ___2793, ___3318, m_feZoneInfo->getNumNodesPerCell(section)); } uint8_t const* ___2762 = compressor.___2762(); ___2037 = ___2037 && ___4560<uint8_t, false, 0>(file, CSZ_CONNECT_NSZ_OFFSET_ARRAY_DESCRIPTION, ___2743, ___2793, ___2762, m_feZoneInfo->getNumNodesPerCell(section)); ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } uint64_t SZLFEZoneWriter::cszConnectivityDataFileSize( bool ___2000, size_t totalNumCellNodes, size_t numRefNszs, ItemAddress64::___2978 numRefPartitions, bool outputPartitionIndices) { uint64_t ___3356 = 0; if (outputPartitionIndices)
{ if (numRefPartitions <= MAX_REFS_FOR_2_BIT_COMPRESSION) ___3356 += arraySizeInFile<uint8_t, true  >( BitArray<uint16_t,2>::byteArraySize(numRefNszs), ___2000); else if (numRefPartitions <= MAX_REFS_FOR_4_BIT_COMPRESSION) ___3356 += arraySizeInFile<uint8_t, true  >( BitArray<uint16_t,4>::byteArraySize(numRefNszs), ___2000); else if (numRefPartitions <= MAX_REFS_FOR_8_BIT_COMPRESSION) ___3356 += arraySizeInFile<uint8_t, true  >( BitArray<uint16_t,8>::byteArraySize(numRefNszs), ___2000); else ___3356 += arraySizeInFile<uint16_t, true  >(numRefNszs, ___2000); } ___3356 += arraySizeInFile<uint32_t, false>(numRefNszs, ___2000); if (numRefNszs <= MAX_REFS_FOR_2_BIT_COMPRESSION) ___3356 += arraySizeInFile<uint8_t, true  >( BitArray<uint16_t,2>::byteArraySize(totalNumCellNodes), ___2000); else if (numRefNszs <= MAX_REFS_FOR_4_BIT_COMPRESSION) ___3356 += arraySizeInFile<uint8_t, true  >( BitArray<uint16_t,4>::byteArraySize(totalNumCellNodes), ___2000); else if (numRefNszs <= MAX_REFS_FOR_8_BIT_COMPRESSION) ___3356 += arraySizeInFile<uint8_t, true  >( BitArray<uint16_t,8>::byteArraySize(totalNumCellNodes), ___2000); else ___3356 += arraySizeInFile<uint16_t, true  >(totalNumCellNodes, ___2000); ___3356 += arraySizeInFile<uint8_t, false>(totalNumCellNodes, ___2000); return ___3356; } struct CompressSubzoneJobData { ___2238<___1337>* m_compressorVector; ___2727 ___2495; ___1348 const* m_feZoneInfo; ItemAddress64::SectionOffset_t m_section; ItemAddress64::SubzoneOffset_t m_compressorBegin; ItemAddress64::SubzoneOffset_t m_subzoneBegin; ItemAddress64::SubzoneOffset_t m_subzoneCount; }; template <typename NODE_TYPE> void compressSubzoneJob(___90 ___2121) { CompressSubzoneJobData* compressSubzoneJobData = reinterpret_cast<CompressSubzoneJobData*>(___2121); ___2238<___1337>& compressorVector = *compressSubzoneJobData->m_compressorVector; ___2727 ___2721 = compressSubzoneJobData->___2495; ___1348 const& ___1347 = *compressSubzoneJobData->m_feZoneInfo; ItemAddress64::SectionOffset_t const section = compressSubzoneJobData->m_section; ItemAddress64::SubzoneOffset_t const compressorBegin = compressSubzoneJobData->m_compressorBegin; ItemAddress64::SubzoneOffset_t const subzoneBegin = compressSubzoneJobData->m_subzoneBegin; ItemAddress64::SubzoneOffset_t const subzoneCount = compressSubzoneJobData->m_subzoneCount; for (ItemAddress64::SubzoneOffset_t i = 0; i < subzoneCount; ++i) { ItemAddress64::SubzoneOffset_t const whichCompressor = compressorBegin + i; ItemAddress64::SubzoneOffset_t const ___3878 = subzoneBegin + i; ___1337& feCellSubzoneCompressor = compressorVector[whichCompressor]; feCellSubzoneCompressor.___534<NODE_TYPE>(___2721, ___1347, section, ___3878); } } ___372 SZLFEZoneWriter::writeCszConnectivity( FileWriterInterface&    szpltFile, ___2727              ___2721, SubzoneAddressSetArray& nszRefPtnCszSets) { REQUIRE(szpltFile.___2039()); REQUIRE(___2721->___2065()); REQUIRE(nszRefPtnCszSets.size() == size_t(m_feZoneInfo->___2821()));
___372 ___2037 = ___4224; ___2118 ___2117 = ___2335.___4156();
 #if defined OUTPUT_TIMES
uint64_t compressTime = 0; uint64_t ___4546 = 0; uint64_t ___3685 = ___715();
 #endif
for (ItemAddress64::SectionOffset_t section = 0; section < m_feZoneInfo->getNumSections(); ++section) { size_t const ___2781 = checked_numeric_cast<size_t>(m_feZoneInfo->numCszsInSection(section)); if (___2781 == 0) continue; size_t const ___2825 = size_t(___2335.___4155()); size_t const numChunks = 1 + (___2781-1)/FEWRITER_MIN_CSZS_PER_CHUNK; size_t const numTasks = std::min(___2825, numChunks); size_t const subzonesPerTask = std::min<size_t>(static_cast<size_t>(FEWRITER_MAX_CSZS_PER_CHUNK), 1 + (___2781-1)/numTasks); size_t const subzonesPerChunk = numTasks * subzonesPerTask; ___2238<CompressSubzoneJobData> compressSubzoneJobDataVector; if (!compressSubzoneJobDataVector.alloc(numTasks)) throw std::bad_alloc(); for (size_t task = 0; task < numTasks; ++task) { compressSubzoneJobDataVector[task].___2495 = ___2721; compressSubzoneJobDataVector[task].m_feZoneInfo = m_feZoneInfo.get(); } ___2238<___1337> compressorVector; if (!compressorVector.alloc(subzonesPerChunk)) throw std::bad_alloc(); for (size_t chunkSubzoneBegin = 0; ___2037 && chunkSubzoneBegin < ___2781; chunkSubzoneBegin += subzonesPerChunk) { size_t const chunkSubzoneEnd = std::min(chunkSubzoneBegin + subzonesPerChunk, static_cast<size_t>(___2781)); size_t const numCszsThisChunk = chunkSubzoneEnd-chunkSubzoneBegin; size_t const subzonesPerTaskThisChunk = 1 + (numCszsThisChunk-1)/numTasks; size_t const numTasksThisChunk = 1 + (numCszsThisChunk-1)/subzonesPerTaskThisChunk; for(size_t task = 0; task < numTasksThisChunk; ++task) { size_t const threadSubzoneBegin = chunkSubzoneBegin + task * subzonesPerTaskThisChunk; size_t const threadSubzoneEnd = std::min(threadSubzoneBegin + subzonesPerTaskThisChunk, static_cast<size_t>(___2781)); CompressSubzoneJobData* compressSubzoneJobData = &compressSubzoneJobDataVector[task]; compressSubzoneJobData->m_compressorVector = &compressorVector; compressSubzoneJobData->m_section = section; compressSubzoneJobData->m_subzoneBegin = ItemAddress64::SubzoneOffset_t(threadSubzoneBegin); compressSubzoneJobData->m_subzoneCount = ItemAddress64::SubzoneOffset_t(threadSubzoneEnd - threadSubzoneBegin); compressSubzoneJobData->m_compressorBegin = ItemAddress64::SubzoneOffset_t(threadSubzoneBegin - chunkSubzoneBegin); if (___2721->getOffsetDataType() == OffsetDataType_32Bit) ___2335.___4154(compressSubzoneJob<int32_t>, (___90)compressSubzoneJobData, ___2117); else ___2335.___4154(compressSubzoneJob<int64_t>, (___90)compressSubzoneJobData, ___2117); } ___2335.___4159(___2117);
 #if defined OUTPUT_TIMES
uint64_t ___1165 = ___715(); compressTime += (___1165 - ___3685); ___3685 = ___1165;
 #endif
___4633 const fileZone = ___2675 - m_baseZone; for(ItemAddress64::SubzoneOffset_t ___684 = ItemAddress64::SubzoneOffset_t(chunkSubzoneBegin); ___2037 && ___684 < ItemAddress64::SubzoneOffset_t(chunkSubzoneEnd); ++___684) { m_secCszConnectivityFileLocs[section][___684] = szpltFile.fileLoc(); ___1337& feCellSubzoneCompressor = compressorVector[___684 - chunkSubzoneBegin]; ItemAddress64::SubzoneOffset_t const numRefNszs = feCellSubzoneCompressor.numRefNszs(); bool outputPartitionIndices = false; for(ItemAddress64::SubzoneOffset_t ___3321 = 0; ___3321 < numRefNszs; ++___3321) { ItemAddress64::___2978 ___2975 = feCellSubzoneCompressor.refPtnNszs()[___3321].___2975(); if (___2975 == ItemAddress64::INVALID_PARTITION || static_cast<___4633>(___2975) == fileZone) { ItemAddress64::SubzoneOffset_t const ___2755 = feCellSubzoneCompressor.refPtnNszs()[___3321].subzoneOffset(); ItemAddress64::SubzoneAddress const ptnCsz(fileZone, section, ___684); nszRefPtnCszSets[___2755].insert(ptnCsz); } else { outputPartitionIndices = true; } } ___2037 = ___2037 && ___4498(szpltFile, ___684); ___2037 = ___2037 && ___4497(szpltFile, section, compressorVector[___684 - chunkSubzoneBegin], outputPartitionIndices); if (outputPartitionIndices) setBit(m_secCszIncludesPartitionOffsetsBitArray[section], ___684); m_secNumRefNodeSubzones[section][___684] = compressorVector[___684 - chunkSubzoneBegin].numRefNszs(); }
 #if defined OUTPUT_TIMES
___1165 = ___715(); ___4546 += (___1165 - ___3685); ___3685 = ___1165;
 #endif
} }
 #if defined OUTPUT_TIMES
___1929(NULL, "%g seconds compressing cell subzones.", (double)(compressTime) / 1000.0); ___1929(NULL, "%g seconds writing cell subzones.", (double)(___4546) / 1000.0);
 #endif
___2335.___4157(&___2117); return ___2037; } template <typename NODE_TYPE> uint64_t SZLFEZoneWriter::cszConnectivityFileSize( ___2722 const&          ___2721, bool                    ___2000, SubzoneAddressSetArray& nszRefPtnCszSets) { uint64_t ___3356 = m_feZoneInfo->___2781() * cszConnectivityHeaderFileSize(___2000); boost::array<NODE_TYPE,MAX_NODES_PER_ELEM> elemNodes; ItemAddress64::SectionOffset_t const numSections = m_feZoneInfo->getNumSections(); for (ItemAddress64::SectionOffset_t section = 0; section < numSections; ++section) { int32_t const numNodesPerCell = m_feZoneInfo->getNumNodesPerCell(section); ___4633 const fileZone = ___2675 - m_baseZone; for(ItemAddress64::SubzoneOffset_t ___684 = 0; ___684 < m_feZoneInfo->numCszsInSection(section); ++___684) { SubzoneAddressUnorderedSet refPtnNszSet; bool outputPartitionIndices = false; for(ItemAddress64::ItemOffset_t off = 0; off < m_feZoneInfo->___2780(section, ___684); ++off) { ItemAddress64 const cellCoordinate(ItemAddress64::UNKNOWN_PARTITION, section, ___684, off); ___463 ___447 = m_feZoneInfo->cellAtItemAddress(cellCoordinate); ___2721.getElemNodes<NODE_TYPE>(section+1, ___447+1, 1, elemNodes.data()); for (int32_t nOffset = 0; nOffset < numNodesPerCell; ++nOffset) { int64_t ___2707 = elemNodes[nOffset]; ItemAddress64 const& nodeCoordinate = m_feZoneInfo->itemAddressAtNode(___2707 - 1); ItemAddress64::___2978 ___2975 = nodeCoordinate.___2975(); ItemAddress64::SubzoneOffset_t ___2755 = nodeCoordinate.subzoneOffset(); if (___2975 == ItemAddress64::INVALID_PARTITION || static_cast<___4633>(___2975) == fileZone) { refPtnNszSet.insert(ItemAddress64::SubzoneAddress(fileZone, 0 , ___2755)); nszRefPtnCszSets[___2755].insert(ItemAddress64::SubzoneAddress(fileZone, section, ___684)); } else { refPtnNszSet.insert(ItemAddress64::SubzoneAddress(___2975, 0 , ___2755)); outputPartitionIndices = true; } } } size_t totalNumCellNodes = static_cast<size_t>(m_feZoneInfo->___2780(section, ___684)) * numNodesPerCell; uint64_t cszDataFileSize = cszConnectivityDataFileSize( ___2000, totalNumCellNodes, refPtnNszSet.size(), m_feZoneInfo->getNumReferencedPartitions(), outputPartitionIndices); ___3356 += cszDataFileSize; } } return ___3356; } uint64_t SZLFEZoneWriter::cszConnectivityFileSize(bool ___2000, SubzoneAddressSetArray& nszRefPtnCszSets) { ___2722 ___2721(&___2335, ___2675 + 1); return ___2721.getOffsetDataType() == OffsetDataType_32Bit ? cszConnectivityFileSize<int32_t>(___2721, ___2000, nszRefPtnCszSets) : cszConnectivityFileSize<int64_t>(___2721, ___2000, nszRefPtnCszSets); } ___372 SZLFEZoneWriter::___4534( FileWriterInterface&           file, ItemAddress64::SubzoneOffset_t ___2732) { ___372 ___2037 = ___4224; REQUIRE(file.___2039()); if (file.___2000()) { ___2037 = writeValue<uint32_t, false, 0>(file, "nszConnectivityMarker*", SZPLT_NSZ_CONNECTIVITY_MARKER) && writeValue<uint32_t, false, 0>(file, m_zoneNumberLabel.c_str(), (___2675 - m_baseZone + 1)) &&
writeValue<uint64_t, false, 0>(file, "subzoneNum*", ___2732 + 1); } ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } uint64_t SZLFEZoneWriter::nszConnectivityHeaderFileSize(bool ___2000) { uint64_t ___3356 = 0; if (___2000) ___3356 += 2 * valueSizeInFile<uint32_t, false>(___2000) + valueSizeInFile<uint64_t, false>(___2000); return ___3356; } namespace { inline ___372 ___4533( FileWriterInterface&       file, ZoneType_e                 ___4689, char const*                ___970, SubzoneAddressSet const&   refPtnCszSet, PartitionArray const&      referencedPartitions, ItemAddress64::___2978 numReferencedPartitions, bool                       outputPartitionIndices) { ___4276(___970); if (refPtnCszSet.size() > uint16_t(-1)) { std::cerr << "Overflow while writing Node subzone. Too many cells use the same node (> 65536)." << std::endl; return ___1303; } UInt32Array refPtnArray; UInt32Array refCszArray; uint16_t const numRefCszs = uint16_t(refPtnCszSet.size()); ___372 ___2037 = ___4224; if (___2037 && numRefCszs > 0) { ___2037 = refPtnArray.alloc(numRefCszs) && refCszArray.alloc(numRefCszs); if ( ___2037 ) { BitArray<ItemAddress64::SectionOffset_t,4> refCszSec4BitOffsets(numRefCszs, 0); ItemAddress64::SubzoneOffset_t refCszIndex = 0; for (SubzoneAddressSet::const_iterator iter = refPtnCszSet.begin(); iter != refPtnCszSet.end(); iter++) { refPtnArray[refCszIndex] = iter->___2975(); if (___2037 && ___4689 == ZoneType_FEMixed) { ___476(SZPLT_CUR_WRITE_VERSION > 105); refCszSec4BitOffsets[refCszIndex] = iter->sectionOffset(); } refCszArray[refCszIndex] = iter->subzoneOffset(); refCszIndex++; } ___476(refCszIndex==numRefCszs); if (outputPartitionIndices) { typedef uint16_t OffsetType; if (numReferencedPartitions <= MAX_REFS_FOR_2_BIT_COMPRESSION) { UInt8Array refPtn2BitOffsets; ___2037 = refPtn2BitOffsets.alloc(BitArray<OffsetType,2>::byteArraySize(numRefCszs)); if (___2037) { size_t const ___2777 = gatherCompressedOffsets<uint32_t,OffsetType,2>(refPtnArray.data(), numRefCszs, referencedPartitions.data(), numReferencedPartitions, refPtn2BitOffsets.data()); ___2037 = ___2037 && ___4560<uint8_t, true, 0>(file, "refPtn2BitOffsets", ___2743, ___2777, refPtn2BitOffsets.data(), ___944 / 4); } } else if (numReferencedPartitions <= MAX_REFS_FOR_4_BIT_COMPRESSION) { UInt8Array refPtn4BitOffsets; ___2037 = refPtn4BitOffsets.alloc(BitArray<OffsetType,4>::byteArraySize(numRefCszs)); if (___2037) { size_t const ___2777 = gatherCompressedOffsets<uint32_t,OffsetType,4>(refPtnArray.data(), numRefCszs, referencedPartitions.data(), numReferencedPartitions, refPtn4BitOffsets.data()); ___2037 = ___2037 && ___4560<uint8_t, true, 0>(file, "refPtn4BitOffsets", ___2743, ___2777, refPtn4BitOffsets.data(), ___944 / 2); } } else if (numReferencedPartitions <= MAX_REFS_FOR_8_BIT_COMPRESSION) { UInt8Array refPtn8BitOffsets; ___2037 = refPtn8BitOffsets.alloc(BitArray<OffsetType,8>::byteArraySize(numRefCszs)); if (___2037) { size_t const ___2777 = gatherCompressedOffsets<uint32_t,OffsetType,8>(refPtnArray.data(), numRefCszs,
referencedPartitions.data(), numReferencedPartitions, refPtn8BitOffsets.data()); ___2037 = ___2037 && ___4560<uint8_t, true, 0>(file, "refPtn8BitOffsets", ___2743, ___2777, refPtn8BitOffsets.data()); } } else { UInt16Array refPtn16BitOffsets; ___2037 = refPtn16BitOffsets.alloc(numRefCszs); if (___2037) { gatherOffsets(refPtnArray.data(), numRefCszs, referencedPartitions.data(), numReferencedPartitions, refPtn16BitOffsets.data()); ___2037 = ___2037 && ___4560<OffsetType, true, 0>(file, "refPtn16BitOffsets", ___2743, numRefCszs, refPtn16BitOffsets.data()); } } } ___2037 = ___2037 && ___4560<uint32_t, false, 1>(file, NSZ_CONNECT_REF_CSZS, ___2743, numRefCszs, refCszArray.data()); if (___2037 && ___4689 == ZoneType_FEMixed) { ___476(SZPLT_CUR_WRITE_VERSION > 105); ___2037 = ___2037 && ___4560<uint8_t, false, 0>(file, "refCszSec4BitOffsets", ___2743, refCszSec4BitOffsets.byteSize(), static_cast<uint8_t*>(refCszSec4BitOffsets.data())); } } refPtnArray.___935(); refCszArray.___935(); } ENSURE(refPtnArray.empty()); ENSURE(refCszArray.empty()); ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } } namespace { uint64_t nszConnectivityDataFileSize( bool                       ___2000, ZoneType_e                 ___4689, ItemAddress64::___2978 numReferencedPartitions, bool                       outputPartitionIndices, SubzoneAddressSet const&   refPtnCszSet) { uint64_t ___3356 = 0; size_t const numRefCszs = refPtnCszSet.size(); if (outputPartitionIndices) { if (numReferencedPartitions <= MAX_REFS_FOR_2_BIT_COMPRESSION) ___3356 += arraySizeInFile<uint8_t, true  >( BitArray<uint16_t,2>::byteArraySize(numRefCszs), ___2000); else if (numReferencedPartitions <= MAX_REFS_FOR_4_BIT_COMPRESSION) ___3356 += arraySizeInFile<uint8_t, true  >( BitArray<uint16_t,4>::byteArraySize(numRefCszs), ___2000); else if (numReferencedPartitions <= MAX_REFS_FOR_8_BIT_COMPRESSION) ___3356 += arraySizeInFile<uint8_t, true  >( BitArray<uint16_t,8>::byteArraySize(numRefCszs), ___2000); else ___3356 += arraySizeInFile<uint16_t, true  >(numRefCszs, ___2000); } ___3356 += arraySizeInFile<uint32_t, false>(numRefCszs, ___2000); if (___4689 == ZoneType_FEMixed) { ___3356 += arraySizeInFile<uint8_t, false >( BitArray<ItemAddress64::SectionOffset_t,4>::byteArraySize(numRefCszs), ___2000); } return ___3356; } } ___372 SZLFEZoneWriter::___4532( FileWriterInterface&      szpltFile, SubzoneAddressSetArray& nszRefPtnCszSets) { ___372 ___2037 = ___4224; for (___1348::NeighborCszRefMap::const_iterator entryIt = m_feZoneInfo->getNeighborCszRefs().begin(); entryIt != m_feZoneInfo->getNeighborCszRefs().end(); ++entryIt) { ___1348::NeighborCszRefMap::value_type const& entry = *entryIt; ItemAddress64::SubzoneOffset_t ___2755 = entry.first; for (SubzoneAddressUnorderedSet::iterator ptnCszIt = entry.second.begin(); ptnCszIt != entry.second.end(); ++ptnCszIt) { ItemAddress64::SubzoneAddress const& ptnCsz = *ptnCszIt; nszRefPtnCszSets[___2755].insert(ptnCsz); } } ___4633 const fileZone = ___2675 - m_baseZone;
for (ItemAddress64::SubzoneOffset_t ___2755 = 0; ___2037 && ___2755 < m_feZoneInfo->___2821(); ___2755++) { m_nszConnectivityFileLocs[___2755] = szpltFile.fileLoc(); m_numRefCellSubzones[___2755] = static_cast<uint16_t>(nszRefPtnCszSets[___2755].size()); bool outputPartitionIndices = false; for (SubzoneAddressSet::iterator partitionSubzoneIt = nszRefPtnCszSets[___2755].begin(); partitionSubzoneIt != nszRefPtnCszSets[___2755].end(); ++partitionSubzoneIt) { ItemAddress64::SubzoneAddress const& partitionSubzone = *partitionSubzoneIt; ItemAddress64::___2978 ptnIndex = partitionSubzone.___2975(); if (ptnIndex != ItemAddress64::INVALID_PARTITION && static_cast<___4633>(ptnIndex) != fileZone) { outputPartitionIndices = true; } } if (outputPartitionIndices) setBit(m_nszIncludesPartitionOffsetsBitArray, ___2755); ___2037 = ___2037 && ___4534(szpltFile, ___2755); ___2037 = ___2037 && ___4533( szpltFile, ___2335.___4617(___2675 + 1), "nszConnectivity", nszRefPtnCszSets[___2755], m_feZoneInfo->getReferencedPartitions(), m_feZoneInfo->getNumReferencedPartitions(), outputPartitionIndices); } return ___2037; } uint64_t SZLFEZoneWriter::nszConnectivityFileSize(bool ___2000, SubzoneAddressSetArray& nszRefPtnCszSets) { uint64_t ___3356 = m_feZoneInfo->___2821() * nszConnectivityHeaderFileSize(___2000); for (___1348::NeighborCszRefMap::const_iterator entry = m_feZoneInfo->getNeighborCszRefs().begin(); entry != m_feZoneInfo->getNeighborCszRefs().end(); ++entry) { ItemAddress64::SubzoneOffset_t ___2755 = entry->first; for (SubzoneAddressUnorderedSet::const_iterator ptnCsz = entry->second.begin(); ptnCsz != entry->second.end(); ++ptnCsz) { nszRefPtnCszSets[___2755].insert(*ptnCsz); } } ___4633 const fileZone = ___2675 - m_baseZone; for(ItemAddress64::SubzoneOffset_t ___2755 = 0; ___2755 < m_feZoneInfo->___2821(); ++___2755) { bool outputPartitionIndices = false; for (SubzoneAddressSet::iterator partitionSubzone = nszRefPtnCszSets[___2755].begin(); partitionSubzone != nszRefPtnCszSets[___2755].end(); ++partitionSubzone) { ItemAddress64::___2978 ptnIndex = partitionSubzone->___2975(); if (ptnIndex != ItemAddress64::INVALID_PARTITION && static_cast<___4633>(ptnIndex) != fileZone) outputPartitionIndices = true; } ___3356 += nszConnectivityDataFileSize(___2000, ___2335.___4617(___2675 + 1), m_feZoneInfo->getNumReferencedPartitions(), outputPartitionIndices, nszRefPtnCszSets[___2755]); } return ___3356; } ___372 SZLFEZoneWriter::writeZoneConnectivity(FileWriterInterface& szpltFile) { ___372 ___2037 = ___4224; if (m_writeConnectivity) { ___2335.___856(); SubzoneAddressSetArray nszRefPtnCszSets;
 #if defined OUTPUT_TIMES
uint64_t ___3685 = ___715();
 #endif
___2037 = ___2037 && ___483(SzPltWriteOperation_WriteConnectivity, ___2335, 0 , ___2675); ___2037 = ___2037 && nszRefPtnCszSets.alloc(m_feZoneInfo->___2821()); ItemAddress64::SectionOffset_t const numSections = m_feZoneInfo->getNumSections(); ___2037 = ___2037 && m_secCszConnectivityFileLocs.alloc(numSections); ___2037 = ___2037 && m_secNumCszs.alloc(numSections, 0); ___2037 = ___2037 && m_secNumRefNodeSubzones.alloc(numSections); ___2037 = ___2037 && m_secCszIncludesPartitionOffsetsBitArray.alloc(numSections); for (ItemAddress64::SectionOffset_t section = 0; ___2037 && section < numSections; ++section) { if (___2037) m_secNumCszs[section] = m_feZoneInfo->numCszsInSection(section); ___2037 = ___2037 && m_secCszConnectivityFileLocs[section].alloc(m_secNumCszs[section], ___330); ___2037 = ___2037 && m_secNumRefNodeSubzones[section].alloc(m_secNumCszs[section], 0); ___2037 = ___2037 && m_secCszIncludesPartitionOffsetsBitArray[section].alloc(numBytesForNumBits(m_secNumCszs[section]), 0); } ___2037 = ___2037 && m_numRefCellSubzones.alloc(m_feZoneInfo->___2821(), 0); ___2037 = ___2037 && m_nszIncludesPartitionOffsetsBitArray.alloc(numBytesForNumBits(m_feZoneInfo->___2821()), 0); ___2727 ___2721 = boost::make_shared<___2722>(&___2335, ___2675 + 1); if (!___2721->___2065()) ___2037 = ___1303; try { ___2037 = ___2037 && writeCszConnectivity(szpltFile, ___2721, nszRefPtnCszSets);
 #if defined OUTPUT_TIMES
uint64_t ___1165 = ___715(); ___1929(NULL, "%g seconds writing cell subzone connectivity.", (double)(___1165 - ___3685) / 1000.0); ___3685 = ___1165;
 #endif
} catch (___1337::Error const& e) { std::cerr << "Error compressing node map: " << e.what() << std::endl; ___2037 = ___1303; } ___2037 = ___2037 && m_nszConnectivityFileLocs.alloc(m_feZoneInfo->___2821(), ___330); ___2037 = ___2037 && ___4532(szpltFile, nszRefPtnCszSets);
 #if defined OUTPUT_TIMES
uint64_t ___1165 = ___715(); ___1929(NULL, "%g seconds writing node subzone connectivity.", (double)(___1165 - ___3685) / 1000.0);
 #endif
___2335.___857(); } return ___2037; } uint64_t SZLFEZoneWriter::zoneConnectivityFileSize(bool ___2000) { uint64_t ___3356 = 0; if (m_writeConnectivity) { SubzoneAddressSetArray nszRefPtnCszSets; if (nszRefPtnCszSets.alloc(m_feZoneInfo->___2821())) { ___3356 += cszConnectivityFileSize(___2000, nszRefPtnCszSets); ___3356 += nszConnectivityFileSize(___2000, nszRefPtnCszSets); } } return ___3356; } ___372 SZLFEZoneWriter::___4509( FileWriterInterface&           file, ValueLocation_e                ___4323, ___4349                     datasetVar, ItemAddress64::SubzoneOffset_t ___3878) { ___372 ___2037 = ___4224; REQUIRE(file.___2039()); REQUIRE(___4323 == ___4325 || ___4323 == ___4327); if (file.___2000()) { if ( ___4323 == ___4325 ) ___2037 = ___2037 && writeValue<uint32_t, false, 0>(file, "cszFieldDataMarker*", SZPLT_CSZ_FIELD_DATA_MARKER); else ___2037 = ___2037 && writeValue<uint32_t, false, 0>(file, "nszFieldDataMarker*", SZPLT_NSZ_FIELD_DATA_MARKER); ___2037 = ___2037 && writeValue<uint32_t, false, 0>(file, "variableNum*", (datasetVar - m_varIter.baseItem() + 1)); ___2037 = ___2037 && writeValue<uint32_t, false, 0>(file, m_zoneNumberLabel.c_str(), (___2675 - m_baseZone + 1)); ___2037 = ___2037 && writeValue<uint64_t, false, 0>(file, "subzoneNum*", ___3878 + 1); } ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } uint64_t SZLFEZoneWriter::fieldDataSubzoneHeaderFileSize(bool ___2000) { uint64_t ___3356 = 0; if (___2000) { ___3356 += 3 * valueSizeInFile<uint32_t, false>(___2000) + valueSizeInFile<uint64_t, false>(___2000); } return ___3356; } template <typename T, bool isBitArray> uint64_t SZLFEZoneWriter::cellSubzoneFieldDataFileSize(bool ___2000, ItemAddress64::SectionOffset_t section, ItemAddress64::SubzoneOffset_t ___467) const { size_t ___2780 = static_cast<size_t>(m_feZoneInfo->___2780(section, ___467)); return arraySizeInFile<T, false>(___2780, ___2000); } template <> uint64_t SZLFEZoneWriter::cellSubzoneFieldDataFileSize<uint8_t, true>(bool ___2000, ItemAddress64::SectionOffset_t section, ItemAddress64::SubzoneOffset_t ___467) const { size_t ___2780 = static_cast<size_t>(m_feZoneInfo->___2780(section, ___467)); return arraySizeInFile<uint8_t, false>(numBytesForNumBits(___2780), ___2000); } template <typename T, bool isBitArray> uint64_t SZLFEZoneWriter::nodeSubzoneFieldDataFileSize(bool ___2000, ItemAddress64::SubzoneOffset_t ___2732) const { size_t ___2820 = static_cast<size_t>(m_feZoneInfo->___2820(___2732)); return arraySizeInFile<T, false>(___2820, ___2000); } template <> uint64_t SZLFEZoneWriter::nodeSubzoneFieldDataFileSize<uint8_t, true>(bool ___2000, ItemAddress64::SubzoneOffset_t ___2732) const { size_t ___2820 = static_cast<size_t>(m_feZoneInfo->___2820(___2732)); return arraySizeInFile<uint8_t, false>(numBytesForNumBits(___2820), ___2000);
} template <typename T, bool isBitArray  > uint64_t SZLFEZoneWriter::subzoneFieldDataFileSize(bool ___2000, ItemAddress64::SectionOffset_t section, ItemAddress64::SubzoneOffset_t ___3878, ValueLocation_e ___4323) const { if (___4323 == ___4325) return cellSubzoneFieldDataFileSize<T, isBitArray>(___2000, section, ___3878); else return nodeSubzoneFieldDataFileSize<T, isBitArray>(___2000, ___3878); } template <typename T, bool isBitArray  > uint64_t SZLFEZoneWriter::variableFileSize(bool ___2000, ValueLocation_e ___4323) { uint64_t ___3356 = 0; ItemAddress64::SubzoneOffset_t const ___2821 = m_feZoneInfo->___2821(); ___3356 += arraySizeInFile<std::pair<T, T>, false >(static_cast<size_t>(___2821), ___2000); for (ItemAddress64::SectionOffset_t section = 0; section < m_feZoneInfo->getNumSections(); ++section) { ItemAddress64::SubzoneOffset_t const ___2781 = m_feZoneInfo->numCszsInSection(section); ___3356 += arraySizeInFile<std::pair<T, T>, false >(static_cast<size_t>(___2781), ___2000); } if (___4323 == ___4325) { for (ItemAddress64::SectionOffset_t section = 0; section < m_feZoneInfo->getNumSections(); ++section) { ItemAddress64::SubzoneOffset_t const ___2781 = m_feZoneInfo->numCszsInSection(section); for (ItemAddress64::SubzoneOffset_t ___3921 = 0; ___3921 < ___2781; ++___3921) { ___3356 += fieldDataSubzoneHeaderFileSize(___2000); ___3356 += subzoneFieldDataFileSize<T, isBitArray>(___2000, section, ___3921, ___4323); } } } else { for (ItemAddress64::SubzoneOffset_t ___3921 = 0; ___3921 < ___2821; ++___3921) { ___3356 += fieldDataSubzoneHeaderFileSize(___2000); ___3356 += subzoneFieldDataFileSize<T, isBitArray>(___2000, 0 , ___3921, ___4323); } } return ___3356; } uint64_t SZLFEZoneWriter::zoneDataFileSize(bool ___2000) { uint64_t ___3356 = 0; m_varIter.reset(); ___4349 const baseVar = m_varIter.baseItem(); while (m_varIter.hasNext()) { ___4349 const datasetVar = m_varIter.next(); ___4349 const fileVar = datasetVar - baseVar; if (!m_writeVariables[fileVar]) continue; FieldDataType_e const ___1361 = ___2335.___921(___2675 + 1, fileVar + 1); ValueLocation_e const ___4323 = ___2335.___908(___2675 + 1, fileVar + 1); switch (___1361) { case FieldDataType_Float: ___3356 += variableFileSize<float, false>(___2000, ___4323); break; case FieldDataType_Double: ___3356 += variableFileSize<double, false>(___2000, ___4323); break; case FieldDataType_Int32: ___3356 += variableFileSize<int32_t, false>(___2000, ___4323); break; case FieldDataType_Int16: ___3356 += variableFileSize<int16_t, false>(___2000, ___4323); break; case FieldDataType_Byte: ___3356 += variableFileSize<uint8_t, false>(___2000, ___4323); break; case ___1363: ___3356 += variableFileSize<uint8_t, true>(___2000, ___4323); break; default: ___476(___1303); break; } } return ___3356; } template <typename T, bool isBitArray  >
___372 SZLFEZoneWriter::___4493( FileWriterInterface&           szpltFile, ___1350 const&               ___1349, ItemAddress64::SectionOffset_t section, ItemAddress64::SubzoneOffset_t ___467) { ___372 ___2037 = ___4224; REQUIRE(szpltFile.___2039()); REQUIRE(___1349.___2065()); REQUIRE(___1349.___1784() == ___4325); ___2238<T> valueArray; ItemAddress64::SubzoneOffset_t ___2780 = m_feZoneInfo->___2780(section, ___467); ___2037 = ___2037 && valueArray.alloc(___2780); T* rawPointer = static_cast<T*>(___1349.getRawPointer()); if (___2037) { ___81 const baseCell = m_feZoneInfo->baseCellAtSection(section); for (ItemAddress64::ItemOffset_t cszOffset = 0; cszOffset < ___2780; cszOffset++) { ItemAddress64 const ___686(ItemAddress64::UNKNOWN_PARTITION, section, ___467, cszOffset); ___463 const globalCell = baseCell + m_feZoneInfo->cellAtItemAddress(___686); if (rawPointer) valueArray[cszOffset] = rawPointer[globalCell]; else valueArray[cszOffset] = static_cast<T>(___1349.___1778(globalCell + 1)); } } ___2037 = ___2037 && ___4560<T, false, 0>(szpltFile, "cszFieldData", ___2743, ___2780, valueArray.data()); valueArray.___935(); ENSURE(valueArray.empty()); ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } template <> ___372 SZLFEZoneWriter::___4493<uint8_t, true>( FileWriterInterface&           szpltFile, ___1350 const&               ___1349, ItemAddress64::SectionOffset_t section, ItemAddress64::SubzoneOffset_t ___467) { ___372 ___2037 = ___4224; REQUIRE(szpltFile.___2039()); REQUIRE(___1349.___2065()); REQUIRE(___1349.___1784() == ___4325); ___2238<uint8_t> valueArray; ItemAddress64::SubzoneOffset_t ___2780 = m_feZoneInfo->___2780(section, ___467); uint64_t arraySize = numBytesForNumBits(___2780); ___2037 = ___2037 && valueArray.alloc(arraySize); if (___2037) { ___81 const baseCell = m_feZoneInfo->baseCellAtSection(section); for (ItemAddress64::ItemOffset_t cszItemOffset = 0; cszItemOffset < ___2780; cszItemOffset++) { ItemAddress64 const ___686(ItemAddress64::UNKNOWN_PARTITION, section, ___467, cszItemOffset); ___463 const globalCell = baseCell + m_feZoneInfo->cellAtItemAddress(___686); double const ___4296 = ___1349.___1778(globalCell + 1); if (___4296 < 1.0) clearBit(valueArray, cszItemOffset); else setBit(valueArray, cszItemOffset); } } ___2037 = ___2037 && ___4560<uint8_t, false, 0>(szpltFile, "cszFieldData", ___2743, arraySize, valueArray.data()); valueArray.___935(); ENSURE(valueArray.empty()); ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } template <typename T, bool isBitArray  > ___372 SZLFEZoneWriter::___4528( FileWriterInterface&           szpltFile, ___1350 const&               ___1349, ItemAddress64::SubzoneOffset_t ___2732) { ___372 ___2037 = ___4224;
REQUIRE(szpltFile.___2039()); REQUIRE(___1349.___2065()); REQUIRE(___1349.___1784() == ___4327); ___2238<T> valueArray; ItemAddress64::ItemOffset_t ___2820 = m_feZoneInfo->___2820(___2732); ___2037 = ___2037 && valueArray.alloc(___2820); T* rawPointer = static_cast<T*>(___1349.getRawPointer()); if (___2037) { for (ItemAddress64::ItemOffset_t nszItemOffset = 0; nszItemOffset < ___2820; nszItemOffset++) { ItemAddress64 const ___2757(ItemAddress64::UNKNOWN_PARTITION, 0 , ___2732, nszItemOffset); ___2716 const ___2707 = m_feZoneInfo->nodeAtItemAddress(___2757); if (rawPointer) valueArray[nszItemOffset] = rawPointer[___2707]; else valueArray[nszItemOffset] = static_cast<T>(___1349.___1778(___2707 + 1)); } } ___2037 = ___2037 && ___4560<T, false, 0>(szpltFile, "nszFieldData", ___2743, ___2820, valueArray.data()); valueArray.___935(); ENSURE(valueArray.empty()); ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } template <> ___372 SZLFEZoneWriter::___4528<uint8_t, true>( FileWriterInterface&           szpltFile, ___1350 const&               ___1349, ItemAddress64::SubzoneOffset_t ___2732) { ___372 ___2037 = ___4224; REQUIRE(szpltFile.___2039()); REQUIRE(___1349.___2065()); REQUIRE(___1349.___1784() == ___4327); ___2238<uint8_t> valueArray; ItemAddress64::ItemOffset_t ___2820 = m_feZoneInfo->___2820(___2732); uint64_t arraySize = numBytesForNumBits(___2820); ___2037 = ___2037 && valueArray.alloc(arraySize); if (___2037) { for (ItemAddress64::ItemOffset_t ___2761 = 0; ___2761 < ___2820; ___2761++) { ItemAddress64 const ___2757(ItemAddress64::UNKNOWN_PARTITION, 0 , ___2732, ___2761); ___2716 const ___2707 = m_feZoneInfo->nodeAtItemAddress(___2757); double const ___4296 = ___1349.___1778(___2707 + 1); if (___4296 < 1.0) clearBit(valueArray, ___2761); else setBit(valueArray, ___2761); } } ___2037 = ___2037 && ___4560<uint8_t, false, 0>(szpltFile, "nszFieldData", ___2743, arraySize, valueArray.data()); valueArray.___935(); ENSURE(valueArray.empty()); ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } template <typename T, bool isBitArray  > ___372 SZLFEZoneWriter::writeVariable( FileWriterInterface&                  szpltFile, ___4349 const                      datasetVar, ___2479 const&                    nszDataMinMax, ___2238<___2479> const& secCszDataMinMax) { ___4349 const fileVar = datasetVar - m_varIter.baseItem(); ItemAddress64::SubzoneOffset_t const ___2821 = m_feZoneInfo->___2821(); ___372 ___2037 = ___4525<T>(szpltFile, NODE_SUBZONE_DATA_MIN_MAX_ARRAY_DESCRIPTION, fileVar, ___2821, nszDataMinMax.data(), ___944 / 2); for (ItemAddress64::SectionOffset_t section = 0; ___2037 && section < m_feZoneInfo->getNumSections(); ++section) ___2037 = ___4525<T>(szpltFile, CELL_SUBZONE_DATA_MIN_MAX_ARRAY_DESCRIPTION, fileVar,
m_feZoneInfo->numCszsInSection(section), secCszDataMinMax[section].data(), ___944 / 2); ___1350 ___1349(&___2335, ___2675 + 1, datasetVar + 1); ___2037 = ___2037 && ___1349.___2065(); ValueLocation_e const ___4323 = ___1349.___1784(); if (___4323 == ___4325) { for (ItemAddress64::SectionOffset_t section = 0; ___2037 && section < m_feZoneInfo->getNumSections(); ++section) for (ItemAddress64::SubzoneOffset_t ___3921 = 0; ___2037 && ___3921 < m_feZoneInfo->numCszsInSection(section); ++___3921) ___2037 = (___4509(szpltFile, ___4323, datasetVar, ___3921) && ___4493<T, isBitArray>(szpltFile, ___1349, section, ___3921)); } else { for (ItemAddress64::SubzoneOffset_t ___3921 = 0; ___2037 && ___3921 < ___2821; ++___3921) ___2037 = (___4509(szpltFile, ___4323, datasetVar, ___3921) && ___4528<T, isBitArray>(szpltFile, ___1349, ___3921)); } ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } ___372 SZLFEZoneWriter::writeZoneData(FileWriterInterface& szpltFile) {
 #if defined OUTPUT_TIMES
uint64_t ___3685 = ___715(); uint64_t minMaxTime = 0; uint64_t ___4546 = 0;
 #endif
___372 ___2037 = ___4224; ___2479 ___2760; ___2238<___2479> secCszMinMaxArray; m_varIter.reset(); ___4349 const baseVar = m_varIter.baseItem(); while (___2037 && m_varIter.hasNext()) { ___4349 const datasetVar = m_varIter.next(); ___4349 const fileVar = datasetVar - baseVar; if (!m_writeVariables[fileVar]) continue; ___2335.___856(); ___2037 = ___483(SzPltWriteOperation_WriteFieldData, ___2335, datasetVar, ___2675); ___2037 = ___2037 && calculateVarSubzoneMinMaxes(datasetVar, ___2760, secCszMinMaxArray);
 #if defined OUTPUT_TIMES
uint64_t ___1165 = ___715(); minMaxTime += (___1165 - ___3685); ___3685 = ___1165;
 #endif
___2671[fileVar] = szpltFile.fileLoc(); if (___2037) { switch (___2335.___921(___2675 + 1, datasetVar + 1)) { case FieldDataType_Float: ___2037 = writeVariable<float, false>(szpltFile, datasetVar, ___2760, secCszMinMaxArray); break; case FieldDataType_Double: ___2037 = writeVariable<double, false>(szpltFile, datasetVar, ___2760, secCszMinMaxArray); break; case FieldDataType_Int32: ___2037 = writeVariable<int32_t, false>(szpltFile, datasetVar, ___2760, secCszMinMaxArray); break; case FieldDataType_Int16: ___2037 = writeVariable<int16_t, false>(szpltFile, datasetVar, ___2760, secCszMinMaxArray); break; case FieldDataType_Byte: ___2037 = writeVariable<uint8_t, false>(szpltFile, datasetVar, ___2760, secCszMinMaxArray); break; case ___1363: ___2037 = writeVariable<uint8_t, true>(szpltFile, datasetVar, ___2760, secCszMinMaxArray); break; default: ___476(___1303); ___2037 = ___1303; break; } } ___2760.___935(); secCszMinMaxArray.___935();
 #if defined OUTPUT_TIMES
___1165 = ___715(); ___4546 += (___1165 - ___3685); ___3685 = ___1165;
 #endif
___2335.___857(); }
 #if defined OUTPUT_TIMES
uint64_t ___1165 = ___715(); ___1929(NULL, "%g seconds calculating variable ranges.", (double)(minMaxTime) / 1000.0); ___1929(NULL, "%g seconds writing zone data.", (double)(___4546) / 1000.0);
 #endif
ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } ___372 SZLFEZoneWriter::writeZoneHeader(FileWriterInterface& szpltFile) { REQUIRE(szpltFile.___2039()); return m_headerWriter.write(szpltFile); } uint64_t SZLFEZoneWriter::zoneHeaderFileSize(bool ___2000) { return m_headerWriter.sizeInFile(___2000); } }}
