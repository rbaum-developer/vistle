#include "FECellSubzoneCompressor.h"
#include "ThirdPartyHeadersBegin.h"
#include <algorithm>
#include "ThirdPartyHeadersEnd.h"
#include "gatherOffsets.h"
namespace tecplot { namespace ___3931 { ___1337::___1337() : m_numCellsInSubzone(0) , m_refPtnOffsetsNumBytes(0) , m_numRefNszs(0) , m_refNszOffsetsNumBytes(0) , m_numRefPartitions(0) {} ___1337::~___1337() {} template <typename NODE_TYPE> void ___1337::___534( ___2727                     ___2721, ___1348 const&              ___1347, ItemAddress64::SectionOffset_t section, ItemAddress64::SubzoneOffset_t ___467) { m_numCellsInSubzone = ___1347.___2780(section, ___467); m_numRefPartitions = static_cast<uint16_t>(___1347.getNumReferencedPartitions()); PartitionArray const& referencedPartitions = ___1347.getReferencedPartitions(); m_numRefNszs = 0; m_refPtnNszSet.clear(); uint32_t count = 0; int32_t const numNodesPerCell = ___1347.getNumNodesPerCell(section); boost::array<NODE_TYPE,MAX_NODES_PER_ELEM> elemNodes; ItemAddress64::___2978 const* first = (m_numRefPartitions > 0 ? &referencedPartitions[0] : NULL); ASSERT_ONLY(ItemAddress64::___2978 const* last = (m_numRefPartitions > 0 ? &referencedPartitions[m_numRefPartitions - 1] + 1 : NULL)); for (ItemAddress64::ItemOffset_t cszOffset = 0; cszOffset < m_numCellsInSubzone; ++cszOffset) { ItemAddress64 const ___686(ItemAddress64::UNKNOWN_PARTITION, section, ___467, cszOffset); ___463 const ___447 = ___1347.cellAtItemAddress(___686); ___2721->getElemNodes<NODE_TYPE>(section+1, ___447+1, 1, elemNodes.data()); for (int32_t nOffset = 0; nOffset < numNodesPerCell; ++nOffset) { ___2716 const datasetNode = checked_numeric_cast<___2716>(elemNodes[nOffset] - 1); ItemAddress64 const& szCoordOfNode = ___1347.itemAddressAtNode(datasetNode); m_szCoordinateArray[count] = szCoordOfNode; ItemAddress64::___2978 ___2975 = ItemAddress64::INVALID_PARTITION; if (first) { ___2975 = szCoordOfNode.___2975(); ASSERT_ONLY(ItemAddress64::___2978 const* current = std::lower_bound(first, last, ___2975)); ___476(*current == ___2975); } ItemAddress64::SubzoneOffset_t const ___2755 = szCoordOfNode.subzoneOffset(); ___476(szCoordOfNode.sectionOffset() == 0); ItemAddress64::SubzoneAddress ptnNsz(___2975, 0 , ___2755); m_ptnNszReferences[cszOffset * numNodesPerCell + nOffset] = ptnNsz; m_refPtnNszSet.insert(ptnNsz); ++count; } } m_numRefNszs = uint16_t(m_refPtnNszSet.size()); ItemAddress64::SubzoneOffset_t refPtnNszIndex = 0; for (SubzoneAddressSet::const_iterator iter = m_refPtnNszSet.begin(); iter != m_refPtnNszSet.end(); ++iter) { m_refPtnNszArray[refPtnNszIndex] = *iter; m_refPtnArray[refPtnNszIndex] = iter->___2975(); ___476(iter->sectionOffset() == 0); m_refNszArray[refPtnNszIndex] = iter->subzoneOffset(); ++refPtnNszIndex; } ___476(refPtnNszIndex == m_numRefNszs); std::sort(&m_refPtnNszArray[0], &m_refPtnNszArray[m_numRefNszs]); typedef uint16_t OffsetType; if (m_numRefPartitions > 0) { if (m_numRefPartitions <= MAX_REFS_FOR_2_BIT_COMPRESSION) { m_refPtnOffsetsNumBytes = gatherCompressedOffsets<uint32_t,OffsetType,2>(m_refPtnArray.data(), (OffsetType)(m_numRefNszs),
referencedPartitions.data(), m_numRefPartitions, m_refPtn2BitOffsets.data()); } else if (m_numRefPartitions <= MAX_REFS_FOR_4_BIT_COMPRESSION) { m_refPtnOffsetsNumBytes = gatherCompressedOffsets<uint32_t,OffsetType,4>(m_refPtnArray.data(), (OffsetType)(m_numRefNszs), referencedPartitions.data(), m_numRefPartitions, m_refPtn4BitOffsets.data()); } else if ( m_numRefPartitions <= MAX_REFS_FOR_8_BIT_COMPRESSION ) { m_refPtnOffsetsNumBytes = gatherCompressedOffsets<uint32_t,OffsetType,8>(m_refPtnArray.data(), (OffsetType)(m_numRefNszs), referencedPartitions.data(), m_numRefPartitions, m_refPtn8BitOffsets.data()); } else { m_refPtnOffsetsNumBytes = 0; gatherOffsets(m_refPtnArray.data(), (OffsetType)(m_numRefNszs), referencedPartitions.data(), m_numRefPartitions, m_refPtn16BitOffsets.data()); } } size_t ___2793 = m_numCellsInSubzone * numNodesPerCell; if (m_numRefNszs <= MAX_REFS_FOR_2_BIT_COMPRESSION) { m_refNszOffsetsNumBytes = gatherCompressedOffsets<ItemAddress64::SubzoneAddress,OffsetType,2>( m_ptnNszReferences.data(), (OffsetType)(___2793), m_refPtnNszArray.data(), m_numRefNszs, m_refNsz2BitOffsets.data()); } else if (m_numRefNszs <= MAX_REFS_FOR_4_BIT_COMPRESSION) { m_refNszOffsetsNumBytes = gatherCompressedOffsets<ItemAddress64::SubzoneAddress,OffsetType,4>( m_ptnNszReferences.data(), (OffsetType)(___2793), m_refPtnNszArray.data(), m_numRefNszs, m_refNsz4BitOffsets.data()); } else if ( m_numRefNszs <= MAX_REFS_FOR_8_BIT_COMPRESSION ) { m_refNszOffsetsNumBytes = gatherCompressedOffsets<ItemAddress64::SubzoneAddress,OffsetType,8>( m_ptnNszReferences.data(), (OffsetType)(___2793), m_refPtnNszArray.data(), m_numRefNszs, m_refNsz8BitOffsets.data()); } else { m_refNszOffsetsNumBytes = 0; gatherOffsets(m_ptnNszReferences.data(), (OffsetType)(___2793), m_refPtnNszArray.data(), m_numRefNszs, m_refNsz16BitOffsets.data()); } for (size_t ___1839 = 0; ___1839 < ___2793; ++___1839) { ItemAddress64::ItemOffset_t const ___2863 = m_szCoordinateArray[___1839].itemOffset(); ___476(___2863 <= uint8_t(-1)); m_nszOffsets[___1839] = uint8_t(___2863); } } template void ___1337::___534<int32_t>( ___2727                     ___2721, ___1348 const&              ___1347, ItemAddress64::SectionOffset_t section, ItemAddress64::SubzoneOffset_t ___467); template void ___1337::___534<int64_t>( ___2727                     ___2721, ___1348 const&              ___1347, ItemAddress64::SectionOffset_t section, ItemAddress64::SubzoneOffset_t ___467); ItemAddress64::ItemOffset_t ___1337::___2780() const { return m_numCellsInSubzone; } uint16_t ___1337::numRefNszs() const { return m_numRefNszs; } uint16_t ___1337::numRefPartitions() const { return m_numRefPartitions; } ItemAddress64::SubzoneAddress const* ___1337::refPtnNszs() const { return m_refPtnNszArray.data(); } uint32_t const* ___1337::___3317() const { return m_refNszArray.data();
} size_t ___1337::refPtnOffsetsNumBytes() const { return m_refPtnOffsetsNumBytes; } uint8_t const* ___1337::refPtn2BitOffsets() const { if (m_numRefPartitions > MAX_REFS_FOR_2_BIT_COMPRESSION) throw ("2-bit array requested for node map compression requiring > 2 bits."); return m_refPtn2BitOffsets.data(); } uint8_t const* ___1337::refPtn4BitOffsets() const { if (m_numRefPartitions <= MAX_REFS_FOR_2_BIT_COMPRESSION) throw ("4-bit array requested for node map compression requiring only 2 bits."); else if (m_numRefPartitions > MAX_REFS_FOR_4_BIT_COMPRESSION) throw ("4-bit array requested for node map compression requiring > 4 bits."); return m_refPtn4BitOffsets.data(); } uint8_t const* ___1337::refPtn8BitOffsets() const { if (m_numRefPartitions <= MAX_REFS_FOR_4_BIT_COMPRESSION) throw ("8-bit array requested for node map compression requiring only 4 bits."); else if (m_numRefPartitions > MAX_REFS_FOR_8_BIT_COMPRESSION) throw ("8-bit array requested for node map compression requiring > 8 bits."); return m_refPtn8BitOffsets.data(); } uint16_t const* ___1337::refPtn16BitOffsets() const { if ( m_numRefPartitions <= MAX_REFS_FOR_8_BIT_COMPRESSION ) throw ("16-bit array requested for node map compression requiring < 16 bits."); return m_refPtn16BitOffsets.data(); } size_t ___1337::refNszOffsetsNumBytes() const { return m_refNszOffsetsNumBytes; } uint8_t const* ___1337::refNsz2BitOffsets() const { if (m_numRefNszs > MAX_REFS_FOR_2_BIT_COMPRESSION) throw ("2-bit array requested for node map compression requiring > 2 bits."); return m_refNsz2BitOffsets.data(); } uint8_t const* ___1337::___3319() const { if (m_numRefNszs <= MAX_REFS_FOR_2_BIT_COMPRESSION) throw ("4-bit array requested for node map compression requiring only 2 bits."); else if (m_numRefNszs > MAX_REFS_FOR_4_BIT_COMPRESSION) throw ("4-bit array requested for node map compression requiring > 4 bits."); return m_refNsz4BitOffsets.data(); } uint8_t const* ___1337::___3320() const { if (m_numRefNszs <= MAX_REFS_FOR_4_BIT_COMPRESSION) throw ("8-bit array requested for node map compression requiring only 4 bits."); else if (m_numRefNszs > MAX_REFS_FOR_8_BIT_COMPRESSION) throw ("8-bit array requested for node map compression requiring > 8 bits."); return m_refNsz8BitOffsets.data(); } uint16_t const* ___1337::___3318() const { if ( m_numRefNszs <= MAX_REFS_FOR_8_BIT_COMPRESSION ) throw ("16-bit array requested for node map compression requiring < 16 bits."); return m_refNsz16BitOffsets.data(); } uint8_t const* ___1337::___2762() const { return m_nszOffsets.data(); } }}
