 #pragma once
#include "ThirdPartyHeadersBegin.h"
#include <algorithm>
#include <iterator>
#include <sstream>
#include <stdexcept>
#include <vector>
#include <boost/unordered_set.hpp>
#include "ThirdPartyHeadersEnd.h"
#include "basicTypes.h"
#include "fileio.h"
#include "RawArray.h"
struct GhostInfo_s { std::vector<int64_t> m_baseOffsetPerSection; std::vector<int64_t> m_items; std::vector<int32_t> m_neighbors; std::vector<int64_t> m_neighborItems; GhostInfo_s() {} GhostInfo_s( tecplot::___3267<int64_t const> const& numCellsPerSection, tecplot::___3267<int32_t const> const& cells) { ___1930<int32_t>(numCellsPerSection, cells); } GhostInfo_s( tecplot::___3267<int64_t const> const& numCellsPerSection, tecplot::___3267<int64_t const> const& cells) { ___1930<int64_t>(numCellsPerSection, cells); } GhostInfo_s( tecplot::___3267<int32_t const> const& nodes, tecplot::___3267<int32_t const> const& neighbors, tecplot::___3267<int32_t const> const& neighborItems) { ___1930<int32_t>(nodes, neighbors, neighborItems); } GhostInfo_s( tecplot::___3267<int64_t const> const& nodes, tecplot::___3267<int32_t const> const& neighbors, tecplot::___3267<int64_t const> const& neighborItems) { ___1930<int64_t>(nodes, neighbors, neighborItems); } bool empty() const { return m_items.empty(); } void writeToFile(tecplot::___3931::FileWriterInterface& outputFile, bool ___4477) const { tecplot::tecioszl::writeVector(outputFile, m_baseOffsetPerSection, ___4477); tecplot::tecioszl::writeVector(outputFile, m_items, ___4477); tecplot::tecioszl::writeVector(outputFile, m_neighbors, ___4477); tecplot::tecioszl::writeVector(outputFile, m_neighborItems, ___4477); } uint64_t sizeInFile(bool ___4477) const { return tecplot::tecioszl::vectorSizeInFile(m_baseOffsetPerSection, ___4477) + tecplot::tecioszl::vectorSizeInFile(m_items, ___4477) + tecplot::tecioszl::vectorSizeInFile(m_neighbors, ___4477) + tecplot::tecioszl::vectorSizeInFile(m_neighborItems, ___4477); } GhostInfo_s(tecplot::___3931::___1397& inputFile, bool readASCII) { tecplot::tecioszl::readVector(inputFile, m_baseOffsetPerSection, readASCII); tecplot::tecioszl::readVector(inputFile, m_items, readASCII); tecplot::tecioszl::readVector(inputFile, m_neighbors, readASCII); tecplot::tecioszl::readVector(inputFile, m_neighborItems, readASCII); } private: template <typename T> void ___1930( tecplot::___3267<int64_t const> const& numCellsPerSection, tecplot::___3267<T const> const&       cells) { m_baseOffsetPerSection.reserve(numCellsPerSection.size()); int64_t baseOffset = 0; for (size_t section = 0; section < numCellsPerSection.size(); ++section) { m_baseOffsetPerSection.push_back(baseOffset); baseOffset += numCellsPerSection[section]; } throwIfDuplicateItems(numCellsPerSection, cells); m_items.reserve(cells.size()); std::copy(cells.begin(), cells.end(), std::back_inserter(m_items)); m_neighbors.assign(cells.size(), 0); m_neighborItems.assign(cells.size(), 0); } template <typename T> void ___1930( tecplot::___3267<T const> const& nodes, tecplot::___3267<int32_t const> const& neighbors, tecplot::___3267<T const> const& neighborItems) { int64_t const numNodesPerSection = checked_numeric_cast<int64_t>(nodes.size()); throwIfDuplicateItems(tecplot::___3267<int64_t const>(&numNodesPerSection,1,1), nodes);
m_baseOffsetPerSection.reserve(1); m_baseOffsetPerSection.push_back(0); m_items.reserve(nodes.size()); std::copy(nodes.begin(), nodes.end(), std::back_inserter(m_items)); m_neighbors.reserve(neighbors.size()); std::copy(neighbors.begin(), neighbors.end(), std::back_inserter(m_neighbors)); m_neighborItems.reserve(neighborItems.size()); std::copy(neighborItems.begin(), neighborItems.end(), std::back_inserter(m_neighborItems)); } template <typename T> void throwIfDuplicateItems( tecplot::___3267<int64_t const> const& numItemsPerSection, tecplot::___3267<T const> const&       ___2097) { int64_t baseOffset = 0; for (size_t section = 0; section < numItemsPerSection.size(); ++section) { boost::unordered_set<T> ___2098; for (size_t i = 0; i < static_cast<size_t>(numItemsPerSection[section]); ++i) { if (!___2098.insert(___2097[baseOffset+i]).second) { size_t ___2103 = 0; for(___2103 = 0; ___2103 < i; ++___2103) if (___2097[baseOffset+___2103] == ___2097[baseOffset+i]) break; ___476(___2103 < i); std::ostringstream ___2890; ___2890 << "Duplicate item " << ___2097[baseOffset+i] << " detected at position " << i + 1 << ", section " << section + 1 << "; duplicates item at position " << ___2103 + 1; throw std::runtime_error(___2890.str().c_str()); } } baseOffset += static_cast<size_t>(numItemsPerSection[section]); } } };
