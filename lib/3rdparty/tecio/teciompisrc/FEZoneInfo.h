 #pragma once
#include "ThirdPartyHeadersBegin.h"
#include <algorithm>
#include <utility>
#include <vector>
#include <boost/shared_ptr.hpp>
#include <boost/unordered_map.hpp>
#include <boost/unordered_set.hpp>
#include "ThirdPartyHeadersEnd.h"
#include "FESubzonePartitionerInterface.h"
#include "fileStuff.h"
#include "SzlFileLoader.h"
namespace tecplot { namespace ___3931 { class ___1348 { UNCOPYABLE_CLASS(___1348); public: ___1348( ___2716                                                           ___2819, std::vector<CellNodeIndex_t> const&                                   numLinearNodesPerCell, std::vector<CellNodeIndex_t> const&                                   numHighOrderNodesPerCell, boost::shared_ptr<FESubzonePartitionerInterface>                      nszPartitioner, std::vector<boost::shared_ptr<FESubzonePartitionerInterface> > const& secCszPartitioners, ItemAddress64::___2978                                            ___2975 = ItemAddress64::UNKNOWN_PARTITION, std::vector<___463> const&                                       secNumGhostCells = std::vector<___463>(), ___2716                                                           numGhostNodes = 0) : m_numNodes(___2819) , m_numLinearNodesPerCell(numLinearNodesPerCell) , m_numHighOrderNodesPerCell(numHighOrderNodesPerCell) , m_nszPartitioner(nszPartitioner) , m_secCszPartitioners(secCszPartitioners) , m_partition(___2975) , m_secNumGhostCells(secNumGhostCells) , m_numGhostNodes(numGhostNodes) , m_numReferencedPartitions(0) { REQUIRE(m_numLinearNodesPerCell.size() == m_numHighOrderNodesPerCell.size()); REQUIRE(m_numLinearNodesPerCell.size() > 0); if (m_secNumGhostCells.empty()) m_secNumGhostCells.resize(m_numLinearNodesPerCell.size(), 0); } ~___1348() {} typedef boost::unordered_map<ItemAddress64::SubzoneOffset_t, SubzoneAddressUnorderedSet > NeighborCszRefMap; typedef boost::unordered_map<ItemAddress64::SubzoneOffset_t, std::vector<___2477> > NszMinMaxMap; static ItemAddress64::SubzoneOffset_t calcNumSubzones(___81 ___2810) { REQUIRE(___2810>0); REQUIRE(ItemAddress64::MAX_ITEM_OFFSET+1==DEFAULT_SUBZONE_MAX_FE_SIZE); ItemAddress64::SubzoneOffset_t const numSubzones = ItemAddress64::SubzoneOffset_t( 1 + ( (___2810-1) >> ItemAddress64::ItemOffsetBitSize ) ); ENSURE(numSubzones > 0 && numSubzones <= ___2810); return numSubzones; } ItemAddress64::___2978     getPartition() const { return m_partition; } ___2716                    ___1766() const { return m_numNodes; } CellNodeIndex_t                getNumLinearNodesPerCell(ItemAddress64::SectionOffset_t section) const { return m_numLinearNodesPerCell[section]; } CellNodeIndex_t                getNumHighOrderNodesPerCell(ItemAddress64::SectionOffset_t section) const { return m_numHighOrderNodesPerCell[section]; } CellNodeIndex_t                getNumNodesPerCell(ItemAddress64::SectionOffset_t section) const { return m_numLinearNodesPerCell[section] + m_numHighOrderNodesPerCell[section]; } ItemAddress64::SectionOffset_t getNumSections() const { return checked_numeric_cast<ItemAddress64::SectionOffset_t>(m_numLinearNodesPerCell.size()); } ___463                    getNumGhostCells(ItemAddress64::SectionOffset_t section) const { return m_secNumGhostCells[section]; } ___2716                    getNumGhostNodes() const { return m_numGhostNodes; }
___463 numCellsInSection(ItemAddress64::SectionOffset_t section) const { return m_secCszPartitioners[section]->numIndexes(); } inline ItemAddress64::SubzoneOffset_t ___2781() const { ItemAddress64::SubzoneOffset_t numSubzones = 0; for (ItemAddress64::SectionOffset_t section = 0; section < getNumSections(); ++section) numSubzones += numCszsInSection(section); return numSubzones; } inline ItemAddress64::SubzoneOffset_t numCszsInSection(ItemAddress64::SectionOffset_t section) const { ItemAddress64::SubzoneOffset_t const numSubzones = m_secCszPartitioners[section]->numSubzones(); ENSURE(numSubzones == 0 || numSubzones == calcNumSubzones(numCellsInSection(section) - m_secNumGhostCells[section])); return numSubzones; } ItemAddress64::ItemOffset_t ___2780( ItemAddress64::SectionOffset_t section, ItemAddress64::SubzoneOffset_t ___467) const { return m_secCszPartitioners[section]->numItemsInSubzone(___467); } ___463 baseCellAtSection(ItemAddress64::SectionOffset_t section) const { return m_secCszPartitioners[section]->baseIndex(); } ___463 cellAtItemAddress(ItemAddress64 const& ___2087) const { return m_secCszPartitioners[___2087.sectionOffset()]->indexAtItemAddress(___2087); } inline ItemAddress64 const& itemAddressAtCell( ItemAddress64::SectionOffset_t section, ___463                    ___447) const { REQUIRE(0 <= ___447 && ___447 < numCellsInSection(section)); return m_secCszPartitioners[section]->itemAddressAtIndex(___447); } inline ItemAddress64::SubzoneOffset_t ___2821() const { ItemAddress64::SubzoneOffset_t const numSubzones = m_nszPartitioner->numSubzones(); ENSURE(numSubzones == 0 || numSubzones == calcNumSubzones(m_numNodes - m_numGhostNodes)); return numSubzones; } ItemAddress64::ItemOffset_t ___2820(ItemAddress64::SubzoneOffset_t ___2732) const { return m_nszPartitioner->numItemsInSubzone(___2732); } ___2716 nodeAtItemAddress(ItemAddress64 const& ___2087) const { return m_nszPartitioner->indexAtItemAddress(___2087); } inline ItemAddress64 const& itemAddressAtNode(___2716 ___2707) const { REQUIRE(0 <= ___2707 && ___2707 < m_numNodes); return m_nszPartitioner->itemAddressAtIndex(___2707); } void addNeighborNodeCoordinate(___2716 ___2707, ItemAddress64 const& ___2087) { m_nszPartitioner->setItemAddressAtIndex(___2707, ___2087); } inline void addNeighborCszInfo( tecplot::ItemAddress64::___2978            neighbor, std::vector<___2716> const&                nodes, std::vector<SubzoneAddressUnorderedSet> const& cellSubzones, std::vector<std::vector<___2477> > const&       varMinMaxes) { REQUIRE(getPartition() != ItemAddress64::INVALID_PARTITION); REQUIRE(neighbor != getPartition()); REQUIRE(!nodes.empty()); REQUIRE(nodes.size() == cellSubzones.size()); REQUIRE(cellSubzones.size() == varMinMaxes.size()); if (m_numReferencedPartitions == 0) { m_numReferencedPartitions = 2; m_referencedPartitions.alloc(m_numReferencedPartitions); m_referencedPartitions[0] = getPartition();
m_referencedPartitions[1] = neighbor; } else { std::set<tecplot::ItemAddress64::___2978> partitions(m_referencedPartitions.begin(), m_referencedPartitions.end(m_numReferencedPartitions)); if (partitions.insert(neighbor).second) { ++m_numReferencedPartitions; m_referencedPartitions.___935(); m_referencedPartitions.alloc(m_numReferencedPartitions); int i = 0; for (std::set<tecplot::ItemAddress64::___2978>::iterator ___2975 = partitions.begin(); ___2975 != partitions.end(); ++___2975) { m_referencedPartitions[i++] = *___2975; } } } for(size_t i = 0; i < nodes.size(); ++i) { ItemAddress64 const& szCoordinate = itemAddressAtNode(nodes[i]); ItemAddress64::SubzoneOffset_t ___2755 = szCoordinate.subzoneOffset(); for (SubzoneAddressUnorderedSet::const_iterator ___467 = cellSubzones[i].begin(); ___467 != cellSubzones[i].end(); ++___467) { ___476(neighbor == ___467->___2975()); m_neighborCszRefs[___2755].insert(ItemAddress64::SubzoneAddress( neighbor, ___467->sectionOffset(), ___467->subzoneOffset())); } std::vector<___2477>& minMaxes = m_nszMinMaxes[___2755]; if (minMaxes.empty()) minMaxes.resize(varMinMaxes[i].size()); for(size_t ___2103 = 0; ___2103 < varMinMaxes[i].size(); ++___2103) minMaxes[___2103].include(varMinMaxes[i][___2103]); } } inline void addNeighborCszRef(ItemAddress64::SubzoneOffset_t ___2755, ItemAddress64 const& cellCoordinate) { m_neighborCszRefs[___2755].insert(ItemAddress64::SubzoneAddress( cellCoordinate.___2975(), cellCoordinate.sectionOffset(), cellCoordinate.subzoneOffset())); } NeighborCszRefMap const& getNeighborCszRefs() const { return m_neighborCszRefs; } NszMinMaxMap const& getNszMinMaxes() const { return m_nszMinMaxes; } inline void resetNeighborInfo() { m_neighborCszRefs.clear(); m_nszMinMaxes.clear(); m_numReferencedPartitions = 0; m_referencedPartitions.___935(); } inline void addReferencedPartitions(std::set<tecplot::ItemAddress64::___2978> const& partitionSet) { REQUIRE(getPartition() != ItemAddress64::INVALID_PARTITION); REQUIRE(!partitionSet.empty()); std::set<tecplot::ItemAddress64::___2978> partitions(partitionSet); for(tecplot::ItemAddress64::___2978 i = 0; i < m_numReferencedPartitions; ++i) partitions.insert(m_referencedPartitions[i]); partitions.insert(getPartition()); if (m_numReferencedPartitions != static_cast<tecplot::ItemAddress64::___2978>(partitions.size())) { m_referencedPartitions.___935(); m_referencedPartitions.alloc((uint64_t)partitions.size()); int i = 0; for (std::set<tecplot::ItemAddress64::___2978>::iterator ___2975 = partitions.begin(); ___2975 != partitions.end(); ++___2975) { m_referencedPartitions[i] = *___2975; ++i; } m_numReferencedPartitions = i; } } tecplot::ItemAddress64::___2978 getNumReferencedPartitions() const { return m_numReferencedPartitions; } PartitionArray const& getReferencedPartitions() const { return m_referencedPartitions; } private: ___2716 const                                                    m_numNodes; std::vector<CellNodeIndex_t> const                                   m_numLinearNodesPerCell;
std::vector<CellNodeIndex_t> const                                   m_numHighOrderNodesPerCell; boost::shared_ptr<FESubzonePartitionerInterface> const               m_nszPartitioner; std::vector<boost::shared_ptr<FESubzonePartitionerInterface> > const m_secCszPartitioners; ItemAddress64::___2978                                           m_partition; std::vector<___463>                                             m_secNumGhostCells; ___2716 const                                                    m_numGhostNodes; NeighborCszRefMap                                                    m_neighborCszRefs; NszMinMaxMap                                                         m_nszMinMaxes; tecplot::ItemAddress64::___2978                                  m_numReferencedPartitions; PartitionArray                                                       m_referencedPartitions; }; }}
