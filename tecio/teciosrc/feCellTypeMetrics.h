 #pragma once
#include "ThirdPartyHeadersBegin.h"
#include <algorithm>
 #if __cplusplus > 199711L
#include <cstdint>
 #else
#include <stdint.h>
 #endif
#include "ThirdPartyHeadersEnd.h"
#include "MASTER.h"
#include "GLOBAL.h"
#include "StandardIntegralTypes.h"
#include "CodeContract.h"
namespace tecplot { namespace { ___1170 triNumNodes(FEGridOrder_t gridOrder) { return gridOrder == 1 ? 3 : (gridOrder + 1) * (gridOrder + 2) / 2; } } namespace { ___1170 quadNumNodes(FEGridOrder_t gridOrder) { return (gridOrder + 1) * (gridOrder + 1); } } template < class NumCornersPerFaceOrEdgeItr, class NumNodesPerFaceOrEdgeItr, class NumHighOrderNodesPerFaceOrEdgeItr > void feCellTypeMetrics( FECellShape_e const shape, FEGridOrder_t const gridOrder, FECellBasisFunction_e const /* basisFn */, ___1170& numEdges, ___1170& numFacesOrEdges, ___1170& ___2787, ___1170& ___2819, ___1170& numHighOrderNodes, ___1170& numNaturalSubElems, NumCornersPerFaceOrEdgeItr numCornersPerFaceOrEdgeBegin, NumNodesPerFaceOrEdgeItr numNodesPerFaceOrEdgeBegin, NumHighOrderNodesPerFaceOrEdgeItr numHighOrderNodesPerFaceOrEdgeBegin) { REQUIRE(VALID_ENUM(shape, FECellShape_e)); REQUIRE(gridOrder > 0); switch (shape) { case FECellShape_Bar: { numEdges = 1; numFacesOrEdges = 1; ___2787 = 2; ___2819 = gridOrder + 1; numNaturalSubElems = gridOrder; std::fill_n(numCornersPerFaceOrEdgeBegin, numFacesOrEdges, 2); std::fill_n(numNodesPerFaceOrEdgeBegin, numFacesOrEdges, gridOrder + 1); } break; case FECellShape_Triangle: { numEdges = 3; numFacesOrEdges = 3; ___2787 = 3; ___2819 = triNumNodes(gridOrder); switch (gridOrder) { case 1: numNaturalSubElems = 1;  break; case 2: numNaturalSubElems = 4;  break; case 3: numNaturalSubElems = 9;  break; case 4: numNaturalSubElems = 16; break; default: ___476(___1303); break; } std::fill_n(numCornersPerFaceOrEdgeBegin, numFacesOrEdges, 2); std::fill_n(numNodesPerFaceOrEdgeBegin, numFacesOrEdges, gridOrder + 1); } break; case FECellShape_Quadrilateral: { numEdges = 4; numFacesOrEdges = 4; ___2787 = 4; ___2819 = quadNumNodes(gridOrder); switch (gridOrder) { case 1: numNaturalSubElems = 1;  break; case 2: numNaturalSubElems = 8;  break; case 3: numNaturalSubElems = 18; break; case 4: numNaturalSubElems = 32; break; default: ___476(___1303); break; } std::fill_n(numCornersPerFaceOrEdgeBegin, numFacesOrEdges, 2); std::fill_n(numNodesPerFaceOrEdgeBegin, numFacesOrEdges, gridOrder + 1); } break; case FECellShape_Tetrahedron: { numEdges = 6; numFacesOrEdges = 4; ___2787 = 4; ___2819 = gridOrder == 1 ? 4 : ((gridOrder + 1) * (gridOrder + 2) * (gridOrder + 3)) / 6; switch (gridOrder) { case 1: numNaturalSubElems = 1;  break; case 2: numNaturalSubElems = 8;  break; case 3: numNaturalSubElems = 27; break; case 4: numNaturalSubElems = 64; break; default: ___476(___1303); break; } std::fill_n(numCornersPerFaceOrEdgeBegin, numFacesOrEdges, 3); std::fill(numNodesPerFaceOrEdgeBegin, numNodesPerFaceOrEdgeBegin+numFacesOrEdges, triNumNodes(gridOrder)); } break; case FECellShape_Pyramid: { numEdges = 8; numFacesOrEdges = 5; ___2787 = 5; ___2819 = gridOrder == 1 ? 5 : ((gridOrder + 1) * (gridOrder + 2) * (2 * gridOrder + 3)) / 6; switch (gridOrder) { case 1: numNaturalSubElems = 1;   break; case 2: numNaturalSubElems = 16;  break;
case 3: numNaturalSubElems = 54;  break; case 4: numNaturalSubElems = 128; break; default: ___476(___1303); break; } ___1170 const numQuadFaces = 1; std::fill_n(numCornersPerFaceOrEdgeBegin, numQuadFaces, 4); ___1170 const numTriFaces = 4; std::fill_n(numCornersPerFaceOrEdgeBegin + numQuadFaces, numTriFaces, 3); *numNodesPerFaceOrEdgeBegin = quadNumNodes(gridOrder); std::fill(numNodesPerFaceOrEdgeBegin + 1, numNodesPerFaceOrEdgeBegin + numFacesOrEdges, triNumNodes(gridOrder)); } break; case FECellShape_Prism: { numEdges = 9; numFacesOrEdges = 5; ___2787 = 6; ___2819 = gridOrder == 1 ? 6 : ((gridOrder + 1) * (gridOrder + 1) * (gridOrder + 2)) / 2; switch (gridOrder) { case 1: numNaturalSubElems = 1;   break; case 2: numNaturalSubElems = 24;  break; case 3: numNaturalSubElems = 81;  break; case 4: numNaturalSubElems = 192; break; default: ___476(___1303); break; } ___1170 const numQuadFaces = 3; std::fill_n(numCornersPerFaceOrEdgeBegin, numQuadFaces, 4); ___1170 const numTriFaces = 2; std::fill_n(numCornersPerFaceOrEdgeBegin + numQuadFaces, numTriFaces, 3); std::fill(numNodesPerFaceOrEdgeBegin, numNodesPerFaceOrEdgeBegin + 3, quadNumNodes(gridOrder)); std::fill(numNodesPerFaceOrEdgeBegin + 3, numNodesPerFaceOrEdgeBegin + numFacesOrEdges, triNumNodes(gridOrder)); } break; case FECellShape_Hexahedron: { numEdges = 12; numFacesOrEdges = 6; ___2787 = 8; ___2819 = (gridOrder + 1) * (gridOrder + 1) * (gridOrder + 1); switch (gridOrder) { case 1: numNaturalSubElems = 1;   break; case 2: numNaturalSubElems = 40;  break; case 3: numNaturalSubElems = 162; break; case 4: numNaturalSubElems = 320; break; default: ___476(___1303); break; } std::fill_n(numCornersPerFaceOrEdgeBegin, numFacesOrEdges, 4); std::fill(numNodesPerFaceOrEdgeBegin, numNodesPerFaceOrEdgeBegin + numFacesOrEdges, quadNumNodes(gridOrder)); } break; default: ___476(___1303); numEdges = 0; numFacesOrEdges = 0; ___2787 = 0; ___2819 = 0; numHighOrderNodes = 0; numNaturalSubElems = 0; break; } numHighOrderNodes = ___2819 - ___2787; if (gridOrder > 1) { for (___1170 faceOrEdge = 0; faceOrEdge < numFacesOrEdges; ++faceOrEdge) *(numHighOrderNodesPerFaceOrEdgeBegin + faceOrEdge) = *(numNodesPerFaceOrEdgeBegin + faceOrEdge) - *(numCornersPerFaceOrEdgeBegin + faceOrEdge); } ENSURE(___2787 >= numFacesOrEdges); ENSURE(IMPLICATION(gridOrder == 1, ___2819 == ___2787)); ENSURE(IMPLICATION(gridOrder > 1, ___2819 > ___2787)); ENSURE(IMPLICATION(gridOrder == 1, numHighOrderNodes == 0)); ENSURE(IMPLICATION(gridOrder > 1, numHighOrderNodes > 0)); ENSURE(IMPLICATION(gridOrder == 1, numNaturalSubElems == 1)); ENSURE(IMPLICATION(gridOrder > 1, numNaturalSubElems > 1)); } }
