#include "ZoneVarMetadata.h"
#include "ThirdPartyHeadersBegin.h"
#include <cctype>
#include <new>
#include <sstream>
#include <boost/assign.hpp>
#include <boost/static_assert.hpp>
#include "ThirdPartyHeadersEnd.h"
#include "AltTecUtil.h"
#include "fileStuff.h"
#include "ItemSetIterator.h"
#include "zoneUtil.h"
namespace tecplot { namespace ___3931 { namespace { ___4633 varGetPrevSharedZone( ___4633           zone, ___4633           ___341, ___4349            ___4333, ___37&           ___36, ___4632 const& zoneShareConnectivityWithZone) { ___4633 prevSharedZone = ___36.___912(NULL, zone + 1, ___4333 + 1) - 1; if (prevSharedZone != NOT_SHARED) { if (___36.___4617(zone + 1) == ___4701) {
 #if !defined TECIOMPI 
if (___36.___4617((___4633)prevSharedZone + 1) == ___4701) { ___1842 ___4629; ___1842 sharedZoneIJK; ___36.___4612((___4633)(zone + 1), ___4629); ___36.___4612((___4633)(prevSharedZone + 1), sharedZoneIJK); if (___4629 != sharedZoneIJK) prevSharedZone = NOT_SHARED; }
 #endif
} else if (zoneShareConnectivityWithZone[zone - ___341] == NOT_SHARED) { prevSharedZone = NOT_SHARED; } } return prevSharedZone; } } ___4704::___4704() {} ___4704::___4704( ___37&      ___36, ItemSetIterator& varIter, ItemSetIterator& zoneIter, bool             allowSharingBetweenFiles  ) { BOOST_STATIC_ASSERT(static_cast<size_t>(END_ValueLocation_e) <= uint8_t(-1)); BOOST_STATIC_ASSERT(static_cast<size_t>(END_FieldDataType_e) <= uint8_t(-1)); if (!___36.___894()) return; m_numVars = varIter.___2810(); m_numZones = zoneIter.___2810(); if (!m_zoneNames.alloc(m_numZones) || !m_zoneTypes.alloc(m_numZones) || !m_zoneDimension.alloc(m_numZones) || !m_zoneFaceNeighborModes.alloc(m_numZones) || !m_zoneSolutionTimes.alloc(m_numZones) || !m_zoneStrandIDs.alloc(m_numZones) || !m_zoneParentZones.alloc(m_numZones) || !m_zoneIMaxOrNumNodes.alloc(m_numZones) || !m_zoneJMaxOrNumCells.alloc(m_numZones) || !m_zoneKMaxOrNumCorners.alloc(m_numZones) || !m_zoneShareConnectivityWithZone.alloc(m_numZones) || !m_varNames.alloc(m_numVars) || !___3354(m_vzMinMaxes, m_numVars, m_numZones) || !___3354(m_vzValueLocations, m_numVars, m_numZones) || !___3354(m_vzFieldDataTypes, m_numVars, m_numZones) || !___3354(m_vzIsPassive, m_numVars, m_numZones) || !___3354(m_vzShareVarWithZone, m_numVars, m_numZones) || !m_zoneNumSections.alloc(m_numZones, 0) || !m_zoneNumElemsPerSec.alloc(m_numZones) || !m_zoneCellShapePerSec.alloc(m_numZones) || !m_zoneGridOrderPerSec.alloc(m_numZones) || !m_zoneCellBasisFuncPerSec.alloc(m_numZones)) { throw std::bad_alloc(); } std::map<ZoneType_e, char> zoneTypeMap = boost::assign::map_list_of<ZoneType_e, char> (___4701, ___4702) (___4699, ZONETYPE_FETRIANGLE_CHAR) (___4697, ZONETYPE_FEQUAD_CHAR) (___4698, ZONETYPE_FETETRA_CHAR) (___4692, ZONETYPE_FEBRICK_CHAR) (___4693, ZONETYPE_FELINESEG_CHAR) (___4695, ZONETYPE_FEPOLYGON_CHAR) (___4696, ZONETYPE_FEPOLYHEDRON_CHAR) (ZoneType_FEMixed, ZONETYPE_FEMIXED_CHAR); ___4262 const datasetID = ___36.datasetGetUniqueID(); zoneIter.reset(); ___4633 ___341 = zoneIter.baseItem(); while (zoneIter.hasNext()) { ___4633 const ___902 = zoneIter.next(); ___4633 const fileZone = ___902 - ___341; if (!___36.___4635(___902 + 1)) continue; char *zoneName = NULL; if (___36.___4613(___902 + 1, &zoneName)) { m_zoneNames[fileZone] = zoneName; ___36.___3815(&zoneName); } else { throw std::bad_alloc(); } m_zoneFaceNeighborModes[fileZone] = static_cast<uint8_t>(___36.___834(___902 + 1)); ___1842 ___4629; ___36.___4612(___902 + 1, ___4629); ZoneType_e const ___4689 = ___36.___4617(___902 + 1); m_zoneTypes[fileZone] = zoneTypeMap[___4689]; m_zoneDimension[fileZone] = ___36.zoneGetDimension( ___36.datasetGetUniqueID(), ___902 + 1);
if (___3893(___4689, m_zoneDimension[fileZone])) m_zoneTypes[fileZone] = static_cast<char>(std::toupper(m_zoneTypes[fileZone])); if (___4689 == ZoneType_FEMixed) { ___1170 numSections = 0; if (!___36.zoneGetNumSections(datasetID, ___902 + 1, &numSections)) throw std::runtime_error("failed to get zone section information"); m_zoneNumSections[fileZone] = checked_numeric_cast<uint8_t>(numSections); if (!m_zoneNumElemsPerSec[fileZone].alloc(numSections)  || !m_zoneCellShapePerSec[fileZone].alloc(numSections) || !m_zoneGridOrderPerSec[fileZone].alloc(numSections) || !m_zoneCellBasisFuncPerSec[fileZone].alloc(numSections)) { throw std::bad_alloc(); } for (___1170 section = 0; section < numSections; ++section) { FECellShape_e         cellShape = FECellShape_Invalid; ___1170            gridOrder = 0; FECellBasisFunction_e basisFn = FECellBasisFunction_Lagrangian; ___2225             numElements = 0; ___1170            numCornersPerElem = 0; ___1170            numNodesPerElem = 0; if (!___36.zoneGetSectionMetrics( datasetID, ___902+1, section+1, &cellShape, &gridOrder, &basisFn, &numElements, &numCornersPerElem, &numNodesPerElem)) { throw std::runtime_error("failed to get zone section information"); } m_zoneNumElemsPerSec[fileZone][section] = numElements; m_zoneCellShapePerSec[fileZone][section] = checked_numeric_cast<uint8_t>(cellShape); m_zoneGridOrderPerSec[fileZone][section] = checked_numeric_cast<uint8_t>(gridOrder); m_zoneCellBasisFuncPerSec[fileZone][section] = checked_numeric_cast<uint8_t>(basisFn); } } m_zoneSolutionTimes[fileZone] = ___36.___4615(___902 + 1); m_zoneStrandIDs[fileZone] = ___36.___4616(___902 + 1); ___4633 ___2972 = ___36.___4614(___902 + 1) - 1; ___476(___2972 == -1 || ___2972 >= ___341); m_zoneParentZones[fileZone] = ___2972 == -1 ? ___2972 : ___2972 - ___341; if (___4689 == ___4701) { m_zoneIMaxOrNumNodes[fileZone]   = ___4629.i(); m_zoneJMaxOrNumCells[fileZone]   = ___4629.___2103(); m_zoneKMaxOrNumCorners[fileZone] = ___4629.___2132(); } else { m_zoneIMaxOrNumNodes[fileZone] = ___4629.___1668(); m_zoneJMaxOrNumCells[fileZone] = ___4629.___1666(); if (___3156(___4689)) m_zoneKMaxOrNumCorners[fileZone] = ___4629.___2132(); else if (___4689 == ZoneType_FEMixed) m_zoneKMaxOrNumCorners[fileZone] = 0; else m_zoneKMaxOrNumCorners[fileZone] = ___4629.___1667(); } ___4633 const prevSharedZone = ___36.___542(NULL, ___902 + 1) - 1; if (prevSharedZone == NOT_SHARED) m_zoneShareConnectivityWithZone[fileZone] = NOT_SHARED; else if (prevSharedZone < ___341) m_zoneShareConnectivityWithZone[fileZone] = (allowSharingBetweenFiles ? prevSharedZone : NOT_SHARED); else if (m_zoneShareConnectivityWithZone[prevSharedZone - ___341] == NOT_SHARED) m_zoneShareConnectivityWithZone[fileZone] = prevSharedZone - ___341; else m_zoneShareConnectivityWithZone[fileZone] = m_zoneShareConnectivityWithZone[prevSharedZone - ___341];
___476(IMPLICATION(!allowSharingBetweenFiles, m_zoneShareConnectivityWithZone[fileZone] == NOT_SHARED || m_zoneShareConnectivityWithZone[m_zoneShareConnectivityWithZone[fileZone]] == NOT_SHARED)); } varIter.reset(); ___4349 const baseVar = varIter.baseItem(); while (varIter.hasNext()) { ___4349 const datasetVar = varIter.next(); ___4349 const fileVar = datasetVar - baseVar; char* ___4359 = NULL; if (___36.___4341(datasetVar+1, &___4359)) { m_varNames[fileVar] = ___4359; ___36.___3815(&___4359); } else { throw std::bad_alloc(); } } varIter.reset(); while (varIter.hasNext()) { ___4349 const datasetVar = varIter.next(); ___4349 const fileVar = datasetVar - baseVar; zoneIter.reset(); ___341 = zoneIter.baseItem(); while (zoneIter.hasNext()) { ___4633 const ___902 = zoneIter.next(); ___4633 const fileZone = ___902 - ___341; if (!___36.___4635(___902 + 1)) continue; ValueLocation_e ___4323 = ___36.___908(___902 + 1, datasetVar + 1); m_vzValueLocations[fileVar][fileZone] = static_cast<uint8_t>(___4323); FieldDataType_e ___1361 = ___36.___921(___902+1,datasetVar+1); m_vzFieldDataTypes[fileVar][fileZone] = static_cast<uint8_t>(___1361); ___372 varIsPassive = ___36.___924(___902 + 1, datasetVar + 1); m_vzIsPassive[fileVar][fileZone] = (varIsPassive ? 1 : 0); ___4633 const prevSharedZone = varGetPrevSharedZone( ___902, ___341, datasetVar, ___36, m_zoneShareConnectivityWithZone); if (prevSharedZone == NOT_SHARED) m_vzShareVarWithZone[fileVar][fileZone] = NOT_SHARED; else if (prevSharedZone < ___341) m_vzShareVarWithZone[fileVar][fileZone] = (allowSharingBetweenFiles ? prevSharedZone : NOT_SHARED); else if (m_vzShareVarWithZone[fileVar][prevSharedZone - ___341] == NOT_SHARED) m_vzShareVarWithZone[fileVar][fileZone] = prevSharedZone - ___341; else m_vzShareVarWithZone[fileVar][fileZone] = m_vzShareVarWithZone[fileVar][prevSharedZone - ___341]; if (prevSharedZone >= ___341) { m_vzMinMaxes[fileVar][fileZone] = m_vzMinMaxes[fileVar][prevSharedZone - ___341]; } else { double minValue; double maxValue; ___36.___911(___902 + 1, datasetVar + 1, &minValue, &maxValue); m_vzMinMaxes[fileVar][fileZone] = ___2477(minValue, maxValue); }
 #if !defined TECIOMPI 
___476(IMPLICATION(!allowSharingBetweenFiles, m_vzShareVarWithZone[fileVar][fileZone] == NOT_SHARED || m_vzShareVarWithZone[fileVar][m_vzShareVarWithZone[fileVar][fileZone]] == NOT_SHARED));
 #endif
} } } bool ___4704::alloc(size_t ___2844, size_t ___2841, std::vector<uint8_t> const& zoneNumSections) { REQUIRE(___2844 > 0); REQUIRE(___2841 > 0); m_numZones = ___2844; m_numVars = ___2841; bool ___3356 = m_zoneNames.alloc(___2844) && m_zoneTypes.alloc(___2844) && m_zoneDimension.alloc(m_numZones) && m_zoneFaceNeighborModes.alloc(___2844) && m_zoneSolutionTimes.alloc(___2844) && m_zoneStrandIDs.alloc(___2844) && m_zoneParentZones.alloc(___2844) && m_zoneIMaxOrNumNodes.alloc(___2844) && m_zoneJMaxOrNumCells.alloc(___2844) && m_zoneKMaxOrNumCorners.alloc(___2844) && m_zoneShareConnectivityWithZone.alloc(___2844) && m_varNames.alloc(___2841) && m_vzMinMaxes.alloc(___2841) && m_vzValueLocations.alloc(___2841) && m_vzFieldDataTypes.alloc(___2841) && m_vzIsPassive.alloc(___2841) && m_vzShareVarWithZone.alloc(___2841) && m_zoneNumSections.alloc(m_numZones) && m_zoneNumElemsPerSec.alloc(m_numZones) && m_zoneCellShapePerSec.alloc(m_numZones) && m_zoneGridOrderPerSec.alloc(m_numZones) && m_zoneCellBasisFuncPerSec.alloc(m_numZones); for (size_t ___4333 = 0; ___3356 && ___4333 < ___2841; ++___4333) { ___3356 = m_vzMinMaxes[___4333].alloc(___2844) && m_vzValueLocations[___4333].alloc(___2844) && m_vzFieldDataTypes[___4333].alloc(___2844) && m_vzIsPassive[___4333].alloc(___2844) && m_vzShareVarWithZone[___4333].alloc(___2844); } for (size_t zone = 0; ___3356 && zone < ___2844; ++zone) { m_zoneNumElemsPerSec[zone].alloc(zoneNumSections[zone]); m_zoneCellShapePerSec[zone].alloc(zoneNumSections[zone]); m_zoneGridOrderPerSec[zone].alloc(zoneNumSections[zone]); m_zoneCellBasisFuncPerSec[zone].alloc(zoneNumSections[zone]); } return ___3356; } bool ___4704::assign(___4704 const& ___2886, size_t zoneOffset) { REQUIRE(___2886.m_numZones + zoneOffset <= m_numZones); REQUIRE(___2886.m_numVars == m_numVars); try { for (size_t ___4333 = 0; ___4333 < ___2886.m_numVars; ++___4333) m_varNames[___4333] = ___2886.m_varNames[___4333]; for (size_t zone = 0; zone < ___2886.m_numZones; ++zone) { m_zoneNames                    [zoneOffset + zone] = ___2886.m_zoneNames[zone]; m_zoneTypes                    [zoneOffset + zone] = ___2886.m_zoneTypes[zone]; m_zoneDimension                [zoneOffset + zone] = ___2886.m_zoneDimension[zone]; m_zoneFaceNeighborModes        [zoneOffset + zone] = ___2886.m_zoneFaceNeighborModes[zone]; m_zoneSolutionTimes            [zoneOffset + zone] = ___2886.m_zoneSolutionTimes[zone]; m_zoneStrandIDs                [zoneOffset + zone] = ___2886.m_zoneStrandIDs[zone]; m_zoneParentZones              [zoneOffset + zone] = ___2886.m_zoneParentZones[zone]; m_zoneIMaxOrNumNodes           [zoneOffset + zone] = ___2886.m_zoneIMaxOrNumNodes[zone]; m_zoneJMaxOrNumCells           [zoneOffset + zone] = ___2886.m_zoneJMaxOrNumCells[zone]; m_zoneKMaxOrNumCorners         [zoneOffset + zone] = ___2886.m_zoneKMaxOrNumCorners[zone]; m_zoneShareConnectivityWithZone[zoneOffset + zone] = ___2886.m_zoneShareConnectivityWithZone[zone]; m_zoneNumSections              [zoneOffset + zone] = ___2886.m_zoneNumSections[zone]; for (size_t ___4333 = 0; ___4333 < ___2886.m_numVars; ++___4333)
{ m_vzMinMaxes        [___4333][zoneOffset + zone] = ___2886.m_vzMinMaxes[___4333][zone]; m_vzValueLocations  [___4333][zoneOffset + zone] = ___2886.m_vzValueLocations[___4333][zone]; m_vzFieldDataTypes  [___4333][zoneOffset + zone] = ___2886.m_vzFieldDataTypes[___4333][zone]; m_vzIsPassive       [___4333][zoneOffset + zone] = ___2886.m_vzIsPassive[___4333][zone]; m_vzShareVarWithZone[___4333][zoneOffset + zone] = ___2886.m_vzShareVarWithZone[___4333][zone]; } ___476(m_zoneNumElemsPerSec[zoneOffset + zone].size() == ___2886.m_zoneNumSections[zone]); ___476(m_zoneCellShapePerSec[zoneOffset + zone].size() == ___2886.m_zoneNumSections[zone]); ___476(m_zoneGridOrderPerSec[zoneOffset + zone].size() == ___2886.m_zoneNumSections[zone]); ___476(m_zoneCellBasisFuncPerSec[zoneOffset + zone].size() == ___2886.m_zoneNumSections[zone]); for (uint8_t section = 0; section < ___2886.m_zoneNumSections[zone]; ++section) { m_zoneNumElemsPerSec     [zoneOffset + zone][section] = ___2886.m_zoneNumElemsPerSec[zone][section]; m_zoneCellShapePerSec    [zoneOffset + zone][section] = ___2886.m_zoneCellShapePerSec[zone][section]; m_zoneGridOrderPerSec    [zoneOffset + zone][section] = ___2886.m_zoneGridOrderPerSec[zone][section]; m_zoneCellBasisFuncPerSec[zoneOffset + zone][section] = ___2886.m_zoneCellBasisFuncPerSec[zone][section]; } } } catch (std::bad_alloc const&) { return false; } return true; } }}
