 #pragma once
#include "ThirdPartyHeadersBegin.h"
#include <utility>
#include "ThirdPartyHeadersEnd.h"
#include "SzlFileLoader.h"
#include "AltTecUtil.h"
#include "FieldData.h"
namespace tecplot { namespace ___3931 { class OrthogonalBisection { UNCOPYABLE_CLASS(OrthogonalBisection); public: enum BisectionType_e { BisectionType_ZoneCells, BisectionType_ZoneNodes }; BisectionType_e bisectionType() const; private: static ___4349 const NUM_BISECTION_DIRECTIONS = 3; static ItemAddress64::SubzoneOffset_t const  MAX_THREADS_PER_CORE = 4; static ___81 const MIN_THREADED_ITEM_RANGE_SIZE = 256; static ___81 const MIN_THREADED_SUBZONE_RANGE_SIZE = 1; ___4633 const                    ___2675; ItemAddress64::SectionOffset_t const m_section; BisectionType_e const                m_bisectionType; ItemAddress64::ItemOffset_t const    m_maxDomainSize; ItemAddress64::SubzoneOffset_t m_maxThreadedJobs; ItemAddress64::SubzoneOffset_t m_maxRecursion; ___81                     m_baseItem; ___81                     m_numItems; ___81                     m_numGhostItems; ItemAddress64::SubzoneOffset_t m_numRecursionDepths; ItemAddress64::SubzoneOffset_t m_numDomains; ___2238<___81>   m_itemList; ZoneType_e                      ___2682; ___2238<FieldDataPtr> m_nodalFieldDataPtrs; ___2238<FieldDataPtr> m_ccFieldDataPtrs; ___2238<UInt8Array>   m_reducedPrecisionSortDataArrays; public: OrthogonalBisection( ___4633                    zone, ItemAddress64::SectionOffset_t section, BisectionType_e                bisectionType, ItemAddress64::ItemOffset_t    maxDomainSize); ~OrthogonalBisection(); ___372 performBisection(___37& ___36); ___372 getSzCoordByOriginalItemArray( ___37&               ___36, ItemAddressArray& szCoordsOfOriginalItems); ___81 queryBaseItem() const { return m_baseItem; } ___81 queryNumItems() const { return m_numItems; } ___81 queryNumGhostItems() const { return m_numGhostItems; } ___81 queryPositionbyOffset(___81 ___2863) const { return m_itemList[___2863]; } ItemAddress64::SubzoneOffset_t queryNumberDomains() const { return m_numDomains; } inline ItemAddress64::ItemOffset_t getDomainSize(ItemAddress64::SubzoneOffset_t domain) const { REQUIRE(domain<m_numDomains); ItemAddress64::ItemOffset_t domainSize; if ( domain < m_numDomains-1 ) domainSize = m_maxDomainSize; else { domainSize = ( m_numItems % m_maxDomainSize ); if ( domainSize == 0 ) domainSize = m_maxDomainSize; ___476(m_maxDomainSize*(m_numDomains-1) + domainSize == m_numItems); } ENSURE(domainSize > 0 && domainSize <= ItemAddress64::MAX_ITEM_OFFSET+1); return domainSize; } void ___935(void); private: ___372 updateStatusLine( ___37&                    ___36, ItemAddress64::SubzoneOffset_t recursionDepth); ___372 loadCoordinateVarZoneFieldData(___37& ___36, char axis); inline void getJobStartEndForRange( ___81                     rangeStart, ___81                     ___3266, ItemAddress64::SubzoneOffset_t ___2116, ItemAddress64::SubzoneOffset_t numJobs, ___81&                    jobStart, ___81&                    jobEnd)
{ REQUIRE(IMPLICATION(m_numItems > 0, rangeStart < m_numItems)); REQUIRE(IMPLICATION(m_numItems > 0, ___3266 > 0 && rangeStart+___3266 <= m_numItems)); REQUIRE(___2116 < numJobs); REQUIRE(numJobs > 0); jobStart = ___81( rangeStart + (uint64_t(___3266)*___2116)/numJobs ); jobEnd = ___81( rangeStart + (uint64_t(___3266)*(___2116+1))/numJobs ); ENSURE(IMPLICATION(m_numItems > 0, rangeStart<=jobStart && jobStart<jobEnd && jobEnd<=m_numItems)); ENSURE(IMPLICATION(___2116==0, jobStart==rangeStart)); ENSURE(IMPLICATION(___2116==numJobs-1, jobEnd==rangeStart+___3266)); } void getMinMaxWeightOverRange( ___81                     rangeStart, ___81                     rangeEnd, ItemAddress64::SubzoneOffset_t ___2116, ItemAddress64::SubzoneOffset_t numJobs, ___4349                     axisDirToSplit, ___2477&                        weightMinMax); void rescaleWeightsOverRange( ___81                     rangeStart, ___81                     ___3266, ItemAddress64::SubzoneOffset_t ___2116, ItemAddress64::SubzoneOffset_t numJobs, ___4349                     axisDirToSplit, double                         scale, double                         ___2863); ___372 calcReducedPrecisionValues( ___37&                          ___36, ___81 const                     domainStart, ___81 const                     domainSize, ___4349 const                     axisDirToSplit, ItemAddress64::SubzoneOffset_t const recursionDepth); ___372 splitDomain( ___37&                          ___36, ___81 const                     domainStart, ___81 const                     domainSize, ___4349 const                     axisDirToSplit, ItemAddress64::SubzoneOffset_t const recursionDepth, ___2118                        ___2117); void getSzCoordsByRange( ___81                     rangeStart, ___81                     ___3266, ItemAddress64::SubzoneOffset_t ___2116, ItemAddress64::SubzoneOffset_t numJobs, ItemAddressArray&              szCoordArray); ItemAddress64::SubzoneOffset_t calcNumDomains() const { return ItemAddress64::SubzoneOffset_t((m_numItems+m_maxDomainSize-1)/m_maxDomainSize); } void getSubdomainInfo( ___81  domainStart, ___81  domainSize, ___81& leftOffset, ___81& leftSize, ___81& rightOffset, ___81& rightSize) const { REQUIRE(domainSize>0); INVARIANT(m_maxDomainSize>0); ___81 localDomainSplitSize = m_maxDomainSize; while ( localDomainSplitSize < (domainSize+1)/2 ) { localDomainSplitSize *= 2; ___476(localDomainSplitSize>0); } ___476(localDomainSplitSize<domainSize && domainSize<=2*int64_t(localDomainSplitSize)); leftOffset = domainStart; leftSize =  localDomainSplitSize * ___81( (domainSize+int64_t(localDomainSplitSize)*2-1) / (int64_t(localDomainSplitSize)*2) ); rightOffset = domainStart + leftSize; rightSize   = domainSize - leftSize; ENSURE(leftSize>=localDomainSplitSize && leftSize < domainSize); ENSURE(leftSize>=localDomainSplitSize && rightSize < domainSize);
} ItemAddress64::SubzoneOffset_t calcNumRecursionDepths() const { ItemAddress64::SubzoneOffset_t numRecursionDepths = 0; ___81 largestDomainOffset = 0; ___81 largestDomainSize = m_numItems; while ( largestDomainSize > m_maxDomainSize ) { ___81 leftOffset; ___81 leftSize; ___81 rightOffset; ___81 rightSize; getSubdomainInfo(largestDomainOffset, largestDomainSize, leftOffset, leftSize, rightOffset, rightSize); if ( leftSize >= rightSize ) { largestDomainSize = leftSize; largestDomainOffset = leftOffset; } else { largestDomainSize = rightSize; largestDomainOffset = rightOffset; } numRecursionDepths++; } return numRecursionDepths; } }; std::pair<___81,___81> bisectionSize( ___37 const&                    ___36, ___4633                          zone, ItemAddress64::SectionOffset_t       section, ZoneType_e                           ___4689, OrthogonalBisection::BisectionType_e bisectionType); }}
