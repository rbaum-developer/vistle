#include "ZoneInfoCache.h"
#include "ThirdPartyHeadersBegin.h"
#include <functional>
#include <boost/foreach.hpp>
#include <boost/make_shared.hpp>
#include "ThirdPartyHeadersEnd.h"
#include "FEZoneInfo.h"
#include "IJKZoneInfo.h"
#include "ItemSetIterator.h"
#include "OrbFESubzonePartitioner.h"
#include "NoOpFESubzonePartitioner.h"
#include "PartitionTecUtilDecorator.h"
#include "zoneUtil.h"
namespace tecplot { namespace ___3931 { ZoneInfoCache::ZoneInfoCache( ___37*                 ___36, ___1842 const&                  maxIJKSubzoneSize, ItemAddress64::ItemOffset_t feSubzoneSize) : ___2335(___36) , m_maxIJKSubzoneSize(maxIJKSubzoneSize) , m_feSubzoneSize(feSubzoneSize) {} template<typename ZoneInfoType> void ZoneInfoCache::storeForSharedZones( boost::unordered_map<___4633, boost::shared_ptr<ZoneInfoType> >& zoneInfos, boost::shared_ptr<ZoneInfoType>                                      zoneInfo, ___4633                                                          zone) { ___3499 sharedZoneSet = ___2335->___543(zone + 1); if (sharedZoneSet) { for (___3491 sharedZone = ___2335->___3489(sharedZoneSet, zone + 1); sharedZone != 0; sharedZone = ___2335->___3489(sharedZoneSet, sharedZone)) { zoneInfos[static_cast<___4633>(sharedZone - 1)] = zoneInfo; } ___2335->___3482(&sharedZoneSet); } } template <typename ZoneInfoType> void ZoneInfoCache::storeForSharedPartitions( boost::unordered_map<___4633, boost::unordered_map<___4633, boost::shared_ptr<ZoneInfoType> > >& zoneInfos, boost::shared_ptr<ZoneInfoType> zoneInfo, ___4633 zone, ___4633 ___2975) { ___3499 sharedZoneSet = ___2335->___543(zone + 1); if (sharedZoneSet) { for (___3491 sharedZone = ___2335->___3489(sharedZoneSet, zone + 1); sharedZone != ___4037; sharedZone = ___2335->___3489(sharedZoneSet, sharedZone)) { zoneInfos[static_cast<___4633>(sharedZone - 1)][___2975] = zoneInfo; } ___2335->___3482(&sharedZoneSet); } } boost::shared_ptr<___1879> ZoneInfoCache::getIJKZoneInfo(___4633 zone) { REQUIRE(___4638(*___2335, zone) && !zoneIsPartitioned(*___2335, zone)); boost::shared_ptr<___1879> zoneInfo = m_ijkZoneInfos[zone]; if (!zoneInfo) { ___1842 ___4630; ___2335->___4612(zone + 1, ___4630); zoneInfo = boost::make_shared<___1879>(___4630, m_maxIJKSubzoneSize, DEFAULT_MINIMIZE_IJK_NUM_SUBZONES); m_ijkZoneInfos[zone] = zoneInfo; storeForSharedZones(m_ijkZoneInfos, zoneInfo, zone); } zoneInfo->resetNeighborInfo(); return zoneInfo; } boost::shared_ptr<___1879> ZoneInfoCache::getIJKZonePartitionInfo( ___4633 zone, ___4633 ___2975) { REQUIRE(0 <= zone && ___2335->___4635(zone + 1)); REQUIRE(___4638(*___2335, zone) && zoneIsPartitioned(*___2335, zone)); REQUIRE(0 <= ___2975 && ___2975 < ___2335->zoneGetNumPartitions(zone + 1)); boost::shared_ptr<___1879> zoneInfo = m_ijkZonePartitionInfos[zone][___2975]; if (!zoneInfo) { ___1842 ___1841; ___2335->zonePartitionGetIJK(zone + 1, ___2975 + 1, ___1841); ___1842 partitionOffset; ___2335->zonePartitionGetIJKOffset(zone + 1, ___2975 + 1, partitionOffset); ___1842 partitionMaxCorner = ___1841 + partitionOffset; ___1842 ___4629; ___2335->___4612(zone + 1, ___4629); zoneInfo = boost::make_shared<___1879>
(___1841, m_maxIJKSubzoneSize, ___2975, true, partitionMaxCorner.i() == ___4629.i(), partitionMaxCorner.___2103() == ___4629.___2103(), partitionMaxCorner.___2132() == ___4629.___2132()); m_ijkZonePartitionInfos[zone][___2975] = zoneInfo; storeForSharedPartitions(m_ijkZonePartitionInfos, zoneInfo, zone, ___2975); } zoneInfo->resetNeighborInfo(); return zoneInfo; } namespace { typedef std::function<___372( ___4262             dataSetID, ___4633            ___4655, ___4633            partitionNum, ___1170             section, FECellShape_e*         cellShape, ___1170*            gridOrder, FECellBasisFunction_e* basisFn, ___2225*             numElements, ___1170*            numNodesPerElem, ___1170*            numCornersPerElem) > GetSectionMetrics; } namespace { void zoneGetAllSectionMetrics( GetSectionMetrics const&            getSectionMetrics, ___37 const&                   ___36, ___1170                          zone, ___1170                          ___2975, ___1170                          numSections, std::vector<FECellShape_e>&         cellShape, std::vector<___1170>&            gridOrder, std::vector<FECellBasisFunction_e>& basisFn, std::vector<___2225>&             numElements, std::vector<CellNodeIndex_t>&       numLinearNodesPerCell, std::vector<CellNodeIndex_t>&       numHighOrderNodesPerCell) { REQUIRE(getSectionMetrics); REQUIRE(1 <= numSections && numSections <= checked_numeric_cast<___1170>(MAX_NUM_SECTIONS)); ___4262 const datasetID = ___36.datasetGetUniqueID(); cellShape.resize(numSections); gridOrder.resize(numSections); basisFn.resize(numSections); numElements.resize(numSections); numLinearNodesPerCell.resize(numSections); numHighOrderNodesPerCell.resize(numSections); ___1170 numNodesPerElem{0}; for (___1170 section = 0; section < numSections; ++section) { if (!getSectionMetrics(datasetID, zone + 1, ___2975 + 1, section + 1, &cellShape[section], &gridOrder[section], &basisFn[section], &numElements[section], &numLinearNodesPerCell[section], &numNodesPerElem)) throw std::runtime_error("failed to get zone section information"); numHighOrderNodesPerCell[section] = numNodesPerElem - numLinearNodesPerCell[section]; } } } boost::shared_ptr<___1348> ZoneInfoCache::getFEZoneInfo(___4633 zone) { REQUIRE(0 <= zone && ___2335->___4635(zone + 1)); REQUIRE(!___4638(*___2335, zone) && !___4640(*___2335, zone) && !zoneIsPartitioned(*___2335, zone)); boost::shared_ptr<___1348> zoneInfo = m_feZoneInfos[zone]; if (!zoneInfo) { ___1842 ___1841; ___2335->___4612(zone + 1, ___1841); ___2716 const ___2819 = static_cast<___2716>(___1841.i()); ___1170 numSections = 1; if (___2335->___4617(zone + 1) == ZoneType_FEMixed) { ___4262 const datasetID = ___2335->datasetGetUniqueID(); if (!___2335->zoneGetNumSections(datasetID, zone + 1, &numSections)) throw std::runtime_error("failed to get zone section information"); } std::vector<FECellShape_e>         cellShape;
std::vector<___1170>            gridOrder; std::vector<FECellBasisFunction_e> basisFn; std::vector<___2225>             numElements; std::vector<CellNodeIndex_t>       numLinearNodesPerCell; std::vector<CellNodeIndex_t>       numHighOrderNodesPerCell; using namespace std::placeholders; zoneGetAllSectionMetrics(std::bind(&___37::zoneGetSectionMetrics, ___2335, _1, _2, _4, _5, _6, _7, _8, _9, _10), *___2335, zone, 0 , numSections, cellShape, gridOrder, basisFn, numElements, numLinearNodesPerCell, numHighOrderNodesPerCell); bool isSubzonedZoneType = ___3892(___2335->___4617(zone + 1), ___2335->zoneGetDimension(___2335->datasetGetUniqueID(),zone + 1)); boost::shared_ptr<FESubzonePartitionerInterface> nszPartitioner; if (isSubzonedZoneType) nszPartitioner = boost::make_shared<OrbFESubzonePartitioner>( std::ref(*___2335), zone, 0 , OrthogonalBisection::BisectionType_ZoneNodes, m_feSubzoneSize); else nszPartitioner = boost::make_shared<NoOpFESubzonePartitioner>( std::ref(*___2335), zone, 0 , OrthogonalBisection::BisectionType_ZoneNodes); std::vector<boost::shared_ptr<FESubzonePartitionerInterface> > secCszPartitioners; secCszPartitioners.reserve(numSections); for (___1170 section = 0; section < numSections; ++section) { if (isSubzonedZoneType) secCszPartitioners.push_back(boost::make_shared<OrbFESubzonePartitioner>( std::ref(*___2335), zone, section, OrthogonalBisection::BisectionType_ZoneCells, m_feSubzoneSize)); else secCszPartitioners.push_back(boost::make_shared<NoOpFESubzonePartitioner>( std::ref(*___2335), zone, section, OrthogonalBisection::BisectionType_ZoneCells)); } zoneInfo = boost::make_shared<___1348>( ___2819, numLinearNodesPerCell, numHighOrderNodesPerCell, nszPartitioner, secCszPartitioners, checked_numeric_cast<ItemAddress64::___2978>(zone)); m_feZoneInfos[zone] = zoneInfo; storeForSharedZones(m_feZoneInfos, zoneInfo, zone); } zoneInfo->resetNeighborInfo(); return zoneInfo; } boost::shared_ptr<___1348> ZoneInfoCache::getFEZonePartitionInfo( ___4633 zone, ___4633 ___2975, PartitionTecUtilDecorator& partitionTecUtilDecorator) { REQUIRE(0 <= zone && ___2335->___4635(zone + 1)); REQUIRE(!___4638(*___2335, zone) && !___4640(*___2335, zone) && zoneIsPartitioned(*___2335, zone)); REQUIRE(0 <= ___2975 && ___2975 < ___2335->zoneGetNumPartitions(zone + 1)); boost::shared_ptr<___1348> zoneInfo = m_feZonePartitionInfos[zone][___2975]; if (!zoneInfo) { ___1842 ___1841; ___2335->zonePartitionGetIJK(zone + 1, ___2975 + 1, ___1841); ___2716 ___2819 = static_cast<___2716>(___1841.i()); ___1170 numSections = 1; if (___2335->___4617(zone + 1) == ZoneType_FEMixed) { ___4262 const datasetID = ___2335->datasetGetUniqueID(); if (!___2335->zoneGetNumSections(datasetID, zone + 1, &numSections)) throw std::runtime_error("failed to get zone section information"); } std::vector<___463> secNumGhostCells(numSections, 0);
GhostInfo_pa ghostCellInfo = ___2335->zonePartitionGhostCellInfoGetRef(zone + 1, ___2975 + 1); if (ghostCellInfo) { for (___1170 section = 0; section < numSections; ++section) secNumGhostCells[section] = static_cast<___463>( ___2335->ghostInfoGetNumItemsByRef(ghostCellInfo, section+1)); } ___2716 numGhostNodes = 0; GhostInfo_pa ghostNodeInfo = ___2335->zonePartitionGhostNodeInfoGetRef(zone + 1, ___2975 + 1); if (ghostNodeInfo) numGhostNodes = static_cast<___463>(___2335->ghostInfoGetNumItemsByRef(ghostNodeInfo, 1 )); std::vector<FECellShape_e>         cellShape; std::vector<___1170>            gridOrder; std::vector<FECellBasisFunction_e> basisFn; std::vector<___2225>             numElements; std::vector<CellNodeIndex_t>       numLinearNodesPerCell; std::vector<CellNodeIndex_t>       numHighOrderNodesPerCell; using namespace std::placeholders; zoneGetAllSectionMetrics(std::bind(&___37::zonePartitionGetSectionMetrics, ___2335, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10), *___2335, zone, ___2975, numSections, cellShape, gridOrder, basisFn, numElements, numLinearNodesPerCell, numHighOrderNodesPerCell); boost::shared_ptr<FESubzonePartitionerInterface> nszPartitioner = boost::make_shared<OrbFESubzonePartitioner>( std::ref(partitionTecUtilDecorator), ___2975, 0 , OrthogonalBisection::BisectionType_ZoneNodes, m_feSubzoneSize); std::vector<boost::shared_ptr<FESubzonePartitionerInterface> > secCszPartitioners; secCszPartitioners.reserve(numSections); for (___1170 section = 0; section < numSections; ++section) secCszPartitioners.push_back(boost::make_shared<OrbFESubzonePartitioner>( std::ref(partitionTecUtilDecorator), ___2975, section, OrthogonalBisection::BisectionType_ZoneCells, m_feSubzoneSize)); zoneInfo = boost::make_shared<___1348>( ___2819, numLinearNodesPerCell, numHighOrderNodesPerCell, nszPartitioner, secCszPartitioners, checked_numeric_cast<ItemAddress64::___2978>(___2975), secNumGhostCells, numGhostNodes); m_feZonePartitionInfos[zone][___2975] = zoneInfo; storeForSharedPartitions(m_feZonePartitionInfos, zoneInfo, zone, ___2975); } zoneInfo->resetNeighborInfo(); return zoneInfo; } void ZoneInfoCache::remove(___4633 zone) { m_ijkZoneInfos.erase(zone); m_feZoneInfos.erase(zone); m_ijkZonePartitionInfos.erase(zone); m_feZonePartitionInfos.erase(zone); } void ZoneInfoCache::clear() { m_ijkZoneInfos.clear(); m_feZoneInfos.clear(); m_ijkZonePartitionInfos.clear(); m_feZonePartitionInfos.clear(); } template <typename MapType> void shareZoneInfosInMap(___3499 zonesToWrite, MapType& map, ___37& tecUtil) { REQUIRE(VALID_REF(zonesToWrite)); if (!map.empty()) { ___3499 cachedZoneSet = tecUtil.setAlloc(___1303); BOOST_FOREACH(typename MapType::value_type const& zoneIndexAndZoneInfoPair, map) tecUtil.setAddMember(cachedZoneSet, zoneIndexAndZoneInfoPair.first + 1, ___1303); ___3491 zone; for (zone = tecUtil.___3489(zonesToWrite, ___4037); zone != ___4037;
zone = tecUtil.___3489(zonesToWrite, zone)) { ___4633 sharedZone = (___4633)tecUtil.___542(cachedZoneSet, (___4633)zone); if (sharedZone != ___4033) map[(___4633)zone - 1] = map[sharedZone - 1]; } tecUtil.___3482(&cachedZoneSet); } } template <typename MapType> void shareZonePartitionInfosInMap(___3499 zonesToWrite, MapType& map, ___37& tecUtil) { if (!map.empty()) { ___3499 cachedZoneSet = tecUtil.setAlloc(___1303); BOOST_FOREACH(typename MapType::value_type const& valuePair, map) tecUtil.setAddMember(cachedZoneSet, valuePair.first + 1, ___1303); ___3491 zone; for (zone = tecUtil.___3489(zonesToWrite, ___4037); zone != ___4037; zone = tecUtil.___3489(zonesToWrite, zone)) { ___4633 sharedZone = (___4633)tecUtil.___542(cachedZoneSet, (___4633)zone); if (sharedZone != ___4033) { typename MapType::mapped_type const& partitionMap = map[sharedZone - 1]; BOOST_FOREACH(typename MapType::mapped_type::value_type const& partitionInfoPair, partitionMap) map[(___4633)zone - 1][partitionInfoPair.first] = map[sharedZone - 1][partitionInfoPair.first]; } } tecUtil.___3482(&cachedZoneSet); } } void ZoneInfoCache::replaceDataSource(___37* ___36, ___3499 zonesToWrite) { ___2335 = ___36; if (zonesToWrite) { shareZoneInfosInMap(zonesToWrite, m_ijkZoneInfos, *___2335); shareZoneInfosInMap(zonesToWrite, m_feZoneInfos, *___2335); shareZonePartitionInfosInMap(zonesToWrite, m_ijkZonePartitionInfos, *___2335); shareZonePartitionInfosInMap(zonesToWrite, m_feZonePartitionInfos, *___2335); } } }}
