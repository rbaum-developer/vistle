 #pragma once
#include "basicTypes.h"
#include "ClassMacros.h"
#include "ItemAddress.h"
#include "LightweightVector.h"
#include "RawArray.h"
#include "showMessage.h"
#include "StandardIntegralTypes.h"
namespace tecplot { namespace ___3931 { class CszConnectivity { UNCOPYABLE_CLASS(CszConnectivity); public: typedef uint16_t EntryIndex_t; CszConnectivity() : m_numCells(0) , m_numNodesPerCell(0) , m_numRefNszs(0) { } ~CszConnectivity() { ___935(); } bool empty() const { ENSURE(EQUIVALENCE(m_numCells > 0, m_numNodesPerCell > 0 && m_numRefNszs > 0)); ENSURE(EQUIVALENCE(m_numCells > 0, !m_refItemOffsets.empty() && !m_refSzOffsets.empty() && !m_refSzAddresses.empty())); return m_numCells == 0; } bool alloc( uint32_t ___2779, uint32_t numNodesPerCell, uint32_t numRefNszs); size_t numBytesAllocated(void) const; void ___935(); uint32_t getNumEntries() const; uint32_t getNumRefNszs() const; uint8_t* getItemOffsetArray(); uint8_t const* getItemOffsetArray() const; uint16_t* getRszOffsetArray(); uint16_t const * getRszOffsetArray() const; ItemAddress64::SubzoneAddress* getRefNszArray(); ItemAddress64::SubzoneAddress const* getRefNszArray() const; bool getRszAddresses(___3267<ItemAddress64::SubzoneAddress>& rszAddresses) const; ItemAddress64::SubzoneAddress const& getRszAddress(RefSubzoneOffset_t rszOffset) const; RefSubzoneOffset_t getRszOffset(EntryIndex_t entry) const; uint8_t getNodeOffset(EntryIndex_t entry) const; ItemAddress64 getNodeAddress(EntryIndex_t entry) const; private: uint32_t m_numCells; uint32_t m_numNodesPerCell; uint32_t m_numRefNszs; static ItemAddress64::ItemOffset_t const MAX_NUM_ITEM_OFFSETS = ItemAddress64::MAX_ITEM_OFFSET+1; ___2238<uint8_t>  m_refItemOffsets; ___2238<uint16_t> m_refSzOffsets; ___2238<ItemAddress64::SubzoneAddress> m_refSzAddresses; }; inline bool CszConnectivity::alloc( uint32_t ___2779, uint32_t numNodesPerCell, uint32_t numRefNszs) { REQUIRE(empty()); REQUIRE(___2779 > 0 && ___2779 <= MAX_NUM_ITEM_OFFSETS); REQUIRE(numNodesPerCell > 0 && numNodesPerCell <= MAX_NODES_PER_ELEM); REQUIRE(numRefNszs > 0 && numRefNszs <= ___2779*numNodesPerCell); m_numCells        = ___2779; m_numNodesPerCell = numNodesPerCell; m_numRefNszs      = numRefNszs; uint32_t const ___2793 = m_numCells*m_numNodesPerCell; return (m_refItemOffsets.alloc(___2793) && m_refSzOffsets.alloc(___2793) && m_refSzAddresses.alloc(m_numRefNszs)); } inline size_t CszConnectivity::numBytesAllocated(void) const { return !empty() ? (sizeof(m_numCells)+sizeof(m_numNodesPerCell)+sizeof(m_numRefNszs)+ m_refItemOffsets.numBytesAllocated(getNumEntries())+ m_refSzOffsets.numBytesAllocated(getNumEntries())+ m_refSzAddresses.numBytesAllocated(m_numRefNszs)) : static_cast<size_t>(0); } inline void CszConnectivity::___935() { if (!empty()) { m_numCells        = 0; m_numNodesPerCell = 0; m_numRefNszs      = 0; m_refItemOffsets.___935(); m_refSzOffsets.___935(); m_refSzAddresses.___935(); } ENSURE(empty()); } inline uint32_t CszConnectivity::getNumEntries() const { REQUIRE(!empty()); return m_numCells * m_numNodesPerCell; } inline uint32_t CszConnectivity::getNumRefNszs() const { REQUIRE(!empty()); ENSURE(0 < m_numRefNszs && m_numRefNszs <= getNumEntries());
return m_numRefNszs; } inline uint8_t* CszConnectivity::getItemOffsetArray() { REQUIRE(!empty()); return m_refItemOffsets.data(); } inline uint8_t const* CszConnectivity::getItemOffsetArray() const { REQUIRE(!empty()); return m_refItemOffsets.data(); } inline uint16_t* CszConnectivity::getRszOffsetArray() { REQUIRE(!empty()); return m_refSzOffsets.data(); } inline uint16_t const* CszConnectivity::getRszOffsetArray() const { REQUIRE(!empty()); return m_refSzOffsets.data(); } inline ItemAddress64::SubzoneAddress* CszConnectivity::getRefNszArray() { REQUIRE(!empty()); return m_refSzAddresses.data(); } inline ItemAddress64::SubzoneAddress const* CszConnectivity::getRefNszArray() const { REQUIRE(!empty()); return m_refSzAddresses.data(); } inline bool CszConnectivity::getRszAddresses(___3267<ItemAddress64::SubzoneAddress>& rszAddresses) const { REQUIRE(!empty()); REQUIRE(rszAddresses.empty()); bool ___2037 = ___4224; try { uint32_t const numRefNszs = getNumRefNszs(); ___476(numRefNszs > 0); rszAddresses.reserve(numRefNszs); rszAddresses.___3501(numRefNszs); ItemAddress64::SubzoneAddress const* refNszArray = getRefNszArray(); memcpy(rszAddresses.data(), refNszArray, numRefNszs*sizeof(ItemAddress64::SubzoneAddress)); } catch (std::bad_alloc const&) { ___2037 = ___1184("Out of memory getRszAddresses"); } return ___2037; } inline ItemAddress64::SubzoneAddress const& CszConnectivity::getRszAddress(RefSubzoneOffset_t rszOffset) const { REQUIRE(!empty()); REQUIRE(rszOffset < getNumRefNszs()); ItemAddress64::SubzoneAddress const* refNszArray = getRefNszArray(); ItemAddress64::SubzoneAddress const& ___2755 = refNszArray[rszOffset]; return ___2755; } inline RefSubzoneOffset_t CszConnectivity::getRszOffset(EntryIndex_t entry) const { REQUIRE(!empty()); REQUIRE(entry < getNumEntries()); uint16_t const* rszOffsetArray = getRszOffsetArray(); uint16_t const  rszOffset = rszOffsetArray[entry]; ENSURE(rszOffset < getNumRefNszs()); return rszOffset; } inline uint8_t CszConnectivity::getNodeOffset(EntryIndex_t entry) const { REQUIRE(!empty()); REQUIRE(entry < getNumEntries()); uint8_t const* itemOffsetArray = getItemOffsetArray(); uint8_t const  itemOffset = itemOffsetArray[entry]; return itemOffset; } inline ItemAddress64 CszConnectivity::getNodeAddress(EntryIndex_t entry) const { REQUIRE(!empty()); REQUIRE(entry < getNumEntries()); uint8_t const itemOffset = getNodeOffset(entry); uint16_t const rszOffset = getRszOffset(entry); ItemAddress64::SubzoneAddress const& nszAddress = getRszAddress(rszOffset); return ItemAddress64(nszAddress, itemOffset); } }}
