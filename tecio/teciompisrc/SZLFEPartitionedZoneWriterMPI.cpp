#include "SZLFEPartitionedZoneWriterMPI.h"
#include "ThirdPartyHeadersBegin.h"
#include <boost/make_shared.hpp>
#include <boost/unordered_map.hpp>
#include <boost/unordered_set.hpp>
#include "ThirdPartyHeadersEnd.h"
#include "FEZoneInfo.h"
#include "FieldData.h"
#include "FileWriterInterface.h"
#include "ItemSetIterator.h"
#include "MPICommunicationCache.h"
#include "MPICommunicator.h"
#include "MPIFileWriter.h"
#include "MPINonBlockingCommunicationCollection.h"
#include "MPIUtil.h"
#include "NodeMap.h"
#include "SZLFEPartitionWriter.h"
#include "TecioMPI.h"
#include "ZoneInfoCache.h"
using namespace tecplot::___3931; namespace tecplot { namespace teciompi { struct SZLFEPartitionedZoneWriterMPI::Impl { MPI_Comm m_comm; int m_mainProcess; int m_localProcess; bool m_useCollectiveRoutines; Impl(MPI_Comm comm, int mainProcess, ___37& ___36, ___4633 zone) : m_comm(comm) , m_mainProcess(mainProcess) , m_useCollectiveRoutines(everyRankOwnsOnePartition(comm, ___36, zone)) { MPI_Comm_rank(m_comm, &m_localProcess); } }; SZLFEPartitionedZoneWriterMPI::SZLFEPartitionedZoneWriterMPI( uint32_t                      fileVersion, ItemSetIterator&              varIter, ___4633                   zone, ___4633                   ___341, std::vector<___372> const& ___4561, ___372                     ___4496, ___37&                   ___36, ZoneInfoCache&                zoneInfoCache, MPI_Comm                      comm, int                           mainProcess) : SZLFEPartitionedZoneWriter(fileVersion, varIter, zone, ___341, ___4561, ___4496, ___36, zoneInfoCache) , m_impl(new Impl(comm, mainProcess, ___36, zone)) { createPartitionWriters(); } SZLFEPartitionedZoneWriterMPI::~SZLFEPartitionedZoneWriterMPI() {} ___2477 SZLFEPartitionedZoneWriterMPI::varMinMax(___4349 datasetVar) { REQUIRE(m_varIter.baseItem() <= datasetVar && datasetVar < m_varIter.___2810()); ___2477 ___3356; ___4349 const baseVar = m_varIter.baseItem(); for(___4633 ___2975 = 0; ___2975 < ___2335.zoneGetNumPartitions(___2675 + 1); ++___2975) ___3356.include(m_varPartitionMinMaxes[datasetVar - baseVar][___2975]); return ___3356; } void SZLFEPartitionedZoneWriterMPI::collateAndReturnResponses( MPINonBlockingCommunicationCollection& communicationCollection) { std::vector<std::vector<int> > referencingPartitions(___2335.zoneGetNumPartitions(___2675 + 1)); MPICommunicator communicator(m_impl->m_comm); for(___4633 i = 0; i < ___2335.zoneGetNumPartitions(___2675 + 1); ++i) { int ___3654 = ___2335.zonePartitionGetOwnerProcess(___2675 + 1, i + 1); SimpleVector<ItemAddress64::___2978> neighbors; communicator.receiveVector(neighbors, ___3654, TecioMPI::REFERENCED_PARTITIONS_SIZE, TecioMPI::REFERENCED_PARTITIONS_VEC); for (SimpleVector<ItemAddress64::___2978>::iterator neighbor = neighbors.begin(); neighbor != neighbors.end(); ++neighbor) referencingPartitions[*neighbor].push_back(i); } for(___4633 i = 0; i < ___2335.zoneGetNumPartitions(___2675 + 1); ++i) communicationCollection.sendVectorCopy( SimpleVector<int32_t>(referencingPartitions[i].begin(), referencingPartitions[i].end()), ___2335.zonePartitionGetOwnerProcess(___2675 + 1, i + 1), TecioMPI::REFERENCING_PARTITIONS_SIZE, TecioMPI::REFERENCING_PARTITIONS_VEC); } void SZLFEPartitionedZoneWriterMPI::exchangeGhostInfo( std::map<int, boost::shared_ptr<___3931::___1348> >& partitionInfoMap) { PartitionTecUtilDecorator partitionTecUtilDecorator(___2335, ___2675 + 1); ___4349 const numVarsToWrite = m_varIter.___2810();
ItemAddress64::___2978 numPartitions = static_cast<ItemAddress64::___2978>(___2335.zoneGetNumPartitions(___2675 + 1)); MPINonBlockingCommunicationCollection communicationCollection(m_impl->m_comm); std::map<int, NeighborCellSubzoneInfoMap> neighborCellSubzoneInfoMapMap; std::map<int, SimpleVector<int32_t> > referencingPartitionsMap; for(ItemAddress64::___2978 ___2975 = 0; ___2975 < numPartitions; ++___2975) { if (___2335.zonePartitionGetOwnerProcess(___2675 + 1, ___2975 + 1) != m_impl->m_localProcess) continue; ___2722 ___2721(&partitionTecUtilDecorator, ___2975 + 1); std::vector<___1350> fieldDatas(numVarsToWrite); m_varIter.reset(); ___4349 const baseVar = m_varIter.baseItem(); while (m_varIter.hasNext()) { ___4349 const datasetVar = m_varIter.next(); ___4349 const fileVar = datasetVar - baseVar; if (___2335.___4350(datasetVar + 1) && !___2335.___924(___2675 + 1, datasetVar + 1)) { if (___2335.___908(___2675 + 1, datasetVar + 1) == ___4327) fieldDatas[fileVar] = ___1350(&partitionTecUtilDecorator, ___2975 + 1, datasetVar + 1, false, false); else fieldDatas[fileVar] = ___1350(&partitionTecUtilDecorator, ___2975 + 1, datasetVar + 1, false, true); } } gatherNeighborCellSubzoneInfo(neighborCellSubzoneInfoMapMap[___2975], ___2975, numVarsToWrite, ___2721, fieldDatas, *(partitionInfoMap[___2975])); std::set<ItemAddress64::___2978> referencedPartitions; for (NeighborCellSubzoneInfoMap::iterator valuePair = neighborCellSubzoneInfoMapMap[___2975].begin(); valuePair != neighborCellSubzoneInfoMapMap[___2975].end(); ++valuePair) { ItemAddress64::___2978 const neighbor = valuePair->first; referencedPartitions.insert(neighbor); } if (!referencedPartitions.empty()) partitionInfoMap[___2975]->addReferencedPartitions(referencedPartitions); SimpleVector<ItemAddress64::___2978> partitionVector(referencedPartitions.begin(), referencedPartitions.end()); communicationCollection.sendVectorCopy(partitionVector, m_impl->m_mainProcess, TecioMPI::REFERENCED_PARTITIONS_SIZE, TecioMPI::REFERENCED_PARTITIONS_VEC); communicationCollection.receiveVector(referencingPartitionsMap[___2975], m_impl->m_mainProcess, TecioMPI::REFERENCING_PARTITIONS_SIZE, TecioMPI::REFERENCING_PARTITIONS_VEC); } if (m_impl->m_localProcess == m_impl->m_mainProcess) { collateAndReturnResponses(communicationCollection); } communicationCollection.___4443(); for(ItemAddress64::___2978 ___2975 = 0; ___2975 < numPartitions; ++___2975) { if (___2335.zonePartitionGetOwnerProcess(___2675 + 1, ___2975 + 1) != m_impl->m_localProcess) continue; for (NeighborCellSubzoneInfoMap::iterator valuePair = neighborCellSubzoneInfoMapMap[___2975].begin(); valuePair != neighborCellSubzoneInfoMapMap[___2975].end(); ++valuePair) { ItemAddress64::___2978 const neighbor = valuePair->first; int32_t partitionOwner = ___2335.zonePartitionGetOwnerProcess(___2675 + 1, neighbor + 1);
NeighborCellSubzoneInfo const& neighborCellSubzoneInfo = valuePair->second; ___476(!neighborCellSubzoneInfo.m_nodes.empty()); SimpleVector<int64_t> nodes(neighborCellSubzoneInfo.m_neighborNodes.begin(), neighborCellSubzoneInfo.m_neighborNodes.end()); MPICommunicationCache cache; cache.addVector(nodes, TecioMPI::REFERENCED_NODES); for(size_t i = 0; i < neighborCellSubzoneInfo.m_nodes.size(); ++i) { int32_t szOffset = 0; SimpleVector<uint64_t> rawCellSubzones(checked_numeric_cast<int32_t>( neighborCellSubzoneInfo.m_cellSubzones[i].size())); for (SubzoneAddressUnorderedSet::const_iterator ___467 = neighborCellSubzoneInfo.m_cellSubzones[i].begin(); ___467 != neighborCellSubzoneInfo.m_cellSubzones[i].end(); ++___467) { rawCellSubzones[szOffset++] = ___467->toRawBits(); } cache.addVector(rawCellSubzones, TecioMPI::REFERENCED_NODE_CELL_SUBZONES); SimpleVector<double> minMaxes(checked_numeric_cast<int>(2 * neighborCellSubzoneInfo.m_varMinMaxes[i].size())); int ind = 0; for (std::vector<___2477>::const_iterator minMax = neighborCellSubzoneInfo.m_varMinMaxes[i].begin(); minMax != neighborCellSubzoneInfo.m_varMinMaxes[i].end(); ++minMax) { minMaxes[ind++] = minMax->minValue(); minMaxes[ind++] = minMax->maxValue(); } cache.addVector(minMaxes, TecioMPI::REFERENCED_NODE_MINMAXES); } communicationCollection.sendVectorCopy(cache.data(), partitionOwner, TecioMPI::REFERENCED_NODE_CACHED_INFO_SIZE, TecioMPI::REFERENCED_NODE_CACHED_INFO_VEC); } } typedef std::map<ItemAddress64::___2978, std::set<ItemAddress64::___2978> > PartitionNeighborMap; PartitionNeighborMap receiveOrder; for(ItemAddress64::___2978 i = 0; i < numPartitions; ++i) { if (___2335.zonePartitionGetOwnerProcess(___2675 + 1, i + 1) != m_impl->m_localProcess) continue; for(int ___2103 = 0; ___2103 < referencingPartitionsMap[i].size(); ++___2103) receiveOrder[referencingPartitionsMap[i][___2103]].insert(i); } MPICommunicator mpiCommunicator(m_impl->m_comm); for (PartitionNeighborMap::iterator valuePair = receiveOrder.begin(); valuePair != receiveOrder.end(); ++valuePair) { ItemAddress64::___2978 const referencingPartition = valuePair->first; for (std::set<ItemAddress64::___2978>::iterator ___2975 = valuePair->second.begin(); ___2975 != valuePair->second.end(); ++___2975) { ___476(___2335.zonePartitionGetOwnerProcess(___2675 + 1, *___2975 + 1) == m_impl->m_localProcess); int32_t partitionOwner = ___2335.zonePartitionGetOwnerProcess(___2675 + 1, referencingPartition + 1); SimpleVector<uint8_t> cachedData; mpiCommunicator.receiveVector(cachedData, partitionOwner, TecioMPI::REFERENCED_NODE_CACHED_INFO_SIZE, TecioMPI::REFERENCED_NODE_CACHED_INFO_VEC); MPICommunicationCache cache(cachedData); SimpleVector <int64_t>nodeVector; cache.retrieveVector(nodeVector, TecioMPI::REFERENCED_NODES); std::vector<___2716> nodes(nodeVector.begin(), nodeVector.end()); std::vector<SubzoneAddressUnorderedSet> cellSubzones; std::vector<std::vector<___2477> > varMinMaxes; for(int ___2103 = 0; ___2103 < nodeVector.size(); ++___2103)
{ SimpleVector<uint64_t> rawCellSubzones; cache.retrieveVector(rawCellSubzones, TecioMPI::REFERENCED_NODE_CELL_SUBZONES); SubzoneAddressUnorderedSet cellSubzonesSet; for (SimpleVector<uint64_t>::const_iterator rawCellSubzone = rawCellSubzones.begin(); rawCellSubzone != rawCellSubzones.end(); ++rawCellSubzone) { cellSubzonesSet.insert(ItemAddress64::SubzoneAddress::fromRawBits(*rawCellSubzone)); } cellSubzones.push_back(cellSubzonesSet); SimpleVector<double> minMaxesVector; cache.retrieveVector(minMaxesVector, TecioMPI::REFERENCED_NODE_MINMAXES); int ___2841 = minMaxesVector.size() / 2; std::vector<___2477> nodeMinMaxes(___2841); for(int ___4289 = 0; ___4289 < ___2841; ++___4289) { nodeMinMaxes[___4289].include(minMaxesVector[2 * ___4289]); nodeMinMaxes[___4289].include(minMaxesVector[2 * ___4289 + 1]); } varMinMaxes.push_back(nodeMinMaxes); } partitionInfoMap[*___2975]->addNeighborCszInfo(referencingPartition, nodes, cellSubzones, varMinMaxes); SimpleVector<uint32_t> nodeSubzoneOffsets(nodeVector.size()); SimpleVector<uint16_t> nodeItemOffsets(nodeVector.size()); for(int ___2103 = 0; ___2103 < nodeVector.size(); ++___2103) { ItemAddress64 const nodeAddress(partitionInfoMap[*___2975]->itemAddressAtNode(nodeVector[___2103])); nodeSubzoneOffsets[___2103] = nodeAddress.subzoneOffset(); nodeItemOffsets[___2103] = nodeAddress.itemOffset(); } communicationCollection.sendVectorCopy(nodeSubzoneOffsets, partitionOwner, TecioMPI::REFERENCED_NODE_SUBZONES_SIZE, TecioMPI::REFERENCED_NODE_SUBZONES_VEC); communicationCollection.sendVectorCopy(nodeItemOffsets, partitionOwner, TecioMPI::REFERENCED_NODE_OFFSETS_SIZE, TecioMPI::REFERENCED_NODE_OFFSETS_VEC); } } for(ItemAddress64::___2978 ___2975 = 0; ___2975 < numPartitions; ++___2975) { if (___2335.zonePartitionGetOwnerProcess(___2675 + 1, ___2975 + 1) != m_impl->m_localProcess) continue; for (NeighborCellSubzoneInfoMap::iterator valuePair = neighborCellSubzoneInfoMapMap[___2975].begin(); valuePair != neighborCellSubzoneInfoMapMap[___2975].end(); ++valuePair) { ItemAddress64::___2978 const neighborPartition = valuePair->first; int32_t partitionOwner = ___2335.zonePartitionGetOwnerProcess(___2675 + 1, neighborPartition + 1); NeighborCellSubzoneInfo const& neighborCellSubzoneInfo = valuePair->second; SimpleVector<uint32_t> nodeSubzoneOffsets; SimpleVector<uint16_t> nodeItemOffsets; mpiCommunicator.receiveVector(nodeSubzoneOffsets, partitionOwner, TecioMPI::REFERENCED_NODE_SUBZONES_SIZE, TecioMPI::REFERENCED_NODE_SUBZONES_VEC); mpiCommunicator.receiveVector(nodeItemOffsets, partitionOwner, TecioMPI::REFERENCED_NODE_OFFSETS_SIZE, TecioMPI::REFERENCED_NODE_OFFSETS_VEC); ___476(static_cast<size_t>(nodeSubzoneOffsets.size()) == neighborCellSubzoneInfo.m_nodes.size()); ___476(static_cast<size_t>(nodeItemOffsets.size()) == neighborCellSubzoneInfo.m_nodes.size()); for(int i = 0; i < static_cast<int>(neighborCellSubzoneInfo.m_nodes.size()); ++i) { ItemAddress64 const nodeAddress(neighborPartition, 0 , nodeSubzoneOffsets[i], nodeItemOffsets[i]); partitionInfoMap[___2975]->addNeighborNodeCoordinate(neighborCellSubzoneInfo.m_nodes[i], nodeAddress);
} } } if (!communicationCollection.isComplete()) communicationCollection.___4443(); } void SZLFEPartitionedZoneWriterMPI::createPartitionWriters() { ___4262 const datasetID = ___2335.datasetGetUniqueID(); ___1170 numSections = 1; if (___2335.___4617(___2675 + 1) == ZoneType_FEMixed) { if (!___2335.zoneGetNumSections(datasetID, ___2675 + 1, &numSections)) throw std::runtime_error("failed to get zone section information"); } ___476(m_secPtnNumCells.size() == static_cast<size_t>(numSections)); std::map<int, boost::shared_ptr<___1348> > partitionInfoMap; for(___4633 ___2975 = 0; ___2975 < ___2335.zoneGetNumPartitions(___2675 + 1); ++___2975) { if (___2335.zonePartitionGetOwnerProcess(___2675 + 1, ___2975 + 1) != m_impl->m_localProcess) continue; partitionInfoMap[___2975] = ___2678.getFEZonePartitionInfo(___2675, ___2975, m_partitionTecUtil); for (___1170 section = 0; section < numSections; ++section) m_secPtnNumCells[section][___2975] = partitionInfoMap[___2975]->numCellsInSection(section) - partitionInfoMap[___2975]->getNumGhostCells(section); m_partitionNumNodes[___2975] = partitionInfoMap[___2975]->___1766() - partitionInfoMap[___2975]->getNumGhostNodes(); } exchangeGhostInfo(partitionInfoMap); for(___4633 ___2975 = 0; ___2975 < ___2335.zoneGetNumPartitions(___2675 + 1); ++___2975) { if (___2335.zonePartitionGetOwnerProcess(___2675 + 1, ___2975 + 1) == m_impl->m_localProcess) m_partitionWriters[___2975] = boost::make_shared<SZLFEPartitionWriter> ( m_fileVersion, boost::ref(m_varIter), ___2675, m_baseZone, ___2975, boost::ref(m_writeVariables), m_writeConnectivity, boost::ref(m_partitionTecUtil), partitionInfoMap[___2975]); } } ___372 SZLFEPartitionedZoneWriterMPI::writeZoneHeader(___3931::FileWriterInterface& szpltFile) { if (m_impl->m_localProcess == m_impl->m_mainProcess) return SZLFEPartitionedZoneWriter::writeZoneHeader(szpltFile); else return ___4224; } uint64_t SZLFEPartitionedZoneWriterMPI::zoneHeaderFileSize(bool ___2000) { if (m_impl->m_localProcess == m_impl->m_mainProcess) return SZLFEPartitionedZoneWriter::zoneHeaderFileSize(___2000); else return 0; } ___372 SZLFEPartitionedZoneWriterMPI::writeZoneData(___3931::FileWriterInterface& szpltFile) { ___1391 fileLoc = szpltFile.fileLoc(); boost::unordered_map<___4633, ___1391> partitionFileLocMap; uint64_t localPartitionFileSize = 0; if (m_impl->m_useCollectiveRoutines) { ___476(m_partitionWriters.size() == 1); ___4633 localPartition = m_partitionWriters.begin()->first; localPartitionFileSize = m_partitionWriters[localPartition]->zoneFileSize(szpltFile.___2000() == ___4224); gatherScatterPartitionFileLocs(fileLoc, partitionFileLocMap[localPartition], ___2335, ___2675, m_impl->m_localProcess, localPartitionFileSize, m_impl->m_mainProcess, m_impl->m_comm); } else if (m_impl->m_localProcess == m_impl->m_mainProcess) { MPICommunicator communicator(m_impl->m_comm); for (___4633 ___2975 = 0; ___2975 < ___2335.zoneGetNumPartitions(___2675 + 1); ++___2975)
{ uint64_t partitionFileSize; int32_t partitionOwner = ___2335.zonePartitionGetOwnerProcess(___2675 + 1, ___2975 + 1); if (partitionOwner == m_impl->m_localProcess) { partitionFileLocMap[___2975] = fileLoc; partitionFileSize = m_partitionWriters[___2975]->zoneFileSize(szpltFile.___2000() == ___4224); } else { communicator.sendScalar(fileLoc, partitionOwner, TecioMPI::PARTITION_FILE_LOC); communicator.receiveScalar(partitionFileSize, partitionOwner, TecioMPI::PARTITION_FILE_SIZE); } fileLoc += partitionFileSize; } } else { MPINonBlockingCommunicationCollection communicationCollection(m_impl->m_comm); for (___4633 ___2975 = 0; ___2975 < ___2335.zoneGetNumPartitions(___2675 + 1); ++___2975) { if (___2335.zonePartitionGetOwnerProcess(___2675 + 1, ___2975 + 1) == m_impl->m_localProcess) { uint64_t partitionSize = m_partitionWriters[___2975]->zoneFileSize(szpltFile.___2000() == ___4224); communicationCollection.sendScalarCopy(partitionSize, m_impl->m_mainProcess, TecioMPI::PARTITION_FILE_SIZE); communicationCollection.receiveScalar(partitionFileLocMap[___2975], m_impl->m_mainProcess, TecioMPI::PARTITION_FILE_LOC); } } communicationCollection.___4443(); } ___4262 const datasetID = ___2335.datasetGetUniqueID(); ___1170 numSections = 1; if (___2335.___4617(___2675 + 1) == ZoneType_FEMixed) { if (!___2335.zoneGetNumSections(datasetID, ___2675 + 1, &numSections)) throw std::runtime_error("failed to get zone section information"); } if (m_impl->m_useCollectiveRoutines) { ___476(m_partitionWriters.size() == 1 && localPartitionFileSize > 0); ___4633 localPartition = m_partitionWriters.begin()->first; MPIFileWriter& fileWriter = dynamic_cast<MPIFileWriter&>(szpltFile); boost::scoped_ptr<MPIFileWriter::ScopedCaching> scopedCaching; try { scopedCaching.reset(new MPIFileWriter::ScopedCaching(fileWriter, localPartitionFileSize)); } catch (...) { } m_partitionWriters[localPartition]->writeZone(szpltFile, partitionFileLocMap[localPartition]); m_partitionHeaderFilePositions[localPartition] = m_partitionWriters[localPartition]->getZoneHeaderFilePosition(); MPICommunicationCache cache; cache.addScalar(m_partitionHeaderFilePositions[localPartition], TecioMPI::PARTITION_HEADER_FILE_LOC); SimpleVector<int64_t> numCellsPerSection(numSections); for (___1170 section = 0; section < numSections; ++section) numCellsPerSection[section] = m_secPtnNumCells[section][localPartition]; cache.addVector(numCellsPerSection, TecioMPI::PARTITION_NUM_CELLS); cache.addScalar(m_partitionNumNodes[localPartition], TecioMPI::PARTITION_NUM_NODES); SimpleVector<___2477> minMaxValues(m_varIter.___2810()); m_varIter.reset(); int i = 0; while (m_varIter.hasNext()) { ___4349 const datasetVar = m_varIter.next(); minMaxValues[i++] = m_partitionWriters[localPartition]->varMinMax(datasetVar); } cache.addVector(minMaxValues, TecioMPI::PARTITION_VAR_MINMAX_VALUES); SimpleVector<uint8_t> cachedData = cache.data(); int bytesPerPartition = cachedData.size();
std::vector<uint8_t> serializedCaches(static_cast<size_t>(bytesPerPartition)* ___2335.zoneGetNumPartitions(___2675 + 1)); MPI_Gather(&cachedData[0], bytesPerPartition, MPI_UINT8_T, serializedCaches.data(), bytesPerPartition, MPI_UINT8_T, m_impl->m_mainProcess, m_impl->m_comm); if (m_impl->m_localProcess == m_impl->m_mainProcess) { for (___4633 ___2975 = 0; ___2975 < ___2335.zoneGetNumPartitions(___2675 + 1); ++___2975) { MPICommunicationCache partitionCache(&serializedCaches[___2975 * bytesPerPartition], bytesPerPartition); int32_t partitionOwner = ___2335.zonePartitionGetOwnerProcess(___2675 + 1, ___2975 + 1); partitionCache.retrieveScalar(m_partitionHeaderFilePositions[___2975], TecioMPI::PARTITION_HEADER_FILE_LOC); SimpleVector<int64_t> partitionNumCellsPerSection; partitionCache.retrieveVector(partitionNumCellsPerSection, TecioMPI::PARTITION_NUM_CELLS); for (___1170 section = 0; section < numSections; ++section) m_secPtnNumCells[section][___2975] = partitionNumCellsPerSection[section]; partitionCache.retrieveScalar(m_partitionNumNodes[___2975], TecioMPI::PARTITION_NUM_NODES); SimpleVector<___2477> partitionMinMaxValues; partitionCache.retrieveVector(partitionMinMaxValues, TecioMPI::PARTITION_VAR_MINMAX_VALUES); ___476(partitionMinMaxValues.size() == m_varIter.___2810()); m_varIter.reset(); ___4349 const baseVar = m_varIter.baseItem(); while (m_varIter.hasNext()) { ___4349 const fileVar = m_varIter.next() - baseVar; m_varPartitionMinMaxes[fileVar][partitionOwner] = partitionMinMaxValues[fileVar]; } } } } else { for (___4633 ___2975 = 0; ___2975 < ___2335.zoneGetNumPartitions(___2675 + 1); ++___2975) { int32_t partitionOwner = ___2335.zonePartitionGetOwnerProcess(___2675 + 1, ___2975 + 1); if (partitionOwner == m_impl->m_localProcess) { m_partitionWriters[___2975]->writeZone(szpltFile, partitionFileLocMap[___2975]); m_partitionHeaderFilePositions[___2975] = m_partitionWriters[___2975]->getZoneHeaderFilePosition(); if (m_impl->m_localProcess == m_impl->m_mainProcess) { m_varIter.reset(); ___4349 const baseVar = m_varIter.baseItem(); while (m_varIter.hasNext()) { ___4349 const datasetVar = m_varIter.next(); m_varPartitionMinMaxes[datasetVar - baseVar][___2975] = m_partitionWriters[___2975]->varMinMax(datasetVar); } } else { MPICommunicationCache cache; cache.addScalar(m_partitionHeaderFilePositions[___2975], TecioMPI::PARTITION_HEADER_FILE_LOC); SimpleVector<int64_t> numCellsPerSection(numSections); for (___1170 section = 0; section < numSections; ++section) numCellsPerSection[section] = m_secPtnNumCells[section][___2975]; cache.addVector(numCellsPerSection, TecioMPI::PARTITION_NUM_CELLS); cache.addScalar(m_partitionNumNodes[___2975], TecioMPI::PARTITION_NUM_NODES); SimpleVector<___2477> minMaxValues(m_varIter.___2810()); m_varIter.reset(); int i = 0; while (m_varIter.hasNext()) { ___4349 const datasetVar = m_varIter.next(); minMaxValues[i++] = m_partitionWriters[___2975]->varMinMax(datasetVar);
} cache.addVector(minMaxValues, TecioMPI::PARTITION_VAR_MINMAX_VALUES); MPICommunicator(m_impl->m_comm).sendVector(cache.data(), m_impl->m_mainProcess, TecioMPI::PARTITION_CACHED_INFO_SIZE, TecioMPI::PARTITION_CACHED_INFO_VEC); } } else if (m_impl->m_localProcess == m_impl->m_mainProcess) { MPICommunicator communicator(m_impl->m_comm); SimpleVector<uint8_t> cachedData; communicator.receiveVector(cachedData, partitionOwner, TecioMPI::PARTITION_CACHED_INFO_SIZE, TecioMPI::PARTITION_CACHED_INFO_VEC); MPICommunicationCache cache(cachedData); SimpleVector<___2477> minMaxValues; cache.retrieveScalar(m_partitionHeaderFilePositions[___2975], TecioMPI::PARTITION_HEADER_FILE_LOC); SimpleVector<int64_t> numCellsPerSection; cache.retrieveVector(numCellsPerSection, TecioMPI::PARTITION_NUM_CELLS); for (___1170 section = 0; section < numSections; ++section) m_secPtnNumCells[section][___2975] = numCellsPerSection[section]; cache.retrieveScalar(m_partitionNumNodes[___2975], TecioMPI::PARTITION_NUM_NODES); cache.retrieveVector(minMaxValues, TecioMPI::PARTITION_VAR_MINMAX_VALUES); ___476(minMaxValues.size() == m_varIter.___2810()); m_varIter.reset(); ___4349 const baseVar = m_varIter.baseItem(); while (m_varIter.hasNext()) { ___4349 const fileVar = m_varIter.next() - baseVar; m_varPartitionMinMaxes[fileVar][___2975] = minMaxValues[fileVar]; } } } } if (m_impl->m_localProcess == m_impl->m_mainProcess) szpltFile.___3457(fileLoc);
 #if !defined NO_ASSERTS
if (m_impl->m_localProcess != m_impl->m_mainProcess) szpltFile.___3457(0);
 #endif
return ___4224; } uint64_t SZLFEPartitionedZoneWriterMPI::zoneDataFileSize(bool ___2000) { uint64_t ___3356 = 0; MPICommunicator communicator(m_impl->m_comm); if (m_impl->m_localProcess == m_impl->m_mainProcess) { for(___4633 ___2975 = 0; ___2975 < ___2335.zoneGetNumPartitions(___2675 + 1); ++___2975) { uint64_t partitionFileSize; int partitionOwner = ___2335.zonePartitionGetOwnerProcess(___2675 + 1, ___2975 + 1); if (partitionOwner == m_impl->m_localProcess) partitionFileSize = m_partitionWriters[___2975]->zoneFileSize(___2000); else communicator.receiveScalar(partitionFileSize, partitionOwner, TecioMPI::PARTITION_FILE_SIZE); ___3356 += partitionFileSize; } } else { for(___4633 ___2975 = 0; ___2975 < ___2335.zoneGetNumPartitions(___2675 + 1); ++___2975) { int partitionOwner = ___2335.zonePartitionGetOwnerProcess(___2675 + 1, ___2975 + 1); if (partitionOwner == m_impl->m_localProcess) { uint64_t partitionFileSize = m_partitionWriters[___2975]->zoneFileSize(___2000); communicator.sendScalar(partitionFileSize, m_impl->m_mainProcess, TecioMPI::PARTITION_FILE_SIZE); } } } return ___3356; } }}
