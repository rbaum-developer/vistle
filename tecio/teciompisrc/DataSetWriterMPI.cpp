#include "DataSetWriterMPI.h"
#include "ThirdPartyHeadersBegin.h"
#include <boost/foreach.hpp>
#include <boost/static_assert.hpp>
#include <boost/unordered_map.hpp>
#include "ThirdPartyHeadersEnd.h"
#include "FieldData.h"
#include "FileWriterInterface.h"
#include "ItemSetIterator.h"
#include "MPICommunicator.h"
#include "MPINonBlockingCommunicationCollection.h"
#include "NodeMap.h"
#include "TecioMPI.h"
#include "zoneUtil.h"
#include "ZoneWriterAbstract.h"
#include "ZoneWriterFactoryMPI.h"
using namespace tecplot::___3931; namespace tecplot { namespace teciompi { DataSetWriterMPI::DataSetWriterMPI( ___37*                 ___36, ___3499                      vars, ___3499                      ___4668, ___1842 const&                  maxIJKSubzoneSize, ItemAddress64::ItemOffset_t maxFESubzoneSize, MPI_Comm                    communicator, int                         mainProcess, int                         localProcess, bool                        flushToDisk  ) : DataSetWriter(___36, vars, ___4668, maxIJKSubzoneSize, maxFESubzoneSize, flushToDisk) , m_communicator(communicator) , m_mainProcess(mainProcess) , m_localProcess(localProcess) {} DataSetWriterMPI::~DataSetWriterMPI() {} ___372 DataSetWriterMPI::writeDataSet( FileWriterInterface& szpltFile, uint32_t             fileVersion, ___1390&        szpltZoneHeaderFileLocs) { REQUIRE(szpltFile.___2039()); if (!___2335->___894()) return ___4224; ___372 ___2037 = ___4224; try { ZoneWriterFactoryMPI ___4707(___2678, *___2335, m_communicator, m_mainProcess); boost::unordered_map<___4633, boost::shared_ptr<___4706> > zoneWriterMap; std::vector<int32_t> localZoneIndices; std::vector<int32_t> partitionedZones; int32_t ___2844 = static_cast<int32_t>(m_zoneIter->___2810()); std::vector<int32_t> zoneOwners(___2844, -1); m_zoneIter->reset(); ___4633 const ___341 = m_zoneIter->baseItem(); while (___2037 && m_zoneIter->hasNext()) { ___4633 const ___902 = m_zoneIter->next(); ___4633 const fileZoneIndex = ___902 - ___341; if (!___2335->___4635(___902 + 1)) continue; if (___2335->zoneIsPartitioned(___902 + 1)) zoneOwners[fileZoneIndex] = m_mainProcess; else zoneOwners[fileZoneIndex] = ___2335->zoneGetOwnerProcess(___902 + 1); if (zoneOwners[fileZoneIndex] == m_localProcess) localZoneIndices.push_back(fileZoneIndex); else if (m_localProcess != m_mainProcess) partitionedZones.push_back(fileZoneIndex); if (___2335->zoneIsPartitioned(___902 + 1) || zoneOwners[fileZoneIndex] == m_localProcess) { std::vector<___372> ___4561; ___372 ___4496; getZoneSharing(___4561, ___4496, ___902, ___341, szpltFile.___842()); zoneWriterMap[fileZoneIndex] = ___4707.___4705(fileVersion, *m_varIter, ___902, m_flushingToDisk ? 0 : ___341, ___4561, ___4496); } } int32_t const numLocalZones = static_cast<int32_t>(localZoneIndices.size()); std::vector<uint64_t> localZoneSizes; BOOST_FOREACH(int32_t localZoneIndex, localZoneIndices) localZoneSizes.push_back(zoneWriterMap[localZoneIndex]->zoneFileSize(szpltFile.___2000() == ___4224)); BOOST_FOREACH(int32_t localZoneIndex, partitionedZones) (void)zoneWriterMap[localZoneIndex]->zoneFileSize(szpltFile.___2000() == ___4224); std::vector<uint64_t> zoneSizes(1); std::vector<int32_t> numZonesPerRank(1, 0); std::vector<int32_t> offsets(1, 0); if (m_localProcess == m_mainProcess)
{ int32_t numRanks; MPI_Comm_size(m_communicator, &numRanks); numZonesPerRank.resize(numRanks, 0); offsets.resize(numRanks + 1, 0); BOOST_FOREACH(int32_t owner, zoneOwners) ++numZonesPerRank[owner]; for (int32_t i = 0; i < numRanks; ++i) offsets[i + 1] = offsets[i] + numZonesPerRank[i]; zoneSizes.resize(___2844); } if (localZoneSizes.empty()) localZoneSizes.resize(1); MPI_Gatherv(localZoneSizes.data(), numLocalZones, MPI_UINT64_T, zoneSizes.data(), numZonesPerRank.data(), offsets.data(), MPI_UINT64_T, m_mainProcess, m_communicator); std::vector<uint64_t> zoneFileLocs(1); std::vector<uint64_t> localZoneFileLocs(std::max(1, numLocalZones)); if (m_localProcess == m_mainProcess) { int32_t numRanks; MPI_Comm_size(m_communicator, &numRanks); zoneFileLocs.resize(___2844); std::vector<int32_t> tempNumZonesPerRank(numRanks, 0); ___1391 fileLoc = szpltFile.fileLoc(); for (int i = 0; i < ___2844; ++i) { int32_t const owner = zoneOwners[i]; int32_t const zoneOffset = offsets[owner] + tempNumZonesPerRank[owner]++; zoneFileLocs[zoneOffset] = fileLoc; fileLoc += zoneSizes[zoneOffset]; } } MPI_Scatterv(zoneFileLocs.data(), numZonesPerRank.data(), offsets.data(), MPI_UINT64_T, localZoneFileLocs.data(), numLocalZones, MPI_UINT64_T, m_mainProcess, m_communicator); boost::unordered_map<___4633, ___1391> localZoneFileLocMap; for (int i = 0; i < numLocalZones; ++i) localZoneFileLocMap[localZoneIndices[i]] = localZoneFileLocs[i]; std::vector<uint64_t> localHeaderFileLocations; localHeaderFileLocations.reserve(std::max((size_t)1, localZoneIndices.size())); std::vector<___2477> localMinMaxes; int32_t const ___2841 = m_varIter->___2810(); localMinMaxes.reserve(static_cast<size_t>(___2841) * numLocalZones); m_zoneIter->reset(); while (___2037 && m_zoneIter->hasNext()) { ___4633 const ___902 = m_zoneIter->next(); ___4633 const fileZone = ___902 - ___341; if (!___2335->___4635(___902 + 1)) continue; if (___2335->zoneIsPartitioned(___902 + 1) || zoneOwners[fileZone] == m_localProcess) { ___2037 = zoneWriterMap[fileZone]->writeZone(szpltFile, localZoneFileLocMap[fileZone]); } if (zoneOwners[fileZone] == m_localProcess) { localHeaderFileLocations.push_back(zoneWriterMap[fileZone]->getZoneHeaderFilePosition()); m_varIter->reset(); while (m_varIter->hasNext()) { ___4349 const ___4333 = m_varIter->next(); localMinMaxes.push_back(zoneWriterMap[fileZone]->varMinMax(___4333)); } } zoneWriterMap.erase(fileZone); if (szpltFile.___842() == ___843) ___2678.remove(fileZone); } if (localHeaderFileLocations.empty()) localHeaderFileLocations.resize(1); std::vector<uint64_t> rankOrderZoneHeaderFileLocs(___2844); MPI_Gatherv(localHeaderFileLocations.data(), numLocalZones, MPI_UINT64_T, rankOrderZoneHeaderFileLocs.data(), numZonesPerRank.data(), offsets.data(), MPI_UINT64_T, m_mainProcess, m_communicator); if (m_localProcess == m_mainProcess) { std::vector<int32_t> tempNumZonesPerRank(numZonesPerRank.size(), 0); for(size_t i = 0; i < zoneOwners.size(); ++i)
{ int32_t const owner = zoneOwners[i]; int32_t const zoneOffset = offsets[owner] + tempNumZonesPerRank[owner]++; szpltZoneHeaderFileLocs[i] = rankOrderZoneHeaderFileLocs[zoneOffset]; } ___476(tempNumZonesPerRank == numZonesPerRank); } BOOST_STATIC_ASSERT(sizeof(___2477) == 2 * sizeof(double)); std::vector<___2477> rankOrderMinMaxes(1); std::vector<int32_t> numValuesPerRank(1); if (m_localProcess == m_mainProcess) { rankOrderMinMaxes.resize(___2844 * ___2841); numValuesPerRank.resize(numZonesPerRank.size()); for (size_t i = 0; i < numZonesPerRank.size(); ++i) { numValuesPerRank[i] = 2 * ___2841 * numZonesPerRank[i]; offsets[i] *= (2 * ___2841); } } if (localMinMaxes.empty()) localMinMaxes.resize(1); MPI_Gatherv(localMinMaxes.data(), 2 * numLocalZones * ___2841, MPI_DOUBLE, rankOrderMinMaxes.data(), numValuesPerRank.data(), offsets.data(), MPI_DOUBLE, m_mainProcess, m_communicator); if (m_localProcess == m_mainProcess) { BOOST_FOREACH(int32_t& ___2863, offsets) ___2863 /= 2; std::vector<int32_t> tempNumZonesPerRank(numZonesPerRank.size(), 0); for (size_t zone = 0; zone < zoneOwners.size(); ++zone) { int32_t const owner = zoneOwners[zone]; int32_t const zoneOffset = offsets[owner] + ___2841 * tempNumZonesPerRank[owner]++; for (int ___4333 = 0; ___4333 < ___2841; ++___4333) { ___4633 const shareZone = m_zoneVarMetadata->m_vzShareVarWithZone[___4333][zone]; ___4633 const fileShareZone = shareZone - ___341; ___476(IMPLICATION(shareZone != NOT_SHARED && fileShareZone < 0, m_flushingToDisk)); if (shareZone == NOT_SHARED || fileShareZone < 0) m_zoneVarMetadata->m_vzMinMaxes[___4333][zone] = rankOrderMinMaxes[static_cast<size_t>(zoneOffset) + ___4333]; else m_zoneVarMetadata->m_vzMinMaxes[___4333][zone] = m_zoneVarMetadata->m_vzMinMaxes[___4333][fileShareZone]; } } } } catch(std::exception const& e) { ___2037 = ___1184(e.what()); } return ___2037; } }}
